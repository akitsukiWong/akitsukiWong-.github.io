{"meta":{"title":"渣博客","subtitle":"哈哈哈","description":"汪秋月的个人博客","author":"汪秋月","url":"https://akitsukiwong.github.io"},"pages":[{"title":"关于我","date":"2018-05-10T16:15:47.000Z","updated":"2021-02-26T16:49:29.490Z","comments":true,"path":"about/index.html","permalink":"https://akitsukiwong.github.io/about/index.html","excerpt":"","text":"这是一个渣渣前端的个人博客 个人简历网站版 http://dflxm.oschina.io"},{"title":"canvas","date":"2021-02-05T02:11:19.000Z","updated":"2021-02-26T16:49:29.490Z","comments":true,"path":"canvas/index-1.html","permalink":"https://akitsukiwong.github.io/canvas/index-1.html","excerpt":"","text":"canvas var c = document.getElementById(“myCanvas”); var cxt = c.getContext(“2d”); cxt.fillStyle = “#FF0000”; cxt.fillRect(0, 0, 150, 75);"},{"title":"canvas","date":"2021-02-05T02:10:28.000Z","updated":"2021-02-26T16:49:29.490Z","comments":true,"path":"canvas/index.html","permalink":"https://akitsukiwong.github.io/canvas/index.html","excerpt":"","text":"canvas var c = document.getElementById(“myCanvas”); var cxt = c.getContext(“2d”); cxt.fillStyle = “#FF0000”; cxt.fillRect(0, 0, 150, 75);"},{"title":"Markdown学习","date":"2017-11-13T07:16:21.000Z","updated":"2021-02-26T16:49:29.522Z","comments":true,"path":"md/2017-11-13 Markdown学习.html","permalink":"https://akitsukiwong.github.io/md/2017-11-13 Markdown学习.html","excerpt":"","text":"一级标题H1二级标题H2三级标题H3四级标题H4五级标题H5六级标题H6无序列表 列表1 列表2 列表3 或者 列表1 列表1 列表1 再或者 列表1 列表1 列表1 引用 这个样子引用，啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦 还有个二级的引用，哈哈哈哈哈哈哈哈哈哈哈哈或或或或或或或或或或或或或或或或或或或或或 三级的引用，看了啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦 回归一级吧，记得要空一行 例子 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 代码区块这是一个普通段落： 这是一个代码区块。 前面一个制表符就是代码 或者四个空格 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理 分割线 链接I get 10 times more traffic from Google than fromYahoo or MSN. I get 10 times more traffic from Google than fromYahoo or MSN. 一小段代码Use the printf() function.There is a literal backtick (`) here.A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 dog bird cat foo foo foo bar bar bar baz baz baz"},{"title":"数组常用方法","date":"2017-11-20T07:04:48.000Z","updated":"2021-02-26T16:49:29.522Z","comments":true,"path":"md/2017-11-20 数组常用方法.html","permalink":"https://akitsukiwong.github.io/md/2017-11-20 数组常用方法.html","excerpt":"","text":"栈方法push() 接收任意数量的参数逐个添加到数组末尾（从末尾加） pop() 从数组末尾移除最后一项（删最后一个） 队列方法shift() 移除数组中的第一个项（删第一个） unshift() 在数组前端添加任意个项（从前面加） 重排列方法reverse() 翻转数组项的顺序 sort() 升序排列（首字母排序，不是按大小） 比较函数升序12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //0,1,5,10,15 降序12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //15,10,5,1,0 操作方法concat() 末尾添加数组 1contan( [ &quot;black&quot; , &quot;yellow&quot; , &quot;red&quot; ] ) splice() 数组中部插入项 删除splice（要删除的第一项的位置， 要删除的项数） splice( 0, 2 ) 删除数组中前两项 插入splice( 起始位置， 0（要删除的项数）， 要插入的项) splice( 2, 0, &quot;red&quot;, &quot;green&quot; )从当前数组的位置2 开始插入字符串“red” 和“green” 替换splice( 起始位置， 要删除的项数， 要插入的任意数量的项) splice( 2, 1, &quot;red&quot;, &quot;green&quot; ) 会删除当前数组位置 2 的项， 然后再从位置 2 开始插入字符串 “red” 和“green” 例子 123456789101112var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1); //remove the first itemalert(colors); //green,bluealert(removed); //red - one item array removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); //insert two items at position 1alert(colors); //green,yellow,orange,bluealert(removed); //empty array removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //insert two values, remove onealert(colors); //green,red,purple,orange,bluealert(removed); //yellow - one item array 位置方法indexOf() 从数组的开头（位置0）开始向后查找， 没找到的情况下会返回-1 lastIndexOf 从数组的末尾开始向前查找， 没找到的情况下会返回-1 例子 1234567891011121314var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5 alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3 var person = &#123; name: &quot;Nicholas&quot; &#125;;var people = [&#123; name: &quot;Nicholas&quot; &#125;];var morePeople = [person]; alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 迭代方法every() 对数组中的每一项运行给定函数， 如果该函数对每一项都返回true， 则返回true。 filter() 对数组中的每一项运行给定函数， 返回该函数会返回 true 的项组成的数组。 forEach() 对数组中的每一项运行给定的函数。 这个方法没有返回值。 map() 对数组中的每一项运行给定的函数， 返回每次函数调用的结果组成的数组。 some() 对数组中的每一项运行给定的函数， 如果该函数对任一项返回true， 则返回true。 以上方法都不会修改数组中的包含的值， 传入这些方法会接受三个参数（数组项的值， 该项在数组中的位置， 数组对象本身） every() some() 例子以上代码调用的every() 和 some() ， 传入的函数只要给定项大于 2 就会返回true， 对于every()，它返回的是false， 因为只有部分数组项符合条件，对于some() 就返回true， 因为至少有一项是大于 2 的。 12345678910111213var numbers = [1,2,3,4,5,4,3,2,1]; var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(everyResult); //false var someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(someResult); //true filter() 例子通过filter（）方法创建并返回一个所有数值都大于 2 的数组 1234567var numbers = [1,2,3,4,5,4,3,2,1]; var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(filterResult); //[3,4,5,4,3] map() 例子给数组中每一项都乘以 2 1234567var numbers = [1,2,3,4,5,4,3,2,1]; var mapResult = numbers.map(function(item, index, array)&#123; return item * 2; &#125;); alert(mapResult); //[2,4,6,8,10,8,6,4,2] forEach() 例子1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;) 归并方法reduce() 从数组第一项开始逐个遍历到最后 reduceRight() 从数组最后一项开始，向前遍历到第一项 四个参数（前一个值， 当前值， 项的索引， 数组对象） reduce() 例子求数组所有值之和 12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); reduceRight() 例子求数组所有值之和 12345var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum);"},{"title":"pc端移动端跳转js","date":"2017-12-17T17:43:33.000Z","updated":"2021-02-26T16:49:29.522Z","comments":true,"path":"md/2017-12-18 pc端移动端跳转js.html","permalink":"https://akitsukiwong.github.io/md/2017-12-18 pc端移动端跳转js.html","excerpt":"经常用到的跳转代码","text":"经常用到的跳转代码 if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href=”你的手机版地址”;}else{ window.location.href=”你的电脑版地址”;}"},{"title":"随便做的一个个人简历","date":"2018-05-10T07:44:58.000Z","updated":"2021-02-26T16:49:29.523Z","comments":true,"path":"md/2018-05-10 随便做的一个个人简历.html","permalink":"https://akitsukiwong.github.io/md/2018-05-10 随便做的一个个人简历.html","excerpt":"","text":"码云page地址: http://dflxm.oschina.io"},{"title":"rem.js","date":"2017-12-18T07:25:44.000Z","updated":"2021-02-26T16:49:29.523Z","comments":true,"path":"md/2017-12-18 rem-js.html","permalink":"https://akitsukiwong.github.io/md/2017-12-18 rem-js.html","excerpt":"","text":"12345678910111213window.onload = function()&#123; /*720代表设计师给的设计稿的宽度，你的设计稿是多少，就写多少;100代表换算比例，这里写100是 为了以后好算,比如，你测量的一个宽度是100px,就可以写为1rem,以及1px=0.01rem等等*/ getRem(750,100)&#125;;window.onresize = function()&#123; getRem(750,100)&#125;;function getRem(pwidth,prem)&#123; var html = document.getElementsByTagName(&quot;html&quot;)[0]; var oWidth = document.body.clientWidth || document.documentElement.clientWidth; html.style.fontSize = oWidth/pwidth*prem + &quot;px&quot;;&#125;"},{"title":"常见前端面试题","date":"2018-05-10T14:20:58.000Z","updated":"2021-02-26T16:49:29.523Z","comments":true,"path":"md/2018-05-10 常见前端面试题.html","permalink":"https://akitsukiwong.github.io/md/2018-05-10 常见前端面试题.html","excerpt":"","text":"HTML什么是盒子模型？在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素：a、b、span、img、input、strong、select、label、em、button、textarea块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img 块元素与内联元素的区别？1.块元素，总是在新行上开始；内联元素，和其他元素都在一行上。 2.块元素，能容纳其他块元素或内联元素；内联元素，只能容纳文本或者其他内联元素。 3.块元素中高度，行高以及顶和底边距都可控制；内联元素中高，行高及顶和底边距不可改变。 常见的块级元素 address – 地址 blockquote – 块引用 center – 举中对齐块 dir – 目录列表 div – 常用块级容易，也是CSS layout的主要标签 dl – 定义列表 fieldset – form控制组 form – 交互表单 h1 – 大标题 h2 – 副标题 h3 – 3级标题 h4 – 4级标题 h5 – 5级标题 h6 – 6级标题 hr – 水平分隔线 isindex – input prompt menu – 菜单列表 noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript – 可选脚本内容（对于不支持script的浏览器显示此内容） ol – 有序表单 p – 段落 pre – 格式化文本 table – 表格 ul – 无序列表 常见的内联元素 a – 锚点 abbr – 缩写 acronym – 首字 b – 粗体(不推荐) bdo – bidi override big – 大字体 br – 换行 cite – 引用 code – 计算机代码(在引用源码的时候需要) dfn – 定义字段 em – 强调 font – 字体设定(不推荐) i – 斜体 img – 图片 input – 输入框 kbd – 定义键盘文本 label – 表格标签 q – 短引用 s – 中划线(不推荐) samp – 定义范例计算机代码 select – 项目选择 small – 小字体文本 span – 常用内联容器，定义文本内区块 strike – 中划线 strong – 粗体强调 sub – 下标 sup – 上标 textarea – 多行文本输入框 tt – 电传文本 u – 下划线 CSSCSS实现垂直水平居中js如何理解闭包？定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。 表现形式：使函数外部能够调用函数内部定义的变量。 jQuery相关jQuery库中的$()是什么？$()函数是jQuery()函数的别称。$()函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $()函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。 其它"},{"title":"hexo的常用命令","date":"2018-05-09T17:43:33.000Z","updated":"2021-02-26T16:49:29.523Z","comments":true,"path":"md/2018-05-10 hexo的常用命令.html","permalink":"https://akitsukiwong.github.io/md/2018-05-10 hexo的常用命令.html","excerpt":"","text":"指令新建一篇文章1$ hexo new 新的文章名称 简写 1$ hexo n 新的文章名称 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: Hexokeywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 清除缓存文件 db.json 和已生成的静态文件 public1$ hexo clean 生成静态文件1$ hexo generate 简写 1$ hexo g 自动生成网站静态文件，并部署到设定的仓库1$ hexo deploy 简写 1$ hexo d 启动本地服务器，用于预览主题。默认地址： http://localhost:4000/ 1$ hexo s"},{"title":"CSS初始化","date":"2018-05-11T09:24:49.000Z","updated":"2021-02-26T16:49:29.523Z","comments":true,"path":"md/2018-05-11 CSS初始化.html","permalink":"https://akitsukiwong.github.io/md/2018-05-11 CSS初始化.html","excerpt":"","text":"为什么初始化css?考虑到浏览器兼容性问题，不同浏览器对标签的默认值是不同的 通用初始化样式1234567891011121314151617181920212223242526272829303132333435body&#123; margin: 0;padding: 0;font-family: &quot;微软雅黑&quot;;overflow: hidden;&#125;body,html&#123;-webkit-text-size-adjust: none;width: 100%;height: 100%;&#125;*&#123;text-decoration: none;list-style: none;&#125;img&#123;border: 0px;&#125;ul,li,dl,dd,dt,p,ol,h1,h2,h3,h4,h5&#123;font-size: 12px;font-weight: 100;padding: 0;margin: 0;&#125;.wrap&#123;margin: 0 auto;&#125;.fl&#123;float: left;&#125;.fr&#123;float: right;&#125;.index&#123;overflow: hidden;&#125;.clr&#123;clear:both; height:0px; width:100%; font-size:1px; line-height:0px; visibility:hidden; overflow:hidden;&#125;.pointer&#123;cursor:pointer;&#125;a,input,button&#123; outline:none; &#125;::-moz-focus-inner&#123;border:0px;&#125;/*a:link &#123;color:#0f0;text-decoration:none;&#125; a:visited &#123;color: #FFFF00; text-decoration:none;&#125; a:hover &#123;color: #00FF00; text-decoration:underline;&#125; a:active &#123;color: #0000FF; text-decoration:underline;&#125;*/a&#123;color: #000;&#125;.wrapper&#123;clear: both;width: 100%;&#125;table &#123; border-collapse:collapse; &#125;word-break:break-all /*文字换行*//*white-space:nowrap 文字不换行*//*默认滚动条样式修改ie9 google Firefox 等高版本浏览器有效*//*::selection &#123;background: #D03333;color: white;text-shadow: none;&#125;::-webkit-scrollbar-track-piece&#123;width:10px;background-color:#f2f2f2&#125;::-webkit-scrollbar&#123;width:10px;height:6px&#125;::-webkit-scrollbar-thumb&#123;height:50px;background-color:rgba(0,0,0,.3);&#125;::-webkit-scrollbar-thumb:hover&#123;background:#cc0000&#125;*//*渐变*//*background-image: -moz-linear-gradient(top, #8fa1ff, #3757fa);background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #ff4f02), color-stop(1, #8f2c00)); Saf4+, Chrome filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=&apos;#c6ff00&apos;, endColorstr=&apos;#538300&apos;, GradientType=&apos;0&apos;); IE*/ 另一种通用化样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* CSS Document */html, body, div, span, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,abbr, address, cite, code,del, dfn, em, img, ins,kbd, q, samp,small, strong, sub, sup, var,b, i,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot,thead,tr, th, td,article, aside, canvas, details, figcaption, figure, footer, header, hgroup, menu, nav, section, summary,time, mark, audio, video &#123; margin:0; padding:0; border:0; outline:0; font-size:100%; vertical-align:baseline; background:transparent; outline-style:none;/*FF*/ &#125;body &#123; line-height:1;&#125;a&#123; margin:0; padding:0; border:0; font-size:100%; vertical-align:baseline; background:transparent;&#125;a:hover,a:focus&#123; text-decoration:none; bblr:expression(this.onFocus=this.blur());/*IE*/ outline-style:none;/*FF*/ &#125;table &#123; border-collapse:collapse; border-spacing:0;&#125;input, select &#123; vertical-align:middle;&#125;/*css为clearfix，清除浮动*/.clearfix::before,.clearfix::after&#123; content: &quot;&quot;; height: 0; line-height: 0; display: block; visibility: hidden; clear: both;&#125;.clearfix:after&#123;clear:both;&#125; .clearfix&#123; *zoom:1;/*IE/7/6*/&#125; 雅虎工程师提供的CSS初始化示例代码12345678910111213141516body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px; &#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption, cite, code, dfn, em, strong, th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none; &#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123;overflow-y: scroll;&#125; .clearfix:after &#123;content: &quot;.&quot;; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; 腾讯官网 样式初始化123456789body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select&#123;margin:0;padding:0&#125; body&#123;font:12px&quot;宋体&quot;,&quot;Arial Narrow&quot;,HELVETICA;background:#fff;-webkit-text-size-adjust:100%;&#125; a&#123;color:#2d374b;text-decoration:none&#125; a:hover&#123;color:#cd0200;text-decoration:underline&#125; em&#123;font-style:normal&#125; li&#123;list-style:none&#125; img&#123;border:0;vertical-align:middle&#125; table&#123;border-collapse:collapse;border-spacing:0&#125; p&#123;word-wrap:break-word&#125; 新浪官网 样式初始化12345678910body,ul,ol,li,p,h1,h2,h3,h4,h5,h6,form,fieldset,table,td,img,div&#123;margin:0;padding:0;border:0;&#125; body&#123;background:#fff;color:#333;font-size:12px; margin-top:5px;font-family:&quot;SimSun&quot;,&quot;宋体&quot;,&quot;Arial Narrow&quot;;&#125; ul,ol&#123;list-style-type:none;&#125; select,input,img,select&#123;vertical-align:middle;&#125; a&#123;text-decoration:none;&#125; a:link&#123;color:#009;&#125; a:visited&#123;color:#800080;&#125; a:hover,a:active,a:focus&#123;color:#c00;text-decoration:underline;&#125; 淘宝官网 样式初始化12345678910111213141516171819202122232425body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125; body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \\5b8b\\4f53; &#125; h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125; address, cite, dfn, em, var &#123; font-style:normal; &#125; code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125; small&#123; font-size:12px; &#125; ul, ol &#123; list-style:none; &#125; a &#123; text-decoration:none; &#125; a:hover &#123; text-decoration:underline; &#125; sup &#123; vertical-align:text-top; &#125; sub&#123; vertical-align:text-bottom; &#125; legend &#123; color:#000; &#125; fieldset, img &#123; border:0; &#125; button, input, select, textarea &#123; font-size:100%; &#125; table &#123; border-collapse:collapse; border-spacing:0; &#125; 网易官网 样式初始化html &#123;overflow-y:scroll;&#125; body &#123;margin:0; padding:29px00; font:12px&quot;\\5B8B\\4F53&quot;,sans-serif;background:#ffffff;&#125; div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p&#123;padding:0; margin:0;&#125; table,td,tr,th&#123;font-size:12px;&#125; li&#123;list-style-type:none;&#125; img&#123;vertical-align:top;border:0;&#125; ol,ul &#123;list-style:none;&#125; h1,h2,h3,h4,h5,h6&#123;font-size:12px; font-weight:normal;&#125; address,cite,code,em,th &#123;font-weight:normal; font-style:normal;&#125; 下面顺便给出admin10000.com 的html模板，用于每次新开发页面使用。123456789101112131415161718&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;zh-cn&quot;&gt; &lt;head&gt; &lt;title&gt;网站标题 - Admin10000.com &lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot; /&gt; &lt;meta name=&quot;Author&quot; content=&quot;网页作者&quot; /&gt; &lt;meta name=&quot;Copyright&quot; content=&quot;网站版权&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;网站关键字&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;网站描述&quot; /&gt; &lt;link rel=&quot;Shortcut Icon&quot; href=&quot;网站.ico图标路径&quot; /&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;CSS文件路径&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;JS文件路径&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;"},{"title":"ES6学习笔记","date":"2018-09-07T01:26:41.000Z","updated":"2021-02-26T16:49:29.524Z","comments":true,"path":"md/ES6学习笔记.html","permalink":"https://akitsukiwong.github.io/md/ES6学习笔记.html","excerpt":"","text":"ES6学习笔记ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准 let 和 const 命令1. let命令用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 2. 块级作用域为什么要使用块级作用域 ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域 let实际上为 JavaScript 新增了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 1&#123;&#123;&#123;&#123;&#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。 1234&#123;&#123;&#123;&#123; &#123;let insane = &apos;Hello World&apos;&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。 1234&#123;&#123;&#123;&#123; let insane = &apos;Hello World&apos;; &#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125;"},{"title":"ECharts学习","date":"2018-05-12T06:10:04.000Z","updated":"2021-02-26T16:49:29.523Z","comments":true,"path":"md/2018-05-12 ECharts学习.html","permalink":"https://akitsukiwong.github.io/md/2018-05-12 ECharts学习.html","excerpt":"","text":"面试了很多家单位，都问到了ECharts，所以准备一下还是很有必要的 2018-5-27 更新： 新单位也用到了ECharts，画了几个，也不难，官方文档也很全 主要就这几个步骤 引用js 准备放图表的容器 初始化图表，设置参数 有其它个性化要求，根据官方的文档，改一改配置项都可以快速解决"},{"title":"SPA （单页应用程序）","date":"2018-09-29T00:42:59.000Z","updated":"2021-02-26T16:49:29.525Z","comments":true,"path":"md/SPA-（单页应用程序）.html","permalink":"https://akitsukiwong.github.io/md/SPA-（单页应用程序）.html","excerpt":"","text":"#SPA （单页应用程序） 先简单复制粘贴一下什么是SPA 百度百科单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 应用介绍单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。 特点速度：更好的用户体验，让用户在web app感受native app的速度和流畅， MVVM：经典MVVM开发模式，前后端各负其责。 ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交。 路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载。 笔记初次学习vue-cli做的SPA代码在这 记个笔记 一. 流程1. 全局安装 vue-cli1npm install -g vue-cli 2. 初始化1vue init webpack 项目名称 3. 安装模块1npm install 4. 启动服务器1npm run dev 5. 打包1npm run build"},{"title":"css3优惠券/邮票","date":"2018-05-18T12:17:50.000Z","updated":"2021-02-26T16:49:29.526Z","comments":true,"path":"md/css3优惠券-邮票.html","permalink":"https://akitsukiwong.github.io/md/css3优惠券-邮票.html","excerpt":"","text":"css3写的优惠券/邮票 码云地址：http://dflxm.gitee.io/code/%E9%82%AE%E7%A5%A8.html"},{"title":"JS语法专题","date":"2018-09-29T00:40:19.000Z","updated":"2021-02-26T16:49:29.525Z","comments":true,"path":"md/JS语法专题.html","permalink":"https://akitsukiwong.github.io/md/JS语法专题.html","excerpt":"","text":"https://wangdoc.com/javascript/features/index.html 语法专题 数据类型的转换 错误处理机制 编程风格 console 对象与控制台 数据类型的转换1. 概述JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。 1var x = y ? 1 : &apos;a&apos;; 上面代码中，变量x到底是数值还是字符串，取决于另一个变量y的值。y为true时，x是一个数值；y为false时，x是一个字符串。这意味着，x的类型没法在编译阶段就知道，必须等到运行时才能知道。 虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。 1&apos;4&apos; - &apos;3&apos; // 1 上面代码中，虽然是两个字符串相减，但是依然会得到结果数值1，原因就在于 JavaScript 将运算子自动转为了数值。 本章讲解数据类型自动转换的规则。在此之前，先讲解如何手动强制转换数据类型。 2. 强制转换强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。 2.1 Number()使用Number函数，可以将任意类型的值转化成数值。 下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。 （1）原始类型值 原始类型值的转换规则如下。 123456789101112131415161718192021// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&apos;324&apos;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&apos;324abc&apos;) // NaN// 空字符串转为0Number(&apos;&apos;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0 Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。 12parseInt(&apos;42 cats&apos;) // 42Number(&apos;42 cats&apos;) // NaN 上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。 另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 12parseInt(&apos;\\t\\v\\r12.34\\n&apos;) // 12Number(&apos;\\t\\v\\r12.34\\n&apos;) // 12.34 （2）对象 简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 123Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5 之所以会这样，是因为Number背后的转换规则比较复杂。 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 请看下面的例子。 123456789var obj = &#123;x: 1&#125;;Number(obj) // NaN// 等同于if (typeof obj.valueOf() === &apos;object&apos;) &#123; Number(obj.toString());&#125; else &#123; Number(obj.valueOf());&#125;"},{"title":"css3做banner","date":"2018-05-12T07:02:56.000Z","updated":"2021-02-26T16:49:29.526Z","comments":true,"path":"md/css3做banner.html","permalink":"https://akitsukiwong.github.io/md/css3做banner.html","excerpt":"","text":"也是面试时候遇到的问题,回来随便弄了一个 在线地址：http://dflxm.oschina.io/code/ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;css3写一个banner&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; ul li &#123; list-style: none; &#125; .banner-box &#123; position: relative; width: 400px; height: 200px; overflow: hidden; &#125; .banner &#123; width: 1600px; position: absolute; left: 0; animation-name: bannerMove; animation-duration: 8s; animation-iteration-count: infinite; &#125; @keyframes bannerMove &#123; 0%, 30% &#123; left: 0; &#125; 35%, 65% &#123; left: -400px; &#125; 70%, 99% &#123; left: -800px; &#125; 100% &#123; left: -1200px; &#125; &#125; .banner li &#123; float: left; width: 400px; height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;banner-box&quot;&gt; &lt;ul class=&quot;banner&quot;&gt; &lt;li style=&quot;background-color:#f90;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#f00;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#9f0;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#333;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;"},{"title":"mac 下svn的使用","date":"2018-07-13T01:48:15.000Z","updated":"2021-02-26T16:49:29.527Z","comments":true,"path":"md/mac-下svn的使用.html","permalink":"https://akitsukiwong.github.io/md/mac-下svn的使用.html","excerpt":"","text":"原来mac自带了svn，还挺好用的 以下是一些常用命令： 1、将文件checkout到本地目录 1 svn checkout path（path是服务器上的目录）2 例如：svn checkout svn://192.168.1.1/pro/domain3 简写：svn co 2、往版本库中添加新的文件 1 svn add file2 例如：svn add test.php(添加test.php)3 svn add *.php(添加当前目录下所有的php文件) 3、将改动的文件提交到版本库 1 svn commit -m “LogMessage“ [-N] [–no-unlock] PATH (如果选择了保持锁，就使用–no-unlock开关)2 例如： svn commit -m “add test file for my test“ test.php3 简写： svn ci 4、加锁/解锁 1 svn lock -m “LockMessage“ [–force] PATH2 例如：svn lock -m “lock test file“ test.php3 svn unlock PATH 5、更新到某个版本 1 svn update -r m path2 例如：3 svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。4 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200)5 svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)6 简写：svn up 6、查看文件或者目录状态 1 1）svn status path（目录下的文件和子目录的状态，正常状态不显示）2 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】3 2）svn status -v path(显示文件和子目录状态)4 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。5 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。6 简写：svn st 7、删除文件 1 svn delete path -m “delete test fle“2 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file”3 或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，推荐使用这种4 简写：svn (del, remove, rm) 8、查看日志 1 svn log path2 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化 9、查看文件详细信息 1 svn info path2 例如：svn info test.php 10、比较差异 1 svn diff path(将修改的文件与基础版本比较)2 例如：svn diff test.php3 svn diff -r m:n path(对版本m和版本n比较差异)4 例如：svn diff -r 200:201 test.php5 简写：svn di 11、将两个版本之间的差异合并到当前文件 1 svn merge -r m:n path2 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） 12、SVN 帮助 1 svn help2 svn help ci 13、版本库下的文件和目录列表 1 svn list path2 显示path目录下的所有属于版本库的文件和目录3 简写：svn ls 14、创建纳入版本控制下的新目录 复制代码 1 svn mkdir: 创建纳入版本控制下的新目录。2 用法: 1、mkdir PATH…3 2、mkdir URL…4 创建版本控制的目录。5 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增6 调度，以待下一次的提交。7 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。8 在这两个情况下，所有的中间目录都必须事先存在 复制代码 15、恢复本地修改 1 svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:2 用法: revert PATH…3 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复4 被删除的目录 16、代码库URL变更 复制代码 1 svn switch (sw): 更新工作副本至不同的URL。 2 用法: 1、switch URL [PATH] 3 2、switch –relocate FROM TO [PATH…] 4 5 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将 6 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的 7 方法。 8 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动 9 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用10 这个命令更新工作副本与仓库的对应关系。 复制代码 17、解决冲突 1 svn resolved: 移除工作副本的目录或文件的“冲突”状态。2 用法: resolved PATH…3 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的4 相关文件，然后让 PATH 可以再次提交。"},{"title":"css画三角形","date":"2018-05-12T06:13:43.000Z","updated":"2021-02-26T16:49:29.526Z","comments":true,"path":"md/css画三角形.html","permalink":"https://akitsukiwong.github.io/md/css画三角形.html","excerpt":"","text":"面试时候遇到的问题，只要设置两个边框透明就行了,学会了这个，妈妈再也不怕我面试的时候被要求画三角形了 上三角 1234567#triangle-up &#123;width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-bottom: 100px solid red;&#125; 下三角 1234567#triangle-down &#123;width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-top: 100px solid red;&#125; 左三角 1234567#triangle-left &#123;width: 0;height: 0;border-top: 50px solid transparent;border-right: 100px solid red;border-bottom: 50px solid transparent;&#125; 右三角 1234567#triangle-right &#123;width: 0;height: 0;border-top: 50px solid transparent;border-left: 100px solid red;border-bottom: 50px solid transparent;&#125;"},{"title":"nginx反向代理","date":"2018-09-29T00:45:22.000Z","updated":"2021-02-26T16:49:29.527Z","comments":true,"path":"md/nginx反向代理.html","permalink":"https://akitsukiwong.github.io/md/nginx反向代理.html","excerpt":"","text":"###nginx反向代理 1.下载nginx http://nginx.org/en/download.html 下载稳定版本，以nginx/Windows-1.12.2为例，直接下载 nginx-1.12.2.zip 2.启动nginx 有很多种方法启动nginx (1)直接双击nginx.exe，双击后一个黑色的弹窗一闪而过 (2)打开cmd命令窗口，切换到nginx解压目录下，输入命令 nginx.exe 或者 start nginx ，回车即可 3.检查nginx是否启动成功 直接在浏览器地址栏输入网址 http://localhost:80，回车，出现以下页面说明启动成功 反向代理1.定义 跨域是指a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是浏览器的限制。理解这一点很重要！！！ 2.跨域访问示例 假设有两个网站，A网站部署在：http://localhost:81 即本地ip端口81上；B网站部署在：http://localhost:82 即本地ip端口82上。 关于nginx的配置可以查看另一篇博文：http://www.cnblogs.com/renjing/p/6126284.html。找到nginx的配置文件“nginx.conf”，修改一下信息 123456789101112131415161718server &#123; listen 80; #监听80端口，可以改成其他端口 server_name localhost; # 当前服务的域名 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://localhost:81; proxy_redirect default; &#125; location /apis &#123; #添加访问目录为/apis的代理配置 rewrite ^/apis/(.*)$ /$1 break; proxy_pass http://localhost:82; &#125;#以下配置省略 配置解释： 1.由配置信息可知，我们让nginx监听localhost的80端口，网站A与网站B的访问都是经过localhost的80端口进行访问。 2.我们特殊配置了一个“/apis”目录的访问，并且对url执行了重写，最后使以“/apis”开头的地址都转到“http://localhost:82”进行处理。 3.rewrite ^/apis/(.*)$ /$1 break; 代表重写拦截进来的请求，并且只能对域名后边以“/apis”开头的起作用，例如www.a.com/apis/msg?x=1重写。只对/apis重写。 rewrite后面的参数是一个简单的正则 ^/apis/(.*)$ ,$1代表正则中的第一个(),$2代表第二个()的值,以此类推。 break代表匹配一个之后停止匹配。 访问地址修改 既然配置了nginx，那么所有的访问都要走nginx，而不是走网站原本的地址（A网站localhost:81,B网站localhost:82）。所以要修改A网站中的ajax访问地址，把访问地址由 “http://localhost:82/api/values”改成》》》“/apis/api/values”。"},{"title":"vue生命周期钩子","date":"2018-10-25T06:55:17.000Z","updated":"2021-02-26T16:49:29.527Z","comments":true,"path":"md/vue生命周期钩子.html","permalink":"https://akitsukiwong.github.io/md/vue生命周期钩子.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message : &quot;xuxiao is boy&quot; &#125;, beforeCreate: function () &#123; console.group(&apos;beforeCreate 创建前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, created: function () &#123; console.group(&apos;created 创建完毕状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group(&apos;beforeMount 挂载前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + (this.$el)); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group(&apos;mounted 挂载结束状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group(&apos;beforeUpdate 更新前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, updated: function () &#123; console.group(&apos;updated 更新完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeDestroy: function () &#123; console.group(&apos;beforeDestroy 销毁前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, destroyed: function () &#123; console.group(&apos;destroyed 销毁完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"wepy学习","date":"2018-12-07T06:51:00.000Z","updated":"2021-02-26T16:49:29.527Z","comments":true,"path":"md/wepy学习.html","permalink":"https://akitsukiwong.github.io/md/wepy学习.html","excerpt":"","text":"快速入门全局安装1npm install wepy-cli -g 生成Demo开发项目1wepy init standard myproject 安装依赖1npm install 实时编译1wepy build --watch 设置微信开发者工具 选项中关闭ES6转ES5 选项中关闭上传代码时样式自动补全 选项中关闭代码压缩上传 选项中打开不检查安全域名（如果已配置好安全域名则建议关闭） @符号 原 bindtap=&quot;click&quot; 替换为 @tap=&quot;click&quot; 原 catchtap=&quot;click&quot; 替换为 @tap.stop=&quot;click&quot; 原 capture-bind:tap=&quot;click&quot; 替换为@tap.capture=&quot;click&quot; 原 capture-catch:tap=&quot;click&quot; 替换为@tap.capture.stop=&quot;click&quot; 1bindtap=&quot;click&quot; data-index= &#123;&#123;index&#125;&#125; 替换为1@tap=&quot;click(&#123;&#123;index&#125;&#125;)&quot;"},{"title":"基于 vue2 + vuex 构建一个具有 45 个页面的大型单页面应用","date":"2018-05-18T16:28:13.000Z","updated":"2021-02-26T16:49:29.528Z","comments":true,"path":"md/个页面的大型单页面应用.html","permalink":"https://akitsukiwong.github.io/md/个页面的大型单页面应用.html","excerpt":"","text":"https://www.vue-js.com/topic/58abbd21a9c1282817afc28d github:https://github.com/bailicangdu/vue2-elm"},{"title":"写插件教程","date":"2018-09-07T06:45:37.000Z","updated":"2021-02-26T16:49:29.528Z","comments":true,"path":"md/写插件教程.html","permalink":"https://akitsukiwong.github.io/md/写插件教程.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #demo-1, #demo-2 &#123; width: 200px; height: 200px; border: 1px solid #ddd; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;点击add可以添加个自input的内容到div里并实现变颜色&lt;/h3&gt; &lt;!--组件实例1--&gt; &lt;div id=&quot;demo-1&quot;&gt; &lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;好的&quot; /&gt; &lt;button id=&quot;add-1&quot;&gt;add&lt;/button&gt; &lt;/div&gt; &lt;br /&gt; &lt;br /&gt; &lt;!--组件实例2--&gt; &lt;div id=&quot;demo-2&quot;&gt; &lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;11&quot; /&gt; &lt;button id=&quot;add-2&quot;&gt;add&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //这里是插件的代码；我为了方便都写到一个html中了；请把这个script标签中的内容单独写在一个js文件里 //整个插件写在一个立即执行函数里；就是function()&#123;&#125;();函数自执行；保证里面的变量不会与外界互相影响 //头部的win啊,doc啊 $ 啊都是底部的window,document,jQuery的映射；方便内部直接调用； //当然你不引用jq的话头部的$和底部的jQuery干掉；你若引用了更过的依赖可以依次添加； //最后面的undefined可不写；最好写了；保证里面再出现的undefined是未定义的意思；不被其他东西赋值； //好了下面是时候展现真正的技术了 //function前的!号(叹号)或者;(分号)这不是写错了,为了防止那个二货写的js结束没有分号；而可能发生报错 /* ;function(win,doc,$,undefined)&#123; &#125;(window,document,jQuery) 或者写在一个闭包里(function()&#123; &#125;()) */ (function(win, doc, undefined) &#123; //我们随便写一个插件吧 比如你要点击按钮 添加input的值到 div里 var addHtml = function(demo, btn) &#123; //插件名，调用的时候直接new一下插件名就行了并传参数或者传对象(一般这个函数名手写字母大写比较好，构造函数嘛，其实也是函数) //很明显我要传id名；这里传什么都可以的其实； this.div = doc.getElementById(demo); //为什么把获取的id传给this.div呢？this的指向为调用的实例；我们此时姑且认为this就指向这个函数；因为这样我们之后再想获取这个div就可以直接用this.div了好吗；而不是在document.getElementById（。。。。） this.btn = doc.getElementById(btn); this.Input = this.div.getElementsByTagName(&quot;input&quot;)[0]; //既然找到了div我们在找下div下面的input；当然你要不input用获取id的形式传参数我没有意见 this.num = 0; //你也可以写一些其他的默认的东西；比如默认的变量啦；方便下面调用；这里写了什么都不会报错；只是有用没用的问题这行可以忽略 this.author = &quot;lianxiaozhuang&quot;; this.init(); //执行下你下面写的函数吧；你想想；如果整个插件没有执行函数；多不好；一堆方法function就不调用；对；这里是调用的时候最开始执行的函数 &#125; //；给构造函数addHtml对象原型里添加属性（方法） addHtml.prototype = &#123; //给函数写方法；这里可能不止一个函数；你还记得你在全局里写一个个的function吗；贼乱； //找也不好找；把一个个函数都写到对象的属性里；调用函数就直接调用对象的属性； constructor: addHtml, //构造器指向构造函数；这行其实不写没啥毛病；不过有时候防止构造器指向Object的情况；你还是装逼写上吧； init: function() &#123; //这里的init；你也可以写成 nimade:function()&#123; &#125;都没有问题；就是在addHtml函数里this.init();执行下；你明白了这里的this了吧；整个插件里this都是只得这个函数（实例）；除非你又引入了其他的函数里的（其他函数里的可能指向就是window了） var _self = this; ////把this保存下来防止在局部函数内部取不到（局部函数内部取得this可能是别的） this.btn.onclick = function() &#123; var _val = _self.Input.value; var tempdiv = doc.createElement(&quot;div&quot;); //创建临时div存放获取input的值 tempdiv.innerHTML = _val; //console.log(tempdiv); _self.div.appendChild(tempdiv); _self.setColor(); //你把所有方法都写在init里绝对没问题；还是那句话；说好的松耦合呢；说好的不写一堆堆的function一层层乱套呢 &#125;; &#125;, setColor: function() &#123; //console.log(this.div) this.div.style.color = &quot;red&quot; &#125; /*, otherFun()&#123; //当然你还可以扩展其他方法；这些方法之间都可以互相调用； 只要用this.方法名 就行了；如果在取不到this比如上面的click函数中的this指向点击的button；只要在写var _self = this;就可以用_self 代替this（函数实例）了；当然_self 也可以写成别的 比如$this等自定义的 &#125;*/ &#125; win.addHtml = addHtml; //把这个对象附给window底下的 名字叫addHtml的对象；要不你调用的时候 new addHtml() 怕在window的环境下找不到； &#125;(window, document)) &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; new addHtml(&quot;demo-1&quot;, &quot;add-1&quot;); //这里是实例1调用插件的代码 new addHtml(&quot;demo-2&quot;, &quot;add-2&quot;); //这里是实例2调用插件的代码 //是不是明白为什么要写插件了；要封装；两个相同组件即使有相同的class名在dom操作的时候也不会相互冲突；因为他们都new出来了个自的实例；有自己的this；有自己的一套方法了（其实方法都在原型里是公用的；操作各自的dom） &lt;/script&gt; &lt;!--这里是最简单的插件写法；当然还有传对象参数的插件等等。。。。--&gt; &lt;/body&gt;&lt;/html&gt;"},{"title":"学习jquery源码","date":"2018-09-07T01:21:00.000Z","updated":"2021-02-26T16:49:29.528Z","comments":true,"path":"md/学习jquery源码.html","permalink":"https://akitsukiwong.github.io/md/学习jquery源码.html","excerpt":"","text":"学习jQuery源码笔记1. 立即执行函数IIFE (立即调用的函数表达,Immediately-Invoked Function Expression，简称IIFE) 123(function() &#123; /*code*/&#125;)() 或者123(function() &#123; /*code*/&#125;()) IIFE的作用 不必为函数命名，避免了污染全局变量我们这里直接对匿名函数使用这种“立即执行的函数表达式”，并且在函数的在括号内定义之后立刻调用执行，这样避免为函数命名，减少命名的冲突 IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。在的JavaScript语法中我们知道作用域分为全局作用域和函数作用域(当然在后面的ES6中引入了块级作用域)，依据函数作用域这一特点，在匿名函数中我们可以封装一些自己内部模块使用的私有变量。 例子1234(function () &#123; var a=10;&#125;)();alert(a); 会报错 a is not defined"},{"title":"webpack之proxyTable设置跨域","date":"2018-09-29T00:44:03.000Z","updated":"2021-02-26T16:49:29.527Z","comments":true,"path":"md/webpack之proxyTable设置跨域.html","permalink":"https://akitsukiwong.github.io/md/webpack之proxyTable设置跨域.html","excerpt":"","text":"###webpack之proxyTable设置跨域 使用vue-cli搭建的vue项目可以使用在项目内设置代理（proxyTable）的方式来解决跨域问题。 123456789proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://www.ykt.com/&apos;,//接口域名 changeOrigin: true,//是否跨域 pathRewrite: &#123; &apos;^/api&apos;: &apos;/index/index&apos;//需要rewrite重写 &#125; &#125; &#125; 实现效果： 1localhost:8080/api/getbuildcate ===&gt; www.ykt.com/index/index/getbuildcate"},{"title":"试一下Hexo Admin好不好用～","date":"2018-07-12T04:23:00.000Z","updated":"2021-02-26T16:49:29.528Z","comments":true,"path":"md/试一下Hexo-Admin好不好用～.html","permalink":"https://akitsukiwong.github.io/md/试一下Hexo-Admin好不好用～.html","excerpt":"","text":"觉得原始的发blog太麻烦，所以装了个hexo admin 现在来尝试下发下博客 1 2 3 发送！"},{"title":"啥啊","date":"2019-05-16T02:05:44.000Z","updated":"2021-02-26T16:49:29.528Z","comments":true,"path":"啥啊/index.html","permalink":"https://akitsukiwong.github.io/啥啊/index.html","excerpt":"","text":"12121得到"},{"title":"这是啥","date":"2019-05-16T02:05:25.000Z","updated":"2021-02-26T16:49:29.529Z","comments":true,"path":"这是啥/index.html","permalink":"https://akitsukiwong.github.io/这是啥/index.html","excerpt":"","text":"test"},{"title":"SQL语句学习","date":"2018-10-25T06:55:00.000Z","updated":"2021-02-26T16:49:29.525Z","comments":true,"path":"md/SQL语句学习.html","permalink":"https://akitsukiwong.github.io/md/SQL语句学习.html","excerpt":"","text":"SQL语句学习上周试着用Express去搭后台 , 搭好了一个基础的框架 , 后端还是挺有意思的 我如果需要更丰富的功能就需要学习更多的SQL语句 , 所以这周的计划是学习SQL语句 学习的主要途径是看W3C的文档 链接 SQL 简介SQL 是用于访问和处理数据库的标准的计算机语言。 什么是 SQL？ SQL 指结构化查询语言 SQL 使我们有能力访问数据库 SQL 是一种 ANSI (美国国家标准化组织) 的标准计算机语言 SQL 能做什么？ SQL 面向数据库执行查询 SQL 可从数据库取回数据 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 SQL 可创建新数据库 SQL 可在数据库中创建新表 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 SQL 语法数据库表一个数据库通常包含一个或多个表。每个表由一个名字标识（例如“客户”或者“订单”）。表包含带有数据的记录（行）。 下面的例子是一个名为 “Persons” 的表： Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 上面的表包含三条记录（每一条对应一个人）和五个列（Id、姓、名、地址和城市）。 SQL 语句您需要在数据库上执行的大部分工作都由 SQL 语句完成。 下面的语句从表中选取 LastName 列的数据： 1SELECT LastName FROM Persons 结果集类似这样： LastName Adams Bush Carter 在本教程中，我们将为您讲解各种不同的 SQL 语句。 重要事项 : 一定要记住，SQL 对大小写不敏感！ SQL DML 和 DDL可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。 SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。 查询和更新指令构成了 SQL 的 DML 部分： SELECT - 从数据库表中获取数据 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。 SQL 中最重要的 DDL 语句: CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL SELECT 语句SQL SELECT 语句SELECT 语句用于从表中选取数据。 结果被存储在一个结果表中（称为结果集）。 SQL SELECT 语法1SELECT 列名称 FROM 表名称 以及： 1SELECT * FROM 表名称 注释：SQL 语句对大小写不敏感。SELECT 等效于 select。 SQL SELECT 实例如需获取名为 “LastName” 和 “FirstName” 的列的内容（从名为 “Persons” 的数据库表），请使用类似这样的 SELECT 语句： 1SELECT LastName,FirstName FROM Persons “Persons” 表: Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 结果： LastName FirstName Adams John Bush George Carter Thomas SQL SELECT * 实例现在我们希望从 “Persons” 表中选取所有的列。 请使用符号 * 取代列的名称，就像这样： 1SELECT * FROM Persons 提示：星号（*）是选取所有列的快捷方式。 结果： Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing SQL SELECT DISTINCT 语句SQL SELECT DISTINCT 语句在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。 关键词 DISTINCT 用于返回唯一不同的值。 语法： 1SELECT DISTINCT 列名称 FROM 表名称 使用 DISTINCT 关键词如果要从 “Company” 列中选取所有的值，我们需要使用 SELECT 语句： 1SELECT Company FROM Orders “Orders”表： Company OrderNumber IBM 3532 W3School 2356 Apple 4698 W3School 6953 结果： Company IBM W3School Apple W3School 请注意，在结果集中，W3School 被列出了两次。 如需从 Company” 列中仅选取唯一不同的值，我们需要使用 SELECT DISTINCT 语句： 1SELECT DISTINCT Company FROM Orders 现在，在结果集中，”W3School” 仅被列出了一次。 SQL WHERE 子句WHERE 子句用于规定选择的标准。WHERE 子句如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。 语法 1SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 下面的运算符可在 WHERE 子句中使用： 操作符 描述 = 等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 注释：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。 使用 WHERE 子句如果只希望选取居住在城市 “Beijing” 中的人，我们需要向 SELECT 语句添加 WHERE 子句： 1SELECT * FROM Persons WHERE City=&apos;Beijing&apos; “Persons” 表 LastName FirstName Address City Year Adams John Oxford Street London 1970 Bush George Fifth Avenue New York 1975 Carter Thomas Changan Street Beijing 1980 Gates Bill Xuanwumen 10 Beijing 1985 结果： LastName FirstName Address City Year Carter Thomas Changan Street Beijing 1980 Gates Bill Xuanwumen 10 Beijing 1985 引号的使用 请注意，我们在例子中的条件值周围使用的是单引号。 SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。 文本值： 12345这是正确的：SELECT * FROM Persons WHERE FirstName=&apos;Bush&apos;这是错误的：SELECT * FROM Persons WHERE FirstName=Bush 数值： 12345这是正确的：SELECT * FROM Persons WHERE Year&gt;1965这是错误的：SELECT * FROM Persons WHERE Year&gt;&apos;1965&apos; SQL AND &amp; OR 运算符AND 和 OR 运算符用于基于一个以上的条件对记录进行过滤。AND 和 OR 运算符AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。 原始的表 (用在例子中的)： LastName FirstName Address City Adams John Oxford Street London Bush George Fifth Avenue New York Carter Thomas Changan Street Beijing Carter William Xuanwumen 10 Beijing AND 运算符实例使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人： 1SELECT * FROM Persons WHERE FirstName=&apos;Thomas&apos; AND LastName=&apos;Carter&apos; 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing OR 运算符实例使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人： 1SELECT * FROM Persons WHERE firstname=&apos;Thomas&apos; OR lastname=&apos;Carter&apos; 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Carter William Xuanwumen 10 Beijing 结合 AND 和 OR 运算符我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）: 12SELECT * FROM Persons WHERE (FirstName=&apos;Thomas&apos; OR FirstName=&apos;William&apos;)AND LastName=&apos;Carter&apos; 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Carter William Xuanwumen 10 Beijing SQL ORDER BY 子句ORDER BY 语句用于对结果集进行排序。ORDER BY 语句ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 原始的表 (用在例子中的)： Orders 表: Company OrderNumber IBM 3532 W3School 2356 Apple 4698 W3School 6953 实例 1 以字母顺序显示公司名称： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company 结果： Company OrderNumber Apple 4698 IBM 3532 W3School 6953 W3School 2356 实例 2 以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber 结果： Company OrderNumber Apple 4698 IBM 3532 W3School 2356 W3School 6953 实例 3 以逆字母顺序显示公司名称： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC 结果： Company OrderNumber W3School 6953 W3School 2356 IBM 3532 Apple 4698 实例 4 以逆字母顺序显示公司名称，并以数字顺序显示顺序号： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC 结果： Company OrderNumber W3School 2356 W3School 6953 IBM 3532 Apple 4698 注意：在以上的结果中有两个相等的公司名称 (W3School)。只有这一次，在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 nulls 时，情况也是这样的。 SQL INSERT INTO 语句INSERT INTO 语句用于向表格中插入新的行。 1INSERT INTO 表名称 VALUES (值1, 值2,....) 我们也可以指定所要插入数据的列： 1INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)"},{"title":"javascript高级程序设计学习笔记","date":"2017-11-30T17:45:22.000Z","updated":"2021-02-26T16:49:29.522Z","comments":true,"path":"md/2017-12-01 javascript高级程序设计学习笔记.html","permalink":"https://akitsukiwong.github.io/md/2017-12-01 javascript高级程序设计学习笔记.html","excerpt":"","text":"第一章 HTML中使用JavaScriptscript元素script中有六个属性 async charset defer language src type 标签的位置传统做法放在&lt;head&gt;中，js会被先加载页面会有延迟 所以把JavaScript引入放在&lt;body&gt;元素中页面元素的后面 这样先加载页面内容，用户会因为空白页面时间缩短而感到页面打开速度加快 延迟脚本HTML 4.01为&lt;script&gt;标签定义了defer属性。 相当于告诉浏览器立即下载延迟执行。 1&lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt; 异步脚本async 1&lt;script type=&apos;text/javascript&apos; async src=&apos;example.js&apos;&gt;&lt;/script&gt; 在XHTML中的用法XTML（可拓展超文本标记语言），是将HTML作为XML的应用而重新定于的一个标准规则比HTML严格 第二章 基本概念语法ECMAScript大量借鉴C及其他类C语言（Java等） 区分大小写ECMAScript中一切（变量、函数名和操作符）都区分大小写。 标识符标识符，指变量、函数、属性都名字，或者函数的参数。 第一个字符必须是字母、下划线（_）或者一个美元符号（$）； 其他字符可以是字母、下划线、美元符号或数字。 注释C风格注释 123456// 单行注释/** 这是一个多行*（块级）注释*/ 严格模式ECMAScript 5 引入严格模式 启用严格模式可在顶部添加use strict; 1234function()&#123; &quot;use strict&quot;; //函数体&#125; 语句分号结尾；代码块{ } 里面 关键字和保留字变量ECMAScript的变量是松散类型的，可以保存任何类型的数据。 定义变量使用 var 操作符 函数中var的是局部变量，省略var是全局变量 定义多个变量（用逗号隔开） 123var message = &quot;hi&quot; , found = false , age = 29 ; 数据类型ES中有五种简单的数据类型 1- Undefined —– 未定义 2- Null ————- 3- Boolean ——– 布尔值 4- Number ——— 数值 5- String ———— 还有一种复杂数据类型 Object typeof 操作符12var message = &quot;some string&quot; ;alert(typeof message) ; //&quot;string&quot; typeof 返回值 undefined —— 为定义 boolean ——— 布尔值 string ———— 字符串 number ———- 数值 object ———— 对象 或者 null function ———- 函数 undefined 类型var 声明变量但为对其加以初始化的值就是undefined Null类型Boolean 类型true和false Number类型 整数和浮点数（带小数点的数值，小数点后至少有一位数字） 浮点数值极大极小的数字用e表示法（科学计数法） 12var floatNum = 3.125e7 //31250000var floatNum = 3e-17 //0.00000000000000003 浮点数值最高精度为17位小数，其计算精度远远不如整数，例如 0.1 + 0.2 结果不是 0.3 而是 0.300000000000004。 数值范围 Infinity （负无穷） Infinity （正无穷） NaN非数值 （not a number） 任何涉及NaN的操作都会返回NaN NaN和任何值都不相等，包括NaN 1alert（NaN == NaN） //false isNaN（）函数，查询是否为数值 123alert(isNaN(NaN)); //truealert(isNaN(10)); //false(10是一个数值)alert(isNaN(&quot;blue&quot;)) //true 数值转换 number() – 如果是布尔值，返回0和1 – 如果是数字，简单的传入和返回 – 如果是null，返回0 – 如果是undefined，返回NaN – 如果是字符串……… – 如果是对象，调用valueOf( ) 方法，如果转换的对象是NaN，调用toString（）方法 parseInt() parseFloat() string 类型单引号和双引号字符串形式完全相同 字符字面量string数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符 \\n 换行 \\t 制表 \\b 退格 等… 字符串的特点ES中字符串是不可变的，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充改变量。 转换为字符串toString（） Object 类型对象其实就是一组数据和功能的集合。对象可以通过new操作符来创建 1var o = new Object( ) ; （括号可以省略，但不推荐） 操作符一元操作符只能操作一个值但操作符叫做一元操作符。 递增和递减操作符++age；等于age = age +1; –age; 等于age = age - 1； 【前置型】会影响语句的结果，求值之前执行 【后置型】不会影响语句结果，求值之后执行 例子 1234var num1 = 2 ;var num2 = 20 ;var num3 = --num + num2 ; //21var num4 = num1 + num2 ; //21 1234var num1 = 2 ;var num2 = 20 ;var num3 = num-- + num2 ; //22var num4 = num1 + num2 ; //21 一元加和减操作符一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。 12var num = 25 ;num = +num ; //25 一元减操作符主要表示负数。 位操作符转化位二进制 12var num = -18 ;alert(num.toString(2)) ; //&quot;-10010&quot; 按位非（NOT）按位非由一个波浪号【～】表示，执行按位非的结果就是返回数值的反码（二进制逐位取反） 按位与（AND）按位与由一个和字符号【&amp;】表示，都是1返回1，有0就返回0 按位或（OR）按位或由一个竖线符号【|】表示，有1返回1，都是0才返回0 左移【&lt;&lt;】，会将数值的所有位向左移动制定的位数。 12var oldValue = 2 ; //二进制10var newValue = oldValue &lt;&lt; 5; //二进制100000，即64 右移【&gt;&gt;】,会将数值向右移动，但保留符号位 12var oldValue = 64 ; //二进制1000000var newValue = oldValue &gt;&gt; 5; //二进制10，即2 无符号右移【&gt;&gt;&gt;】，会将数值的所有32位都向右移动。 对于正数于【&gt;&gt;】一样，对于负数无符号右移后结果会变得非常大，因为无符号右移会移动所有的二进制码。 12var oldValue = -64 ; //二进制1000000var newValue = oldValue &gt;&gt;&gt; 5; //十进制134217726 3.5.3 布尔操作符布尔操作符一共三个 非（NOT）【 ！】 与（AND） 【 &amp;&amp; 】 或（OR） 【 || 】 乘性操作符 乘法 【 * 】 除法 【 / 】 求模 （余数） 【 % 】 1var result = 26 % 5 ; //等于 1 加性操作符 加法 【 + 】 减法 【 - 】 关系操作符 小于 【 &lt; 】 大于 【 &gt; 】 小于等于 【 &lt;= 】 大于等于 【 &gt;= 】 相等操作符相等和不相等（先转换再比较） 全等和不全等（仅比较不转换） 相等和不相等 相等 【 == 】 不相等 【 != 】 全等和不全等 全等 【 === 】 不全等 【 !== 】 条件操作符1variable = boolean_expression ? true_value : false_value 基于对boolean_expression求值对结果，决定给变量variable赋什么值。如果为true，赋true_value值，如果为false，赋false_value值 1var max = (num1 &gt; num2) ? num1 : num2 ; max将保存最大对值，表达式意思是：如果num1大于num2，给max赋num1值，反之赋值num2 赋值操作符简单赋值操作符由符号【 = 】表示，作用：把右侧对值赋给左侧对变量 逗号操作符可以在一条语句中执行多个操作 1var num1 = 1, num2 = 2, num3 = 3; 逗号操作符还可以用作赋值，会返回表达式对最后一项。 1var num = ( 5, 1, 4, 8, 0); //num的值为0，因为0是表达式的最后一项 语句if语句12345if ( condition【条件】 ) &#123; statement1【语句1】； &#125; else &#123; statement【语句2】； &#125; 1234567if( condition1【条件1】 )&#123; statement1【语句1】；&#125; else if ( condition2【条件2】 )&#123; statemen2【语句2】；&#125; else &#123; statement3【语句3】；&#125; do-while 语句12345do&#123; statement【语句】&#125; while &#123; expression【条件】&#125; while 语句123while( expression【条件】 )&#123; statement【语句】&#125; for语句for语句也是一种前端测试循环语句，它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。 123for(initialization【初始化】; expression【条件】; post-loop-expression【循环表达式】)&#123; statement【语句】;&#125; 当三个表达式全部省略就会创建一个无限循环 123for( ; ; )&#123; //无限循环 doSomething();&#125; 3.6.5 for-in语句for-in语句是一种精准当迭代语句，可以用来枚举对象当属性。 123for( property【属性】 in expression)&#123; statement【语句】&#125; 3.6.6 label语句1label【标签】: statement 123start: for (var i = 0; i &lt; count; i++)&#123; alert(i);&#125; 3.6.7 break和continue语句break和continue用于在循环中精确的控制代码的执行【break】立即退出循环，强制继续执行循环后面的语句【continue】立即退出循环，退出循环后会从循环的顶部继续执行break和continue都可以和label语句联合使用，从而返回代码中特定的位置。 3.6.8 with语句123with(expreession【条件】)&#123; statement【语句】&#125; with语句主要目的是为了简化多次编写同一个对象的工作123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 以上代码都包含了location对象，用with语句12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 不建议使用过with语句 3.6.9 switch 语句1234567891011switch(expression)&#123; case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; 相当于if-else语句简化写法123456789if(i == 25)&#123; alert(&quot;25&quot;);&#125; else if(i == 35)&#123; alert(&quot;35&quot;)&#125; else if(i == 45)&#123; alert(&quot;45&quot;)&#125;else &#123; alert(&quot;other&quot;)&#125; 等价于switch语句12345678910111213switch( i )&#123; case 25: alert(&quot;25&quot;); break; case 35: alert(&quot;35&quot;); break; case 45: alert(&quot;45&quot;); break; default: alert(&quot;other&quot;);&#125; 3.7 函数123function functionName(arg0, arg1, ...,argN)&#123; statements&#125; 位于语句之后都任何代码都永远不会执行 3.7.1 理解参数命名的参数只提供便利，但不是必须的 3.7.2 没有重载第三章 变量、作用域和内存问题4.1 基本类型和引用类型的值【基本类型】简单的数据段【引用类型】可能有多个值构成的对象 4.1.1 动态的属性4.1.2 复制变量值4.1.3 传递参数当在函数内部重写obj时，这个变量引用的就是一个局部对象，这个局部对象会在函数执行完毕后立即销毁。12345678function setName(obj)&#123; obj.name = &quot;Nicholas&quot;; obj = new Object(); obj.name = &quot;Greg&quot;;&#125;var person = new Object();set.Name(person);alert(person.name); //&quot;Nicholas&quot; 4.1.4 检测类型instanceof操作符1result = variable instanceof constructor 例子123alert(person instanceof Object); //变量person是Object吗？alert(colors instanceof Array); //变量colors是Array吗？alert(pattern instanceof RegExp); //变量pattern是RegExp吗？ 4.2 执行环境及作用域延长作用域链4.2.2 没有块级作用域声明变量使用var声明的变量会自动添加到最接近到环境中如果初始化变量没有使用var 声明，该变量会自动被添加到全局环境。 查询标识符4.3 垃圾收集js具有垃圾自动收集功能 4.3.1 标记清除4.3.2 引用计数4.3.3 性能问题4.3.4 管理内存第五章 引用类型5.1 Object类型创建Object实例有两种方式 使用new操作符后跟Object构造函数123var person = new Object();person.name = &quot;Nicholas&quot;;person.age = &quot;29&quot;; Object可以省略，用大括号代替123var person = &#123;&#125;;person.name = &quot;Nicholas&quot;;person.age = &quot;29&quot;; 使用对象字面量表示法，是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。1234var person = &#123; name = &quot;Nicholas&quot; , age = 29&#125;; 访问对象属性可以用点表示法，也可以用方括号12alert(person.name); //Nicholasalert(person[&quot;name&quot;]); //Nicholas 方括号语法的主要优点是可以通过变量来访问属性12var propertyName = &quot;name&quot;;alert(person[propertyName]); //Nicholas 5.2 array类型创建数组有两种方法1var colors = new Array(); 创建length值为20的数组1var colors = new Array( 20 ); 也可以向Array构造函数传递数组中应该包含的项1var colors = new Array( &quot;red&quot;,&quot;blue&quot;,&quot;green&quot; ); 可以省略new操作符1var colors = Array(); 可以使用字面量表示法，数组用方括号表示，逗号隔开12var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; var names = [] //创建一个空数组 利用length属性可以方便的在数组末尾添加新项123var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; colors[colors.length] = &quot;black&quot;; //在位置3添加一种颜色colors[colors.length] = &quot;brown&quot; //在位置4添加一种颜色 5.2.1 检测数组123if(value instanceof Array)&#123; //do something&#125; ES5新增的Array.isArray()方法，用于确定某个值到底是不是数组，而不管它是在哪个全局环境下创建的。123if(Array.isArray(value))&#123; //do something&#125; 5.2.2 转换方法join方法可以使用不同的分隔符来构建这个字符串join方法只接受一个参数，用作分隔符的字符串123var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];alert(colors.join(&quot;,&quot;)); //red,blue,greenalert(colors.join(&quot;||&quot;)); //red||blue||green 5.2.3 栈方法栈是一种【LOFO】后进先出的数据结构栈中 插入叫做推入，移除叫做弹出 push() 接收任意数量的参数逐个添加到数组末尾（从末尾加）pop() 从数组末尾移除最后一项（删最后一个） 5.2.4 队列方法队列是【FIFO】先进先出 shift() 移除数组中的第一个项（删第一个）unshift() 在数组前端添加任意个项（从前面加） 5.2.5 重排列方法reverse() 翻转数组项的顺序sort() 升序排列（首字母排序，不是按大小） 比较函数 升序1function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //0,1,5,10,15 降序1function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //15,10,5,1,0 5.2.6 操作方法concat() 末尾添加数组 splice() 数组中部插入项 删除splice（要删除的第一项的位置， 要删除的项数）splice( 0, 2 ) 删除数组中前两项 插入splice( 起始位置， 0（要删除的项数）， 要插入的项)splice( 2, 0, &quot;red&quot;, &quot;green&quot; ) 从当前数组的位置2 开始插入字符串“red” 和“green” 替换splice( 起始位置， 要删除的项数， 要插入的任意数量的项)splice( 2, 1, &quot;red&quot;, &quot;green&quot; ) 会删除当前数组位置 2 的项， 然后再从位置 2 开始插入字符串 “red” 和“green”例子 1var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; var removed = colors.splice(0,1); //remove the first item alert(colors); //green,blue alert(removed); //red - one item array removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); //insert two items at position 1 alert(colors); //green,yellow,orange,blue alert(removed); //empty array removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //insert two values, remove one alert(colors); //green,red,purple,orange,blue alert(removed); //yellow - one item array 5.2.7 位置方法indexOf() 从数组的开头（位置0）开始向后查找， 没找到的情况下会返回-1lastIndexOf 从数组的末尾开始向前查找， 没找到的情况下会返回-1例子 1234567891011121314var numbers = [1,2,3,4,5,4,3,2,1]; alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5 alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3 var person = &#123; name: &quot;Nicholas&quot; &#125;;var people = [&#123; name: &quot;Nicholas&quot; &#125;];var morePeople = [person]; alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 5.2.8 迭代方法every() 对数组中的每一项运行给定函数， 如果该函数对每一项都返回true， 则返回true。filter() 对数组中的每一项运行给定函数， 返回该函数会返回 true 的项组成的数组。forEach() 对数组中的每一项运行给定的函数。 这个方法没有返回值。map() 对数组中的每一项运行给定的函数， 返回每次函数调用的结果组成的数组。some() 对数组中的每一项运行给定的函数， 如果该函数对任一项返回true， 则返回true。 以上方法都不会修改数组中的包含的值， 传入这些方法会接受三个参数（数组项的值， 该项在数组中的位置， 数组对象本身） every() some() 例子以上代码调用的every() 和 some() ， 传入的函数只要给定项大于 2 就会返回true， 对于every()，它返回的是false， 因为只有部分数组项符合条件，对于some() 就返回true， 因为至少有一项是大于 2 的。 12345678910111213var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true filter() 例子通过filter（）方法创建并返回一个所有数值都大于 2 的数组 1234567var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3] map() 例子给数组中每一项都乘以 21234567var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] forEach() 例子1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;) 5.2.9 归并方法reduce() 从数组第一项开始逐个遍历到最后reduceRight() 从数组最后一项开始，向前遍历到第一项四个参数（前一个值， 当前值， 项的索引， 数组对象） reduce() 例子求数组所有值之和12345var values = [1,2,3,4,5]; var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur; &#125;); alert(sum); reduceRight() 例子求数组所有值之和 12345var values = [1,2,3,4,5]; var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur; &#125;); alert(sum); 5.3 Data 类型Data.parse()-接收一个表示日期的字符串参数，然后根据这个字符串返回相应日期的毫秒数Data.UTC()-同样返回日期的毫秒数，但参数分别是年份、基于0但月份（一月是0，二月是1…）、月中的哪一天（1-31）、小时数（0-23）、分钟、秒、毫秒数。只有前两个参数，年和月是必须的 12345//GMT时间2000年1月1日午夜零时var y2k = new Data(Data.UTC(2000,0));//GMT时间2005年5月5日下午5:55:55var allFive = new Data(Data.UTC(2005,4,5,17,55,55)); ES5中添加来Data.now()方法 5.3.1 继承的方法"},{"title":"JS基本语法","date":"2018-09-07T01:23:21.000Z","updated":"2021-02-26T16:49:29.525Z","comments":true,"path":"md/JS基本语法.html","permalink":"https://akitsukiwong.github.io/md/JS基本语法.html","excerpt":"","text":"JS基本语法什么是 JavaScript 语言JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。 1. 语句JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。 1var a = 1 + 3; 这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。 1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 1var a = 1 + 3 ; var b = &apos;abc&apos;; 分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。 1;;; 上面的代码就表示3个空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 121 + 3;&apos;abc&apos;; 上面两行语句只是单纯地产生一个值，并没有任何实际的意义。 2.变量2.1. 概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 1var a = 1; 上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。 注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。 12var a;a = 1; 如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。 12var a;a // undefined 如果变量赋值的时候，忘了写var命令，这条语句也是有效的。 123var a = 1;// 基本等同a = 1; 但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用var命令声明变量。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 12x// ReferenceError: x is not defined 上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。 可以在同一条var命令中声明多个变量。 1var a, b; JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 12var a = 1;a = &apos;hello&apos;; 上面代码中，变量a起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量a已经存在，所以不需要使用var命令。 如果使用var重新声明一个已经存在的变量，是无效的。 123var x = 1;var x;x // 1 上面代码中，变量x声明了两次，第二次声明是无效的。 但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 12345678var x = 1;var x = 2;// 等同于var x = 1;var x;x = 2; 2.2 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 3. 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 4. 注释源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法： 单行注释，用//起头； 多行注释，放在/*和*/之间。 1234567// 这是单行注释/* 这是 多行 注释*/ 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以也被视为合法的单行注释。 12x = 1; &lt;!-- x = 2;--&gt; x = 3; 上面代码中，只有x = 1会执行，其他的部分都被注释掉了。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 1234567function countdown(n) &#123; while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0 上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0。 5. 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。 12345&#123; var a = 1;&#125;a // 1 上面代码在区块内部，使用var命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于var命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如for、if、while、function等。 6. 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 6.1 if 结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示 真，false表示 伪。 12345if (布尔值) 语句;// 或者if (布尔值) 语句; 上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。 12if (m === 3) m = m + 1; 上面代码表示，只有在m等于3时，才会将其值加上1。 这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。 123if (m === 3) &#123; m += 1;&#125; 建议总是在if语句中使用大括号，因为这样方便插入语句。 注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 123456var x = 1;var y = 2;if (x = y) &#123; console.log(x);&#125;// &quot;2&quot; 上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于2）的布尔值（结果为true）。 这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值 12if (x = 2) &#123; // 不报错if (2 = x) &#123; // 报错 至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==）。 6.2 if…else 结构if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 12345if (m === 3) &#123; // 满足条件时，执行的语句&#125; else &#123; // 不满足条件时，执行的语句&#125; 上面代码判断变量m是否等于3，如果等于就执行if代码块，否则执行else代码块。 对同一个变量进行多次判断时，多个if...else语句可以连写在一起。 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; else代码块总是与离自己最近的那个if语句配对。 123456var m = 1;var n = 2;if (m !== 1)if (n === 2) console.log(&apos;hello&apos;);else console.log(&apos;world&apos;); 上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。 1234567if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125; else &#123; console.log(&apos;world&apos;); &#125;&#125; 如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。 12345678if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125;&#125; else &#123; console.log(&apos;world&apos;);&#125;// world 6.3 switch 结构多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。 12345678910switch (fruit) &#123; case &quot;banana&quot;: // ... break; case &quot;apple&quot;: // ... break; default: // ...&#125; 上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 12345678910111213var x = 1;switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); case 2: console.log(&apos;x 等于2&apos;); default: console.log(&apos;x 等于其他值&apos;);&#125;// x等于1// x等于2// x等于其他值 上面代码中，case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。正确的写法是像下面这样。 12345678910switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); break; case 2: console.log(&apos;x 等于2&apos;); break; default: console.log(&apos;x 等于其他值&apos;);&#125; switch语句部分和case语句部分，都可以使用表达式。 1234567switch (1 + 3) &#123; case 2 + 2: f(); break; default: neverHappens();&#125; 上面代码的default部分，是永远不会执行到的。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 12345678910var x = 1;switch (x) &#123; case true: console.log(&apos;x 发生类型转换&apos;); break; default: console.log(&apos;x 没有发生类型转换&apos;);&#125;// x 没有发生类型转换 上面代码中，由于变量x没有发生类型转换，所以不会执行case true的情况。这表明，switch语句内部采用的是“严格相等运算符”。 6.4 三元运算符 ?:JavaScript 还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。 1(条件) ? 表达式1 : 表达式2 上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。 1var even = (n % 2 === 0) ? true : false; 上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。 123456var even;if (n % 2 === 0) &#123; even = true;&#125; else &#123; even = false;&#125; 这个三元运算符可以被视为if...else...的简写形式，因此可以用于多种场合。 1234567var myVar;console.log( myVar ? &apos;myVar has a value&apos; : &apos;myVar does not have a value&apos;)// myVar does not have a value 上面代码利用三元运算符，输出相应的提示。 1var msg = &apos;数字&apos; + n + &apos;是&apos; + (n % 2 === 0 ? &apos;偶数&apos; : &apos;奇数&apos;); 上面代码利用三元运算符，在字符串之中插入不同的值。 7. 循环语句循环语句用于重复执行某个操作，它有多种形式。 7.1 while 循环While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 12345while (条件) 语句;// 或者while (条件) 语句; while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; 下面是while语句的一个例子。 123456var i = 0;while (i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i = i + 1;&#125; 上面的代码将循环100次，直到i等于100为止。 下面的例子是一个无限循环，因为循环条件总是为真。 123while (true) &#123; console.log(&apos;Hello, world&apos;);&#125; 7.2 for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。 12345678for (初始化表达式; 条件; 递增表达式) 语句// 或者for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; for语句后面的括号里面，有三个表达式。 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。 条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。 递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。 下面是一个例子。 1234567var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2 上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。 所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。 1234567var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。 123for ( ; ; )&#123; console.log(&apos;Hello World&apos;);&#125; 上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。 7.3 do…while 循环do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 12345678do 语句while (条件);// 或者do &#123; 语句&#125; while (条件); 不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。 下面是一个例子。 1234567var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); 7.4 break 语句和 continue 语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。 break语句用于跳出代码块或循环。 1234567var i = 0;while(i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i++; if (i === 10) break;&#125; 上面代码只会执行10次循环，一旦i等于10，就会跳出循环。 for循环也可以使用break语句跳出循环。 123456789for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break;&#125;// 0// 1// 2// 3 上面代码执行到i等于3，就会跳出循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 1234567var i = 0;while (i &lt; 100)&#123; i++; if (i % 2 === 0) continue; console.log(&apos;i 当前为：&apos; + i);&#125; 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。 7.5 标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label: 语句 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 标签也可以用于跳出代码块。 12345678foo: &#123; console.log(1); break foo; console.log(&apos;本行不会输出&apos;);&#125;console.log(2);// 1// 2 上面代码执行到break foo，就会跳出区块。 continue语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2"},{"title":"","date":"2021-02-26T16:49:29.491Z","updated":"2021-02-26T16:49:29.491Z","comments":true,"path":"demo/canvas/flag.html","permalink":"https://akitsukiwong.github.io/demo/canvas/flag.html","excerpt":"","text":"flag var canvas = document.getElementById(\"myCanvas\"); //根据 id 找到 canvas 元素 var cxt = canvas.getContext(\"2d\"); //getContext() 方法返回一个用于在画布上绘图的环境 cxt.fillStyle = \"#FF0000\"; //填充颜色 不填充颜色默认为黑色 cxt.fillRect(0, 0, 100, 50); //规定了形状，位置，尺寸 cxt.fillStyle = \"#000000\" cxt.fillRect(0, 0, 3, 120); function waveFlag(canvas, wavelength, amplitude = 10, period = 200, shading = 100, squeeze = 0) { if (!wavelength) wavelength = canvas.width / 10; let fps = 30; let ctx = canvas.getContext('2d'); let w = canvas.width, h = canvas.height; let od = ctx.getImageData(0, 0, w, h).data; return (timer = setInterval(() => { let id = ctx.getImageData(0, 0, w, h); let d = id.data; let now = new Date() / period; for (let y = 0; y < h; ++y) { let lastO = 0, shade = 0; let sq = (y - h / 2) * squeeze; for (let x = 0; x < w; ++x) { let px = (y * w + x) * 4; let pct = x / w; let o = Math.sin(x / wavelength - now) * amplitude * pct; let y2 = (y + (o + sq * pct)) < 0; let opx = (y2 * w + x) * 4; shade = (o - lastO) * shading; d[px] = od[opx] + shade; d[px + 1] = od[opx + 1] + shade; d[px + 2] = od[opx + 2] + shade; d[px + 3] = od[opx + 3]; lastO = o; } } ctx.putImageData(id, 0, 0); }, 1000 / fps)); } waveFlag(canvas, 5, 10, 200, 10, 0.2);"},{"title":"","date":"2021-02-26T16:49:29.491Z","updated":"2021-02-26T16:49:29.491Z","comments":true,"path":"demo/canvas/arc.html","permalink":"https://akitsukiwong.github.io/demo/canvas/arc.html","excerpt":"","text":"canvas var c = document.getElementById(\"myCanvas\"); var ctx = c.getContext(\"2d\"); ctx.beginPath(); ctx.arc(95, 50, 40, 0, 2 * Math.PI); ctx.stroke(); 12345678 &lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt; &lt;script type=\"text/javascript\"&gt; var c = document.getElementById(\"myCanvas\"); var ctx = c.getContext(\"2d\"); ctx.rect(10, 10, 50, 50); //创建矩形 ctx.stroke(); // 绘制图形&lt;/script&gt;"},{"title":"","date":"2021-02-26T16:49:29.491Z","updated":"2021-02-26T16:49:29.491Z","comments":true,"path":"demo/canvas/index2.html","permalink":"https://akitsukiwong.github.io/demo/canvas/index2.html","excerpt":"","text":"canvas var canvas = document.getElementById(\"myCanvas\"); //根据 id 找到 canvas 元素 var cxt = canvas.getContext(\"2d\"); //getContext() 方法返回一个用于在画布上绘图的环境 cxt.fillStyle = \"#FF0000\"; //填充颜色 不填充颜色默认为黑色 cxt.fillRect(0, 0, 100, 50); //规定了形状，位置，尺寸 12345678&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var canvas = document.getElementById(\"myCanvas\"); //根据 id 找到 canvas 元素 var cxt = canvas.getContext(\"2d\"); //getContext() 方法返回一个用于在画布上绘图的环境 cxt.fillStyle = \"#FF0000\"; //填充颜色 cxt.fillRect(0, 0, 100, 50); //规定了形状，位置，尺寸&lt;/script&gt;"},{"title":"","date":"2021-02-26T16:49:29.491Z","updated":"2021-02-26T16:49:29.491Z","comments":true,"path":"demo/canvas/index.html","permalink":"https://akitsukiwong.github.io/demo/canvas/index.html","excerpt":"","text":"canvas 下面其实有个canvas 1&lt;canvas width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;"},{"title":"","date":"2021-02-26T16:49:29.492Z","updated":"2021-02-26T16:49:29.492Z","comments":true,"path":"demo/canvas/index4.html","permalink":"https://akitsukiwong.github.io/demo/canvas/index4.html","excerpt":"","text":"canvas var c = document.getElementById(\"myCanvas\"); var ctx = c.getContext(\"2d\"); ctx.fillRect(10, 10, 50, 50); //绘制被填充的矩形，默认填充颜色是黑色 1234567&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var c = document.getElementById(\"myCanvas\"); var ctx = c.getContext(\"2d\"); ctx.fillRect(10, 10, 50, 50); //绘制被填充的矩形，默认填充颜色是黑色&lt;/script&gt;"},{"title":"","date":"2021-02-26T16:49:29.492Z","updated":"2021-02-26T16:49:29.492Z","comments":true,"path":"demo/canvas/index3.html","permalink":"https://akitsukiwong.github.io/demo/canvas/index3.html","excerpt":"","text":"canvas var c = document.getElementById(\"myCanvas\"); var ctx = c.getContext(\"2d\"); ctx.rect(10, 10, 50, 50); //创建矩形 ctx.stroke(); // 绘制图形 12345678&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt; &lt;script type=\"text/javascript\"&gt; var c = document.getElementById(\"myCanvas\"); var ctx = c.getContext(\"2d\"); ctx.rect(10, 10, 50, 50); //创建矩形 ctx.stroke(); // 绘制图形&lt;/script&gt;"},{"title":"","date":"2021-02-26T16:49:29.492Z","updated":"2021-02-26T16:49:29.492Z","comments":true,"path":"demo/canvas/line.html","permalink":"https://akitsukiwong.github.io/demo/canvas/line.html","excerpt":"","text":"canvas var c = document.getElementById(\"myCanvas\"); var ctx = c.getContext(\"2d\"); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(200, 100); ctx.stroke(); 1234567 &lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var c = document.getElementById(\"myCanvas\"); var ctx = c.getContext(\"2d\"); ctx.fillRect(10, 10, 50, 50); //绘制被填充的矩形，默认填充颜色是黑色&lt;/script&gt;"},{"title":"","date":"2021-02-26T16:49:29.493Z","updated":"2021-02-26T16:49:29.493Z","comments":true,"path":"demo/canvas/sin.html","permalink":"https://akitsukiwong.github.io/demo/canvas/sin.html","excerpt":"","text":"sin var i = 1; var x = 1; var y = 100; function moveSin() { var oCanvas = document.getElementById(\"theCanvas\"); var content = oCanvas.getContext(\"2d\"); content.beginPath(); content.moveTo(x, y); i += 0.1; x = i * 10; y = Math.sin(i) * 10 + 100; content.lineTo(x, y); content.stroke(); content.closePath(); } setInterval(moveSin, 10); window.onload = function () { moveSin(); }"},{"title":"","date":"2021-02-26T16:49:29.493Z","updated":"2021-02-26T16:49:29.493Z","comments":true,"path":"demo/canvas/sin2.html","permalink":"https://akitsukiwong.github.io/demo/canvas/sin2.html","excerpt":"","text":"var curve = function () { var c = document.getElementById(\"study\"); var ctx = c.getContext(\"2d\"); //线条主色 var mianColor = \"#e2dedb\" //画图函数 var Drawing = { line: function (starxy, endxy, lineWidth, color) { ctx.strokeStyle = color; ctx.lineWidth = lineWidth; ctx.beginPath(); ctx.moveTo(starxy[0], starxy[1]); ctx.lineTo(endxy[0], endxy[1]); ctx.stroke(); }, ract: function (starxy, ractWH, color) { ctx.fillStyle = color; ctx.fillRect(starxy[0], starxy[1], ractWH[0], ractWH[1]); }, ractBorder: function (starxy, ractWH, color, lineWidth) { ctx.lineWidth = lineWidth; ctx.strokeStyle = color; ctx.strokeRect(starxy[0], starxy[1], ractWH[0], ractWH[1]); }, /*Drawing.triCurve(triangle, star, cp, color) triangle:三角函数 star：{x：开始x坐标，y：开始的y坐标} cp：{xw：控制x的宽度，yh：控制y的高度，s：位移} color：线条颜色 */ triCurve: function (triangle, star, cp, color) { ctx.strokeStyle = color; ctx.beginPath(); ctx.moveTo(star.x, star.y); //中心判断 var change = false; //中点计算 var count = cp.yh; for (var i = cp.s; i * cp.xw - cp.xw * cp.s + star.x < 600; i += 0.1) { count += 0.5; } var center = parseInt(count / 2); //三角函数曲线 for (var i = cp.s; i * cp.xw - cp.xw * cp.s + star.x < 600; i += 0.1) { if (change === false && cp.yh < center) { cp.yh += 0.5; } if (change === false && cp.yh === center) { change = true; cp.yh -= 0.5; } if (change === true && cp.yh < center) { cp.yh -= 0.5; } var x = i * cp.xw - cp.xw * cp.s + star.x; var y = Math[triangle](i * cp.angle) * cp.yh + star.y; ctx.lineTo(x, y); } ctx.stroke(); ctx.closePath(); }, } //背景填充 Drawing.ract([0, 0], [600, 360], \"#333333\"); //播放条 var play = function (btn) { ctx.clearRect(0, 0, 600, 130); Drawing.ract([0, 0], [600, 130], \"#333333\"); var playLineStar = [93, 105]; var playLineWH = [494, 105]; var playBtnWH = [11, 21]; Drawing.line(playLineStar, playLineWH, 4, mianColor); var playBtnStarX; var playBtnStarY = playLineWH[1] - playBtnWH[1] / 2; btn == undefined ? playBtnStarX = (playLineWH[0] + playLineStar[0]) / 2 - playBtnWH[0] / 2 : playBtnStarX = 4 * btn + playLineStar[0]; Drawing.ractBorder([playBtnStarX, playBtnStarY], playBtnWH, \"#9d9996\", 1); Drawing.ract([playBtnStarX += 1, playBtnStarY += 1], [playBtnWH[0] - 2, playBtnWH[1] - 2], mianColor); } play(); //鼠标滚动控制播放条 var waveGo; var distance = 0; var scrollFunc = function (e) { e = e || window.event; var mouseMove; e.wheelDelta ? mouseMove = e.wheelDelta : mouseMove = e.detail; if (mouseMove > 0) { distance += 5; if (distance >= 100) distance = 100; }//up if (mouseMove < 0) { distance -= 5; if (distance = 100 ? 100 : ad + 15; console.log(adjust); ctx.clearRect(0, 130, 600, 360); Drawing.ract([0, 130], [600, 360], \"#333333\"); if (dong === 1) { cango = false; } if (!cango && dong < 3) { dong += 1; } if (dong === 3) { cango = true; } if (cango && dong"},{"title":"Document 节点","date":"2018-09-29T00:47:00.000Z","updated":"2021-02-26T16:49:29.524Z","comments":true,"path":"md/Document-节点.html","permalink":"https://akitsukiwong.github.io/md/Document-节点.html","excerpt":"","text":"Document 节点概述document节点对象代表整个文档，每张网页都有自己的document对象。window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。 document对象有不同的办法可以获取。 正常的网页，直接使用document或window.document。iframe框架里面的网页，使用iframe节点的contentDocument属性。Ajax操作返回的文档，使用XMLHttpRequest对象的responseXML属性。内部节点的ownerDocument属性。document对象继承了EventTarget接口、Node接口、ParentNode接口。这意味着，这些接口的方法都可以在document对象上调用。除此之外，document对象还有很多自己的属性和方法。 属性快捷方式属性以下属性是指向文档内部的某个节点的快捷方式。 （1）document.defaultViewdocument.defaultView属性返回document对象所属的window对象。如果当前文档不属于window对象，该属性返回null。 1document.defaultView === window // true （2）document.doctype对于 HTML 文档来说，document对象一般有两个子节点。第一个子节点是document.doctype，指向&lt;DOCTYPE&gt;节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成&lt;!DOCTYPE html&gt;。如果网页没有声明 DTD，该属性返回null。 123var doctype = document.doctype;doctype // &quot;&lt;!DOCTYPE html&gt;&quot;doctype.name // &quot;html&quot; document.firstChild通常就返回这个节点。 （3）document.documentElementdocument.documentElement属性返回当前文档的根元素节点（root）。它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。HTML网页的该属性，一般是节点。 （4）document.body，document.headdocument.body属性指向&lt;body&gt;节点，document.head属性指向&lt;head&gt;节点。 这两个属性总是存在的，如果网页源码里面省略了&lt;head&gt;或&lt;body&gt;，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。 （5）document.scrollingElementdocument.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。 标准模式下，这个属性返回的文档的根元素document.documentElement（即）。兼容（quirk）模式下，返回的是元素，如果该元素不存在，返回null。 12// 页面滚动到浏览器顶部document.scrollingElement.scrollTop = 0; （6）document.activeElementdocument.activeElement属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;等表单元素，如果当前没有焦点元素，返回&lt;body&gt;元素或null。 （7）document.fullscreenElementdocument.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。 123if (document.fullscreenElement.nodeName == &apos;VIDEO&apos;) &#123; console.log(&apos;全屏播放视频&apos;);&#125; 上面代码中，通过document.fullscreenElement可以知道&lt;video&gt;元素有没有处在全屏状态，从而判断用户行为。 节点集合属性以下属性返回一个HTMLCollection实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。 （1）document.linksdocument.links属性返回当前文档所有设定了href属性的&lt;a&gt;及&lt;area&gt;节点。 12345// 打印文档所有的链接var links = document.links;for(var i = 0; i &lt; links.length; i++) &#123; console.log(links[i]);&#125; （2）document.formsdocument.forms属性返回所有&lt;form&gt; 表单节点。 1var selectForm = document.forms[0]; 上面代码获取文档第一个表单。 除了使用位置序号，id属性和name属性也可以用来引用表单。 12345/* HTML 代码如下 &lt;form name=&quot;foo&quot; id=&quot;bar&quot;&gt;&lt;/form&gt;*/document.forms[0] === document.forms.foo // truedocument.forms.bar === document.forms.foo // true （3）document.imagesdocument.images属性返回页面所有图片节点。 1234567var imglist = document.images;for(var i = 0; i &lt; imglist.length; i++) &#123; if (imglist[i].src === &apos;banner.gif&apos;) &#123; // ... &#125;&#125; 上面代码在所有img标签中，寻找某张图片。 （4）document.embeds，document.pluginsdocument.embeds属性和document.plugins属性，都返回所有&lt;embed&gt;节点。 （5）document.scriptsdocument.scripts属性返回所有&lt;script&gt;节点。 1234var scripts = document.scripts;if (scripts.length !== 0 ) &#123; console.log(&apos;当前网页有脚本&apos;);&#125; （6）document.styleSheetsdocument.styleSheets属性返回文档内嵌或引入的样式表集合 （7）小结除了document.styleSheets，以上的集合属性返回的都是HTMLCollection实例。 12345document.links instanceof HTMLCollection // truedocument.images instanceof HTMLCollection // truedocument.forms instanceof HTMLCollection // truedocument.embeds instanceof HTMLCollection // truedocument.scripts instanceof HTMLCollection // true HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。 123// HTML 代码如下// &lt;form name=&quot;myForm&quot;&gt;document.myForm === document.forms.myForm // true 文档静态信息属性以下属性返回文档信息。 （1）document.documentURI，document.URLdocument.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；URL继承自HTMLDocument接口，只能用于 HTML 文档。 12345document.URL// http://www.example.com/aboutdocument.documentURI === document.URL// true 如果文档的锚点（#anchor）变化，这两个属性都会跟着变化。 （2）document.domaindocument.domain属性返回当前文档的域名，不包含协议和接口。比如，网页的网址是http://www.example.com:80/hello.html，那么domain属性就等于www.example.com。如果无法获取域名，该属性返回null。 document.domain基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把document.domain设为对应的上级域名。比如，当前域名是a.sub.example.com，则document.domain属性可以设置为sub.example.com，也可以设为example.com。修改后，document.domain相同的两个网页，可以读取对方的资源，比如设置的 Cookie。 另外，设置document.domain会导致端口被改成null。因此，如果通过设置document.domain来进行通信，双方网页都必须设置这个值，才能保证端口相同。 （3）document.locationLocation对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。 （4）document.lastModifieddocument.lastModified属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。 12document.lastModified// &quot;03/07/2018 11:18:27&quot; 注意，document.lastModified属性的值是字符串，所以不能直接用来比较。Date.parse方法将其转为Date实例，才能比较两个网页。 1234var lastVisitedDate = Date.parse(&apos;01/01/2018&apos;);if (Date.parse(document.lastModified) &gt; lastVisitedDate) &#123; console.log(&apos;网页已经变更&apos;);&#125; 如果页面上有 JavaScript 生成的内容，document.lastModified属性返回的总是当前时间。 （5）document.titledocument.title属性返回当前文档的标题。默认情况下，返回&lt;title&gt;节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。 12document.title = &apos;新标题&apos;;document.title // &quot;新标题&quot; （6）document.characterSetdocument.characterSet属性返回当前文档的编码，比如UTF-8、ISO-8859-1等等。 （7）document.referrerdocument.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。 12document.referrer// &quot;https://example.com/path&quot; 如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，document.referrer返回一个空字符串。 document.referrer的值，总是与 HTTP 头信息的Referer字段保持一致。但是，document.referrer的拼写有两个r，而头信息的Referer字段只有一个r。 （8）document.dirdocument.dir返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。 ####（9）document.compatMode compatMode属性返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）。 一般来说，如果网页代码的第一行设置了明确的DOCTYPE（比如&lt;!doctype html&gt;），document.compatMode的值都为CSS1Compat。 文档状态属性（1）document.hiddendocument.hidden属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。 这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。 （2）document.visibilityStatedocument.visibilityState返回文档的可见状态。 它的值有四种可能。 visible：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。 hidden： 页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。 prerender：页面处于正在渲染状态，对于用于来说，该页面不可见。 unloaded：页面从内存里面卸载了。 这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。 （3）document.readyStatedocument.readyState属性返回当前文档的状态，共有三种可能的值。 loading：加载 HTML 代码阶段（尚未完成解析） interactive：加载外部资源阶段 complete：加载完成 这个属性变化的过程如下。 浏览器开始解析 HTML 文档，document.readyState属性等于loading。 浏览器遇到 HTML 文档中的&lt;script&gt;元素，并且没有async或defer属性，就暂停解析，开始执行脚本，这时document.readyState属性还是等于loading。 HTML 文档解析完成，document.readyState属性变成interactive。 浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，document.readyState属性变成complete。 下面的代码用来检查网页是否加载成功。 123456789101112// 基本检查if (document.readyState === &apos;complete&apos;) &#123; // ...&#125;// 轮询检查var interval = setInterval(function() &#123; if (document.readyState === &apos;complete&apos;) &#123; clearInterval(interval); // ... &#125;&#125;, 100); 另外，每次状态变化都会触发一个readystatechange事件。 document.cookiedocument.cookie属性用来操作浏览器 Cookie document.designModedocument.designMode属性控制当前文档是否可编辑。该属性只有两个值on和off，默认值为off。一旦设为on，用户就可以编辑整个文档的内容。 下面代码打开iframe元素内部文档的designMode属性，就能将其变为一个所见即所得的编辑器。 1234// HTML 代码如下// &lt;iframe id=&quot;editor&quot; src=&quot;about:blank&quot;&gt;&lt;/iframe&gt;var editor = document.getElementById(&apos;editor&apos;);editor.contentDocument.designMode = &apos;on&apos;; document.implementationdocument.implementation属性返回一个DOMImplementation对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。 DOMImplementation.createDocument()：创建一个 XML 文档。 DOMImplementation.createHTMLDocument()：创建一个 HTML 文档。 DOMImplementation.createDocumentType()：创建一个 DocumentType 对象。 下面是创建 HTML 文档的例子。 123456789var doc = document.implementation.createHTMLDocument(&apos;Title&apos;);var p = doc.createElement(&apos;p&apos;);p.innerHTML = &apos;hello world&apos;;doc.body.appendChild(p);document.replaceChild( doc.documentElement, document.documentElement); 上面代码中，第一步生成一个新的 HTML 文档doc，然后用它的根元素document.documentElement替换掉document.documentElement。这会使得当前文档的内容全部消失，变成hello world。 方法document.open()，document.close()document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。 document.close方法用来关闭document.open()打开的文档。 123document.open();document.write(&apos;hello world&apos;);document.close(); document.write()，document.writeln()document.write方法用于向当前文档写入内容。 在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行document.close()），document.write写入的内容就会追加在已有内容的后面。 12345// 页面显示“helloworld”document.open();document.write(&apos;hello&apos;);document.write(&apos;world&apos;);document.close(); 注意，document.write会当作 HTML 代码解析，不会转义。 1document.write(&apos;&lt;p&gt;hello world&lt;/p&gt;&apos;); 上面代码中，document.write会将&lt;p&gt;当作 HTML 标签解释。 如果页面已经解析完成（DOMContentLoaded事件发生之后），再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。 12345678910document.addEventListener(&apos;DOMContentLoaded&apos;, function (event) &#123; document.write(&apos;&lt;p&gt;Hello World!&lt;/p&gt;&apos;);&#125;);// 等同于document.addEventListener(&apos;DOMContentLoaded&apos;, function (event) &#123; document.open(); document.write(&apos;&lt;p&gt;Hello World!&lt;/p&gt;&apos;); document.close();&#125;); 如果在页面渲染过程中调用write方法，并不会自动调用open方法。（可以理解成，open方法已调用，但close方法还未调用。） 12345678&lt;html&gt;&lt;body&gt;hello&lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;world&quot;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器打开上面网页，将会显示hello world。 document.write是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对innerHTML属性赋值）。所以，除了某些特殊情况，应该尽量避免使用document.write这个方法。 document.writeln方法与write方法完全一致，除了会在输出内容的尾部添加换行符。 123456789document.write(1);document.write(2);// 12document.writeln(1);document.writeln(2);// 1// 2// 注意，writeln方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入&lt;br&gt;。 document.querySelector()，document.querySelectorAll()document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。 12var el1 = document.querySelector(&apos;.myclass&apos;);var el2 = document.querySelector(&apos;#myParent &gt; [ng-click]&apos;); document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。 1234elementList = document.querySelectorAll(&apos;.myclass&apos;);``` 这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。 var matches = document.querySelectorAll(‘div.note, div.alert’);1234上面代码返回`class`属性是`note`或`alert`的`div`元素。这两个方法都支持复杂的 CSS 选择器。 // 选中 data-foo-bar 属性等于 someval 的元素document.querySelectorAll(‘[data-foo-bar=”someval”]’); // 选中 myForm 表单中所有不通过验证的元素document.querySelectorAll(‘#myForm :invalid’); // 选中div元素，那些 class 含 ignore 的除外document.querySelectorAll(‘DIV:not(.ignore)’); // 同时选中 div，a，script 三类元素document.querySelectorAll(‘DIV, A, SCRIPT’);12345678910但是，它们不支持 CSS 伪元素的选择器（比如`:first-line`和`:first-letter`）和伪类的选择器（比如`:link`和`:visited`），即无法选中伪元素和伪类。如果`querySelectorAll`方法的参数是字符串`*`，则会返回文档中的所有元素节点。另外，`querySelectorAll`的返回结果不是动态集合，不会实时反映元素节点的变化。最后，这两个方法除了定义在`document`对象上，还定义在元素节点上，即在元素节点上也可以调用。### document.getElementsByTagName()`document.getElementsByTagName`方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（`HTMLCollection`实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。 var paras = document.getElementsByTagName(‘p’);paras instanceof HTMLCollection // true123456上面代码返回当前文档的所有`p`元素节点。HTML 标签名是大小写不敏感的，因此`getElementsByTagName`方法也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。如果传入`*`，就可以返回文档中所有 HTML 元素。 var allElements = document.getElementsByTagName(‘*’);12注意，元素节点本身也定义了`getElementsByTagName`方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在`document`对象上调用，也可以在任何元素节点上调用。 var firstPara = document.getElementsByTagName(‘p’)[0];var spans = firstPara.getElementsByTagName(‘span’);123456上面代码选中第一个`p`元素内部的所有`span`元素。### document.getElementsByClassName()`document.getElementsByClassName`方法返回一个类似数组的对象（`HTMLCollection`实例），包括了所有`class`名字符合指定条件的元素，元素的变化实时反映在返回结果中。 var elements = document.getElementsByClassName(names);1234由于`class`是保留字，所以 JavaScript 一律使用`className`表示 CSS 的`class`。参数可以是多个`class`，它们之间使用空格分隔。 var elements = document.getElementsByClassName(‘foo bar’);12345678910上面代码返回同时具有`foo`和`bar`两个`class`的元素，`foo`和`bar`的顺序不重要。注意，正常模式下，CSS 的`class`是大小写敏感的。（`quirks mode`下，大小写不敏感。）与`getElementsByTagName`方法一样，`getElementsByClassName`方法不仅可以在`document`对象上调用，也可以在任何元素节点上调用。### document.getElementsByName() `document.getElementsByName`方法用于选择拥有`name`属性的 HTML 元素（比如`&lt;form&gt;`、`&lt;radio&gt;`、`&lt;img&gt;`、`&lt;frame&gt;`、`&lt;embed&gt;`和`&lt;object&gt;`等），返回一个类似数组的的对象（`NodeList`实例），因为`name`属性相同的元素可能不止一个。 // 表单为 var forms = document.getElementsByName(‘x’);forms[0].tagName // “FORM”1234### document.getElementById()`document.getElementById`方法返回匹配指定`id`属性的元素节点。如果没有发现匹配的节点，则返回`null`。 var elem = document.getElementById(‘para1’);1234注意，该方法的参数是大小写敏感的。比如，如果某个节点的`id`属性是`main`，那么`document.getElementById(&apos;Main&apos;)`将返回`null`。`document.getElementById`方法与`document.querySelector`方法都能获取元素节点，不同之处是`document.querySelector`方法的参数使用 CSS 选择器语法，`document.getElementById`方法的参数是元素的`id`属性。 document.getElementById(‘myElement’)document.querySelector(‘#myElement’)12345678上面代码中，两个方法都能选中`id`为`myElement`的元素，但是`document.getElementById()`比`document.querySelector()`效率高得多。另外，这个方法只能在`document`对象上使用，不能在其他元素节点上使用。### document.elementFromPoint()，document.elementsFromPoint() `document.elementFromPoint`方法返回位于页面指定位置最上层的元素节点。 var element = document.elementFromPoint(50, 50);123456上面代码选中在(50, 50)这个坐标位置的最上层的那个 HTML 元素。elementFromPoint方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回null。document.elementsFromPoint()返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。 var elements = document.elementsFromPoint(x, y);1234### document.caretPositionFromPoint()`document.caretPositionFromPoint()`返回一个 `CaretPosition` 对象，包含了指定坐标点在节点对象内部的位置信息。`CaretPosition` 对象就是光标插入点的概念，用于确定光标点在文本对象内部的具体位置。 var range = document.caretPositionFromPoint(clientX, clientY);12345678910上面代码中，`range`是指定坐标点的 `CaretPosition` 对象。该对象有两个属性。- CaretPosition.offsetNode：该位置的节点对象- CaretPosition.offset：该位置在offsetNode对象内部，与起始位置相距的字符数。### document.createElement()`document.createElement`方法用来生成元素节点，并返回该节点。 var newDiv = document.createElement(‘div’);12`createElement`方法的参数为元素的标签名，即元素节点的`tagName`属性，对于 HTML 网页大小写不敏感，即参数为`div`或`DIV`返回的是同一种节点。如果参数里面包含尖括号（即`&lt;`和`&gt;`）会报错。 document.createElement(‘‘);// DOMException: The tag name provided (‘‘) is not a valid name12注意，`document.createElement`的参数可以是自定义的标签名。 document.createElement(‘foo’);1234### document.createTextNode()`document.createTextNode`方法用来生成文本节点（`Text`实例），并返回该节点。它的参数是文本节点的内容。 var newDiv = document.createElement(‘div’);var newContent = document.createTextNode(‘Hello’);newDiv.appendChild(newContent);1234上面代码新建一个`div`节点和一个文本节点，然后将文本节点插入`div`节点。这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。 var div = document.createElement(‘div’);div.appendChild(document.createTextNode(‘Foo &amp; bar‘));console.log(div.innerHTML)// &lt;span&gt;Foo &amp; bar&lt;/span&gt;1234上面代码中，`createTextNode`方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。 function escapeHtml(str) { var div = document.createElement(‘div’); div.appendChild(document.createTextNode(str)); return div.innerHTML;}; var userWebsite = ‘“ onmouseover=”alert(\\’derp\\’)” “‘;var profileLink = ‘Bob‘;var div = document.getElementById(‘target’);div.innerHTML = profileLink;// Bob123456上面代码中，由于`createTextNode`方法不转义双引号，导致`onmouseover`方法被注入了代码。### document.createAttribute() `document.createAttribute`方法生成一个新的属性节点（`Attr`实例），并返回它。 var attribute = document.createAttribute(name);12`document.createAttribute`方法的参数`name`，是属性的名称。 var node = document.getElementById(‘div1’); var a = document.createAttribute(‘my_attrib’);a.value = ‘newVal’; node.setAttributeNode(a);// 或者node.setAttribute(‘my_attrib’, ‘newVal’);123456上面代码为`div1`节点，插入一个值为`newVal`的`my_attrib`属性。### document.createComment() `document.createComment`方法生成一个新的注释节点，并返回该节点。 var CommentNode = document.createComment(data);`"},{"title":"面向对象编程","date":"2018-09-29T00:46:17.000Z","updated":"2021-02-26T16:49:29.528Z","comments":true,"path":"md/面向对象编程.html","permalink":"https://akitsukiwong.github.io/md/面向对象编程.html","excerpt":"","text":"面向对象编程 实例对象与 new 命令 this 关键字 对象的继承 Object 对象的相关方法 严格模式 实例对象与 new 命令JavaScript 语言具有很强的面向对象编程能力，本章介绍 JavaScript 面向对象编程的基础知识。 1. 对象是什么面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。 那么，“对象”（object）到底是什么？我们从两个层次来理解。 （1）对象是单个实物的抽象。 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 （2）对象是一个容器，封装了属性（property）和方法（method）。 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 2. 构造函数面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。 JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。 构造函数就是一个普通的函数，但是有自己的特征和用法。 123var Vehicle = function () &#123; this.price = 1000;&#125;; 上面代码中，Vehicle 就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。 构造函数的特点有两个。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。 下面先介绍new命令。 3. new 命令3.1 基本用法new 命令的作用，就是执行构造函数，返回一个实例对象。 123456var Vehicle = function () &#123; this.price = 1000;&#125;;var v = new Vehicle();v.price // 1000 上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle得到了price属性。new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，值是1000。 使用new命令时，根据需要，构造函数也可以接受参数。 12345var Vehicle = function (p) &#123; this.price = p;&#125;;var v = new Vehicle(500); new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。 1234// 推荐的写法var v = new Vehicle();// 不推荐的写法var v = new Vehicle; 一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？ 这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。 1234567var Vehicle = function ()&#123; this.price = 1000;&#125;;var v = Vehicle();v // undefinedprice // 1000 上面代码中，调用Vehicle构造函数时，忘了加上new命令。结果，变量v变成了undefined，而price属性变成了全局变量。因此，应该非常小心，避免不使用new命令、直接调用构造函数。 为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。 12345678function Fubar(foo, bar)&#123; &apos;use strict&apos;; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError: Cannot set property &apos;_foo&apos; of undefined 上面代码的Fubar为构造函数，use strict命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的this不能指向全局对象，默认等于undefined，导致不加new调用会报错（JavaScript 不允许对undefined添加属性）。 另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。 1234567891011function Fubar(foo, bar) &#123; if (!(this instanceof Fubar)) &#123; return new Fubar(foo, bar); &#125; this._foo = foo; this._bar = bar;&#125;Fubar(1, 2)._foo // 1(new Fubar(1, 2))._foo // 1 上面代码中的构造函数，不管加不加new命令，都会得到同样的结果。 3.2 new 命令的原理使用new命令时，它后面的函数依次执行下面的步骤。 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。 1234567var Vehicle = function () &#123; this.price = 1000; return 1000;&#125;;(new Vehicle()) === 1000// false 上面代码中，构造函数Vehicle的return语句返回一个数值。这时，new命令就会忽略这个return语句，返回“构造”后的this对象。 但是，如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。 1234567var Vehicle = function ()&#123; this.price = 1000; return &#123; price: 2000 &#125;;&#125;;(new Vehicle()).price// 2000 上面代码中，构造函数Vehicle的return语句，返回的是一个新对象。new命令会返回这个对象，而不是this对象。 另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。 12345678function getMessage() &#123; return &apos;this is a message&apos;;&#125;var msg = new getMessage();msg // &#123;&#125;typeof msg // &quot;object&quot; 上面代码中，getMessage是一个普通函数，返回一个字符串。对它使用new命令，会得到一个空对象。这是因为new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。本例中，return语句返回的是字符串，所以new命令就忽略了该语句。 new命令简化的内部流程，可以用下面的代码表示。 123456789101112131415function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) &#123; // 将 arguments 对象转为数组 var args = [].slice.call(arguments); // 取出构造函数 var constructor = args.shift(); // 创建一个空对象，继承构造函数的 prototype 属性 var context = Object.create(constructor.prototype); // 执行构造函数 var result = constructor.apply(context, args); // 如果返回结果是对象，就直接返回，否则返回 context 对象 return (typeof result === &apos;object&apos; &amp;&amp; result != null) ? result : context;&#125;// 实例var actor = _new(Person, &apos;张三&apos;, 28); 3.3 new.target函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。 123456function f() &#123; console.log(new.target === f);&#125;f() // falsenew f() // true 使用这个属性，可以判断函数调用的时候，是否使用new命令。 12345678function f() &#123; if (!new.target) &#123; throw new Error(&apos;请使用 new 命令调用！&apos;); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ 上面代码中，构造函数f调用时，没有使用new命令，就抛出一个错误。 4. Object.create() 创建实例对象构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。 123456789101112var person1 = &#123; name: &apos;张三&apos;, age: 38, greeting: function() &#123; console.log(&apos;Hi! I\\&apos;m &apos; + this.name + &apos;.&apos;); &#125;&#125;;var person2 = Object.create(person1);person2.name // 张三person2.greeting() // Hi! I&apos;m 张三. 上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法。 this 关键字1. 涵义this关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。 前一章已经提到，this可以用在构造函数之中，表示实例对象。除此之外，this还可以用在别的场合。但不管是什么场合，this都有一个共同点：它总是返回一个对象。 简单说，this就是属性或方法“当前”所在的对象。 1this.property 上面代码中，this就代表property属性当前所在的对象。 下面是一个实际的例子。 123456789var person = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;person.describe()// &quot;姓名：张三&quot; 上面代码中，this.name表示name属性所在的那个对象。由于this.name是在describe方法中调用，而describe方法所在的当前对象是person，因此this指向person，this.name就是person.name。 由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。 1234567891011121314var A = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var B = &#123; name: &apos;李四&apos;&#125;;B.describe = A.describe;B.describe()// &quot;姓名：李四&quot; 上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。 稍稍重构这个例子，this的动态指向就能看得更清楚。 12345678910111213141516function f() &#123; return &apos;姓名：&apos;+ this.name;&#125;var A = &#123; name: &apos;张三&apos;, describe: f&#125;;var B = &#123; name: &apos;李四&apos;, describe: f&#125;;A.describe() // &quot;姓名：张三&quot;B.describe() // &quot;姓名：李四&quot; 上面代码中，函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。 只要函数被赋给另一个变量，this的指向就会变。 12345678910var A = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var name = &apos;李四&apos;;var f = A.describe;f() // &quot;姓名：李四&quot; 上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。 再看一个网页编程的例子。 12345678&lt;input type=&quot;text&quot; name=&quot;age&quot; size=3 onChange=&quot;validate(this, 18, 99);&quot;&gt;&lt;script&gt;function validate(obj, lowval, hival)&#123; if ((obj.value &lt; lowval) || (obj.value &gt; hival)) console.log(&apos;Invalid Value!&apos;);&#125;&lt;/script&gt; 上面代码是一个文本输入框，每当用户输入一个值，就会调用onChange回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此this就代表传入当前对象（即文本框），然后就可以从this.value上面读到用户的输入值。 总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。 2. 实质JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。 1var obj = &#123; foo: 5 &#125;; 上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。 12345678&#123; foo: &#123; [[value]]: 5 [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125; 注意，foo属性的值保存在属性描述对象的value属性里面。 这样的结构是很清晰的，问题在于属性的值可能是一个函数。 1var obj = &#123; foo: function () &#123;&#125; &#125;; 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。 123456&#123; foo: &#123; [[value]]: 函数的地址 ... &#125;&#125; 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f = function () &#123;&#125;;var obj = &#123; f: f &#125;;// 单独执行f()// obj 环境执行obj.f() JavaScript 允许在函数体内部，引用当前环境的其他变量。 123var f = function () &#123; console.log(x);&#125;; 上面代码中，函数体里面使用了变量x。该变量由运行环境提供。 现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 123var f = function () &#123; console.log(this.x);&#125; 上面代码中，函数体里面的this.x就是指当前运行环境的x。 123456789101112131415var f = function () &#123; console.log(this.x);&#125;var x = 1;var obj = &#123; f: f, x: 2,&#125;;// 单独执行f() // 1// obj 环境执行obj.f() // 2 上面代码中，函数f在全局环境执行，this.x指向全局环境的x；在obj环境执行，this.x指向obj.x。 3. 使用场合this主要有以下几个使用场合。 （1）全局环境 全局环境使用this，它指的就是顶层对象window。 123456this === window // truefunction f() &#123; console.log(this === window);&#125;f() // true 上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。 （2）构造函数 构造函数中的this，指的是实例对象。 123var Obj = function (p) &#123; this.p = p;&#125;; 上面代码定义了一个构造函数Obj。由于this指向实例对象，所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性。 12var o = new Obj(&apos;Hello World!&apos;);o.p // &quot;Hello World!&quot; （3）对象的方法 如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。 但是，这条规则很不容易把握。请看下面的代码。 1234567var obj =&#123; foo: function () &#123; console.log(this); &#125;&#125;;obj.foo() // obj 上面代码中，obj.foo方法执行时，它内部的this指向obj。 但是，下面这几种用法，都会改变this的指向。 123456// 情况一(obj.foo = obj.foo)() // window// 情况二(false || obj.foo)() // window// 情况三(1, obj.foo)() // window 上面代码中，obj.foo就是一个值。这个值真正调用的时候，运行环境已经不是obj了，而是全局环境，所以this不再指向obj。 可以这样理解，JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二。obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境。上面三种情况等同于下面的代码。 123456789101112131415161718// 情况一(obj.foo = function () &#123; console.log(this);&#125;)()// 等同于(function () &#123; console.log(this);&#125;)()// 情况二(false || function () &#123; console.log(this);&#125;)()// 情况三(1, function () &#123; console.log(this);&#125;)() 如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。 12345678910var a = &#123; p: &apos;Hello&apos;, b: &#123; m: function() &#123; console.log(this.p); &#125; &#125;&#125;;a.b.m() // undefined 上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b，因为实际执行的是下面的代码。 123456789101112var b = &#123; m: function() &#123; console.log(this.p); &#125;&#125;;var a = &#123; p: &apos;Hello&apos;, b: b&#125;;(a.b).m() // 等同于 b.m() 如果要达到预期效果，只有写成下面这样。 12345678var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: &apos;Hello&apos; &#125;&#125;; 如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。 1234567891011var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: &apos;Hello&apos; &#125;&#125;;var hello = a.b.m;hello() // undefined 上面代码中，m是多层对象内部的一个方法。为求简便，将其赋值给hello变量，结果调用时，this指向了顶层对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。 12var hello = a.b;hello.m() // Hello 4. 使用注意点4.1 避免多层 this由于this的指向是不确定的，所以切勿在函数中包含多层的this。 123456789101112var o = &#123; f1: function () &#123; console.log(this); var f2 = function () &#123; console.log(this); &#125;(); &#125;&#125;o.f1()// Object// Window 上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。 12345678910var temp = function () &#123; console.log(this);&#125;;var o = &#123; f1: function () &#123; console.log(this); var f2 = temp(); &#125;&#125; 一个解决方法是在第二层改用一个指向外层this的变量。 12345678910111213var o = &#123; f1: function() &#123; console.log(this); var that = this; var f2 = function() &#123; console.log(that); &#125;(); &#125;&#125;o.f1()// Object// Object 上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。 事实上，使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。 JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。 12345678910var counter = &#123; count: 0&#125;;counter.inc = function () &#123; &apos;use strict&apos;; this.count++&#125;;var f = counter.inc;f()// TypeError: Cannot read property &apos;count&apos; of undefined 上面代码中，inc方法通过’use strict’声明采用严格模式，这时内部的this一旦指向顶层对象，就会报错。 4.2 避免数组处理方法中的 this数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。 12345678910111213var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + &apos; &apos; + item); &#125;); &#125;&#125;o.f()// undefined a1// undefined a2 上面代码中，foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。原因跟上一段的多层this是一样的，就是内层的this不指向外部，而指向顶层对象。 解决这个问题的一种方法，就是前面提到的，使用中间变量固定this。 1234567891011121314var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; var that = this; this.p.forEach(function (item) &#123; console.log(that.v+&apos; &apos;+item); &#125;); &#125;&#125;o.f()// hello a1// hello a2 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。 12345678910111213var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + &apos; &apos; + item); &#125;, this); &#125;&#125;o.f()// hello a1// hello a2 4.3 避免回调函数中的 this回调函数中的this往往会改变指向，最好避免使用。 1234567var o = new Object();o.f = function () &#123; console.log(this === o);&#125;// jQuery 的写法$(&apos;#button&apos;).on(&apos;click&apos;, o.f); 上面代码中，点击按钮以后，控制台会显示false。原因是此时this不再指向o对象，而是指向按钮的 DOM 对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。 为了解决这个问题，可以采用下面的一些方法对this进行绑定，也就是使得this固定指向某个对象，减少不确定性。 5. 绑定 this 的方法this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。 5.1 Function.prototype.call()函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 12345678var obj = &#123;&#125;;var f = function () &#123; return this;&#125;;f() === window // truef.call(obj) === obj // true 上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。 call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。 123456789101112var n = 123;var obj = &#123; n: 456 &#125;;function a() &#123; console.log(this.n);&#125;a.call() // 123a.call(null) // 123a.call(undefined) // 123a.call(window) // 123a.call(obj) // 456 上面代码中，a函数中的this关键字，如果指向全局对象，返回结果为123。如果使用call方法将this关键字指向obj对象，返回结果为456。可以看到，如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象。 如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。 123456var f = function () &#123; return this;&#125;;f.call(5)// Number &#123;[[PrimitiveValue]]: 5&#125; 上面代码中，call的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定f内部的this。 call方法还可以接受多个参数。 1func.call(thisValue, arg1, arg2, ...) call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。 12345function add(a, b) &#123; return a + b;&#125;add.call(this, 1, 2) // 3 上面代码中，call方法指定函数add内部的this绑定当前环境（对象），并且参数为1和2，因此函数add运行后得到3。 call方法的一个应用是调用对象的原生方法。 12345678910var obj = &#123;&#125;;obj.hasOwnProperty(&apos;toString&apos;) // false// 覆盖掉继承的 hasOwnProperty 方法obj.hasOwnProperty = function () &#123; return true;&#125;;obj.hasOwnProperty(&apos;toString&apos;) // trueObject.prototype.hasOwnProperty.call(obj, &apos;toString&apos;) // false 上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。 5.2 Function.prototype.apply()apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。 1func.apply(thisValue, [arg1, arg2, ...]) apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。 123456function f(x, y)&#123; console.log(x + y);&#125;f.call(null, 1, 1) // 2f.apply(null, [1, 1]) // 2 上面代码中，f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。 利用这一点，可以做一些有趣的应用。 （1）找出数组最大元素 JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。 12var a = [10, 2, 4, 15, 9];Math.max.apply(null, a) // 15 （2）将数组的空元素变为undefined 通过apply方法，利用Array构造函数将数组的空元素变成undefined。 12Array.apply(null, [&apos;a&apos;, ,&apos;b&apos;])// [ &apos;a&apos;, undefined, &apos;b&apos; ] 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 1234567891011121314var a = [&apos;a&apos;, , &apos;b&apos;];function print(i) &#123; console.log(i);&#125;a.forEach(print)// a// bArray.apply(null, a).forEach(print)// a// undefined// b （3）转换类似数组的对象 另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。 1234Array.prototype.slice.apply(&#123;0: 1, length: 1&#125;) // [1]Array.prototype.slice.apply(&#123;0: 1&#125;) // []Array.prototype.slice.apply(&#123;0: 1, length: 2&#125;) // [1, undefined]Array.prototype.slice.apply(&#123;length: 1&#125;) // [undefined] 上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。 （4）绑定回调函数的对象 前面的按钮点击事件的例子，可以改写如下。 12345678910111213var o = new Object();o.f = function () &#123; console.log(this === o);&#125;var f = function ()&#123; o.f.apply(o); // 或者 o.f.call(o);&#125;;// jQuery 的写法$(&apos;#button&apos;).on(&apos;click&apos;, f); 上面代码中，点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。 5.3 Function.prototype.bind()bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 12345var d = new Date();d.getTime() // 1481869925657var print = d.getTime;print() // Uncaught TypeError: this is not a Date object. 上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。 bind方法可以解决这个问题。 12var print = d.getTime.bind(d);print() // 1481869925657 上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。 bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。 12345678910var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc.bind(counter);func();counter.count // 1 上面代码中，counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。 this绑定到其他对象也是可以的。 12345678910111213var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var obj = &#123; count: 100&#125;;var func = counter.inc.bind(obj);func();obj.count // 101 上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。 bind还可以接受更多的参数，将这些参数绑定原函数的参数。 1234567891011var add = function (x, y) &#123; return x * this.m + y * this.n;&#125;var obj = &#123; m: 2, n: 2&#125;;var newAdd = add.bind(obj, 5);newAdd(5) // 20 上面代码中，bind方法除了绑定this对象，还将add函数的第一个参数x绑定成5，然后返回一个新函数newAdd，这个函数只要再接受一个参数y就能运行了。 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）。 123456function add(x, y) &#123; return x + y;&#125;var plus5 = add.bind(null, 5);plus5(10) // 15 上面代码中，函数add内部并没有this，使用bind方法的主要目的是绑定参数x，以后每次运行新函数plus5，就只需要提供另一个参数y就够了。而且因为add内部没有this，所以bind的第一个参数是null，不过这里如果是其他对象，也没有影响。 bind方法有一些使用注意点。 （1）每一次返回一个新函数 bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。 1element.addEventListener(&apos;click&apos;, o.m.bind(o)); 上面代码中，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。 1element.removeEventListener(&apos;click&apos;, o.m.bind(o)); 正确的方法是写成下面这样： 1234var listener = o.m.bind(o);element.addEventListener(&apos;click&apos;, listener);// ...element.removeEventListener(&apos;click&apos;, listener); （2）结合回调函数使用 回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。解决方法就是使用bind方法，将counter.inc绑定counter。 1234567891011121314var counter = &#123; count: 0, inc: function () &#123; &apos;use strict&apos;; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 上面代码中，callIt方法会调用回调函数。这时如果直接把counter.inc传入，调用时counter.inc内部的this就会指向全局对象。使用bind方法将counter.inc绑定counter以后，就不会有这个问题，this总是指向counter。 还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。 123456789101112var obj = &#123; name: &apos;张三&apos;, times: [1, 2, 3], print: function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;); &#125;&#125;;obj.print()// 没有任何输出 上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。 12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this === window); &#125;);&#125;;obj.print()// true// true// true 解决这个问题，也是通过bind方法绑定this。 12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;.bind(this));&#125;;obj.print()// 张三// 张三// 张三 （3）结合call方法使用 利用bind方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的slice方法为例。 123[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1] 上面的代码中，数组的slice方法从[1, 2, 3]里面，按照指定位置和长度切分出另一个数组。这样做的本质是在[1, 2, 3]上面调用Array.prototype.slice方法，因此可以用call方法表达这个过程，得到同样的结果。 call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写。 12var slice = Function.prototype.call.bind(Array.prototype.slice);slice([1, 2, 3], 0, 1) // [1] 上面代码的含义就是，将Array.prototype.slice变成Function.prototype.call方法所在的对象，调用时就变成了Array.prototype.slice.call。类似的写法还可以用于其他数组方法。 123456789var push = Function.prototype.call.bind(Array.prototype.push);var pop = Function.prototype.call.bind(Array.prototype.pop);var a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 如果再进一步，将Function.prototype.call方法绑定到Function.prototype.bind对象，就意味着bind的调用形式也可以被改写。 1234567function f() &#123; console.log(this.v);&#125;var o = &#123; v: 123 &#125;;var bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123 上面代码的含义就是，将Function.prototype.bind方法绑定在Function.prototype.call上面，所以bind方法就可以直接使用，不需要在函数实例上使用。"},{"title":"js数据类型","date":"2018-09-07T01:25:27.000Z","updated":"2021-02-26T16:49:29.527Z","comments":true,"path":"md/js数据类型.html","permalink":"https://akitsukiwong.github.io/md/js数据类型.html","excerpt":"","text":"JS数据类型 概述 null，undefined 和布尔值 数值 字符串 对象 函数 数组 概述简介JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object） 数组（array） 函数（function） 狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。 typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof 运算符 instanceof 运算符 Object.prototype.toString 方法 instanceof运算符和Object.prototype.toString方法，将在后文介绍。这里介绍typeof运算符。 typeof运算符可以返回一个值的数据类型。 数值、字符串、布尔值分别返回number、string、boolean。 123typeof 123 // &quot;number&quot;typeof &apos;123&apos; // &quot;string&quot;typeof false // &quot;boolean&quot; 函数返回function。 123function f() &#123;&#125;typeof f// &quot;function&quot; undefined返回undefined。 12typeof undefined// &quot;undefined 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// &quot;undefined&quot; 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === &quot;undefined&quot;) &#123; // ...&#125; 对象返回object。 123typeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot; 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释。 12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true null返回object。 1typeof null // &quot;object&quot; null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。 null, undefined 和布尔值1. null 和 undefined1.1 概述null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 123var a = undefined;// 或者var a = null; 上面代码中，变量a分别被赋值为undefined和null，这两种写法的效果几乎等价。 在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log(&apos;undefined is false&apos;);&#125;// undefined is falseif (!null) &#123; console.log(&apos;null is false&apos;);&#125;// null is falseundefined == null// true 从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有null，没有undefined！ 既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。 1995年 JavaScript 诞生时，最初像 Java 一样，只设置了null表示”无”。根据 C 语言的传统，null可以自动转为0。 12Number(null) // 05 + null // 5 上面代码中，null转为数字时，自动变成0。 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，null就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果null自动转为0，很不容易发现错误。 因此，他又设计了一个undefined。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 12Number(undefined) // NaN5 + undefined // NaN 1.2 用法和含义对于null和undefined，大致可以像下面这样理解。 null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 2. 布尔值布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。 下列运算符会返回布尔值： 两元逻辑运算符：&amp;&amp; (And)，|| (Or) 前置逻辑运算符： !(Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 布尔值往往用于程序流程的控制，请看一个例子。 1234if (&apos;&apos;) &#123; console.log(&apos;true&apos;);&#125;// 没有任何输出 上面代码中，if命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出。 注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。 123456789if ([]) &#123; console.log(&apos;true&apos;);&#125;// trueif (&#123;&#125;) &#123; console.log(&apos;true&apos;);&#125;// true 数值1. 概述1.1 整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 123456780.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false 1.2 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位 1(-1)^符号位 * 1.xx...xx * 2^指数部分 上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。 精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。 1234567891011121314Math.pow(2, 53)// 9007199254740992 Math.pow(2, 53) + 1// 9007199254740992Math.pow(2, 53) + 2// 9007199254740994Math.pow(2, 53) + 3// 9007199254740996Math.pow(2, 53) + 4// 9007199254740996 上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。 123456Math.pow(2, 53)// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111// 9007199254740992000 上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。 1.3 数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 1Math.pow(2, -1075) // 0 下面是一个实际的例子 1234567var x = 0.5;for(var i = 0; i &lt; 25; i++) &#123; x = x * x;&#125;x // 0 上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 2. 数值的表示法JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。 数值也可以采用科学计数法表示，下面是几个科学计数法的例子。 1234123e3 // 123000123e-3 // 0.123-3.1E+12.1e-23 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。 （1）小数点前的数字多于21位。 123451234567890123456789012// 1.2345678901234568e+21123456789012345678901// 123456789012345680000 （2）小数点后的零多于5个。 123456// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003 // 3e-7// 否则，就保持原来的字面形式0.000003 // 0.000003 3. 数值的进制使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 1230xff // 2550o377 // 2550b11 // 3 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 1230xzz // 报错0o88 // 报错0b22 // 报错 上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。 通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。 120888 // 8880777 // 511 前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 4.特殊数值JavaScript 提供了几个特殊的数值。 4.1 正零和负零前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连0也不例外。 JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。 123-0 === +0 // true0 === -0 // true0 === +0 // true 几乎所有场合，正零和负零都会被当作正常的0。 1234+0 // 0-0 // 0(-0).toString() // &apos;0&apos;(+0).toString() // &apos;0&apos; 唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。 1(1 / +0) === (1 / -0) // false 上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的（关于Infinity详见下文）。 4.2 NaN4.2.1 含义NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 15 - &apos;x&apos; // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 10 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // &apos;number&apos; 4.2.2 运算规则NaN不等于任何值，包括它本身。 1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。 1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。 1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN 4.3 Infinity4.3.1 含义Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 1234567// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity 上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回Infinity。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。 1234Infinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity 上面代码中，非零正数除以-0，会得到-Infinity，负数除以-0，会得到Infinity。 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。 Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。 12Infinity &gt; 1000 // true-Infinity &lt; -1000 // true Infinity与NaN比较，总是返回false。 12345Infinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false 4.3.2 运算规则Infinity的四则运算，符合无穷的数学计算规则。 12345 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。 1230 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity Infinity加上或乘以Infinity，返回的还是Infinity。 12Infinity + Infinity // InfinityInfinity * Infinity // Infinity Infinity减去或除以Infinity，得到NaN。 12Infinity - Infinity // NaNInfinity / Infinity // NaN Infinity与null计算时，null会转成0，等同于与0的计算。 123null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity Infinity与undefined计算，返回的都是NaN。 12345undefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN 5. 与数值相关的全局方法5.1 parseInt()5.1.1 基本用法parseInt方法用于将字符串转为整数。 1parseInt(&apos;123&apos;) // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(&apos; 81&apos;) // 81 如果parseInt的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23) // 1// 等同于parseInt(&apos;1.23&apos;) // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt(&apos;8a&apos;) // 8parseInt(&apos;12**&apos;) // 12parseInt(&apos;12.34&apos;) // 12parseInt(&apos;15e2&apos;) // 15parseInt(&apos;15px&apos;) // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt(&apos;abc&apos;) // NaNparseInt(&apos;.3&apos;) // NaNparseInt(&apos;&apos;) // NaNparseInt(&apos;+&apos;) // NaNparseInt(&apos;+1&apos;) // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt(&apos;0x10&apos;) // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt(&apos;011&apos;) // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt(&apos;1e+21&apos;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&apos;8e-7&apos;) // 8 5.1.2 进制转换parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 123parseInt(&apos;1000&apos;) // 1000// 等同于parseInt(&apos;1000&apos;, 10) // 1000 下面是转换指定进制的数的例子。 123parseInt(&apos;1000&apos;, 2) // 8parseInt(&apos;1000&apos;, 6) // 216parseInt(&apos;1000&apos;, 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt(&apos;10&apos;, 37) // NaNparseInt(&apos;10&apos;, 1) // NaNparseInt(&apos;10&apos;, 0) // 10parseInt(&apos;10&apos;, null) // 10parseInt(&apos;10&apos;, undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 12parseInt(&apos;1546&apos;, 2) // 1parseInt(&apos;546&apos;, 2) // NaN 上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt(&apos;17&apos;, 36)parseInt(&apos;17&apos;, 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 1234567parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2) 上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 5.2 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 1parseFloat(&apos;3.14&apos;) // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat(&apos;314e-2&apos;) // 3.14parseFloat(&apos;0.0314E+2&apos;) // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat(&apos;3.14more non-digit characters&apos;) // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat(&apos;\\t\\v\\r12.34\\n &apos;) // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat(&apos;FF2&apos;) // NaNparseFloat(&apos;&apos;) // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat(&apos;&apos;) // NaNNumber(&apos;&apos;) // 0parseFloat(&apos;123.45#&apos;) // 123.45Number(&apos;123.45#&apos;) // NaN 5.3 isNaN()isNaN方法可以用来判断一个值是否为NaN。 12isNaN(NaN) // trueisNaN(123) // false 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。 123isNaN(&apos;Hello&apos;) // true// 相当于isNaN(Number(&apos;Hello&apos;)) // true 出于同样的原因，对于对象和数组，isNaN也返回true。 1234567isNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // trueisNaN([&apos;xzy&apos;]) // true// 等同于isNaN(Number([&apos;xzy&apos;])) // true 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 123isNaN([]) // falseisNaN([123]) // falseisNaN([&apos;123&apos;]) // false 上面代码之所以返回false，原因是这些数组能被Number函数转成数值。 因此，使用isNaN之前，最好判断一下数据类型。 123function myIsNaN(value) &#123; return typeof value === &apos;number&apos; &amp;&amp; isNaN(value);&#125; 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。 123function myIsNaN(value) &#123; return value !== value;&#125; 5.4 isFinite()isFinite方法返回一个布尔值，表示某个值是否为正常的数值。 123456isFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。 字符串1. 概述1.1 定义字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。 12&apos;abc&apos;&quot;abc&quot; 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12&apos;key = &quot;value&quot;&apos;&quot;It&apos;s a long journey&quot; 上面两个都是合法的字符串。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 12345&apos;Did she say \\&apos;Hello\\&apos;?&apos;// &quot;Did she say &apos;Hello&apos;?&quot;&quot;Did she say \\&quot;Hello\\&quot;?&quot;// &quot;Did she say &quot;Hello&quot;?&quot; 由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。 字符串默认只能写在一行内，分成多行将会报错。 1234&apos;abc&apos;// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript 就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = &apos;Long \\long \\long \\string&apos;;longString// &quot;Long long long string&quot; 上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = &apos;Long &apos; + &apos;long &apos; + &apos;long &apos; + &apos;string&apos;; 如果想输出多行字符串，有一种利用多行注释的变通方法。 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split(&apos;\\n&apos;).slice(1, -1).join(&apos;\\n&apos;)// &quot;line 1// line 2// line 3&quot; 上面的例子中，输出的字符串就是多行。 1.2 转义反斜杠（\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些。 \\0 ：null（\\u0000） \\b ：后退键（\\u0008） \\f ：换页符（\\u000C） \\n ：换行符（\\u000A） \\r ：回车键（\\u000D） \\t ：制表符（\\u0009） \\v ：垂直制表符（\\u000B） \\&#39; ：单引号（\\u0027） \\&quot; ：双引号（\\u0022） \\\\ ：反斜杠（\\u005C） 上面这些字符前面加上反斜杠，都表示特殊含义。 123console.log(&apos;1\\n2&apos;)// 1// 2 上面代码中，\\n表示换行，输出的时候就分成了两行。 反斜杠还有三种特殊用法。 （1）\\HHH 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\\251表示版权符号。显然，这种方法只能输出256种字符。 （2）\\xHH \\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\\xA9表示版权符号。这种方法也只能输出256种字符。 （3）\\uXXXX \\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\\u00A9表示版权符号。 下面是这三种字符特殊写法的例子。 1234567&apos;\\251&apos; // &quot;©&quot;&apos;\\xA9&apos; // &quot;©&quot;&apos;\\u00A9&apos; // &quot;©&quot;&apos;\\172&apos; === &apos;z&apos; // true&apos;\\x7A&apos; === &apos;z&apos; // true&apos;\\u007A&apos; === &apos;z&apos; // true 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。 12&apos;\\a&apos;// &quot;a&quot; 上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。 如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。 12&quot;Prev \\\\ Next&quot;// &quot;Prev \\ Next&quot; 1.3 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = &apos;hello&apos;;s[0] // &quot;h&quot;s[1] // &quot;e&quot;s[4] // &quot;o&quot;// 直接对字符串使用方括号运算符&apos;hello&apos;[1] // &quot;e&quot; 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123&apos;abc&apos;[3] // undefined&apos;abc&apos;[-1] // undefined&apos;abc&apos;[&apos;x&apos;] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 12345678910var s = &apos;hello&apos;;delete s[0];s // &quot;hello&quot;s[1] = &apos;a&apos;;s // &quot;hello&quot;s[5] = &apos;!&apos;;s // &quot;hello&quot; 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 1.4 length 属性length属性返回字符串的长度，该属性也是无法改变的。 12345678var s = &apos;hello&apos;;s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 2. 字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。 12var s = &apos;\\u00A9&apos;;s // &quot;©&quot; 解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。 12var f\\u006F\\u006F = &apos;abc&apos;;foo // &quot;abc&quot; 上面代码中，第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。 我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。 但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。 JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。 1&apos;𝌆&apos;.length // 2 上面代码中，JavaScript 认为𝌆的长度为2，而不是1。 总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 3. Base64 转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。 所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = &apos;Hello World!&apos;;btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;atob(&apos;SGVsbG8gV29ybGQh&apos;) // &quot;Hello World!&quot; 注意，这两个方法不适合非 ASCII 码的字符，会报错。 1btoa(&apos;你好&apos;) // 报错 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode(&apos;你好&apos;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;b64Decode(&apos;JUU0JUJEJUEwJUU1JUE1JUJE&apos;) // &quot;你好&quot; 对象1 概述1.1 生成方法对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。 什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 1234var obj = &#123; foo: &apos;Hello&apos;, bar: &apos;World&apos;&#125;; 上面代码中，大括号就定义了一个对象，它被赋值给变量obj，所以变量obj就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是foo: &#39;Hello&#39;，其中foo是“键名”（成员的名称），字符串Hello是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是bar: &#39;World&#39;，bar是键名，World是键值。两个键值对之间用逗号分隔。 1.2 键名对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。 1234var obj = &#123; &apos;foo&apos;: &apos;Hello&apos;, &apos;bar&apos;: &apos;World&apos;&#125;; 如果键名是数值，会被自动转为字符串。 1234567891011121314151617181920var obj = &#123; 1: &apos;a&apos;, 3.2: &apos;b&apos;, 1e2: true, 1e-2: true, .234: true, 0xFF: true&#125;;obj// Object &#123;// 1: &quot;a&quot;,// 3.2: &quot;b&quot;,// 100: true,// 0.01: true,// 0.234: true,// 255: true// &#125;obj[&apos;100&apos;] // true 上面代码中，对象obj的所有键名虽然看上去像数值，实际上都被自动转成了字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 1234567891011// 报错var obj = &#123; 1p: &apos;Hello World&apos;&#125;;// 不报错var obj = &#123; &apos;1p&apos;: &apos;Hello World&apos;, &apos;h w&apos;: &apos;Hello World&apos;, &apos;p+q&apos;: &apos;Hello World&apos;&#125;; 上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。 1234567var obj = &#123; p: function (x) &#123; return 2 * x; &#125;&#125;;obj.p(1) // 2 上面代码中，对象obj的属性p，就指向一个函数。 如果属性的值还是一个对象，就形成了链式引用。 12345var o1 = &#123;&#125;;var o2 = &#123; bar: &apos;hello&apos; &#125;;o1.foo = o2;o1.foo.bar // &quot;hello&quot; 上面代码中，对象o1的属性foo指向对象o2，就可以链式引用o2的属性。 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。 1234var obj = &#123; p: 123, m: function () &#123; ... &#125;,&#125; 上面的代码中，m属性后面的那个逗号，有没有都可以。 属性可以动态创建，不必在对象声明时就指定。 123var obj = &#123;&#125;;obj.foo = 123;obj.foo // 123 上面代码中，直接对obj对象的foo属性赋值，结果就在运行时创建了foo属性。 1.3 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 12345678var o1 = &#123;&#125;;var o2 = o1;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2 上面代码中，o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 12345var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125; 上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。 但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。 12345var x = 1;var y = x;x = 2;y // 1 上面的代码中，当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。 1.4 表达式还是语句?对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？ 1&#123; foo: 123 &#125; JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。 为了避免这种歧义，V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。 1(&#123; foo: 123&#125;) 这种差异在eval语句（作用是对字符串求值）中反映得最明显。 12eval(&apos;&#123;foo: 123&#125;&apos;) // 123eval(&apos;(&#123;foo: 123&#125;)&apos;) // &#123;foo: 123&#125; 上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象。 2. 属性的操作2.1 属性的读取读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。 123456var obj = &#123; p: &apos;Hello World&apos;&#125;;obj.p // &quot;Hello World&quot;obj[&apos;p&apos;] // &quot;Hello World&quot; 上面代码分别采用点运算符和方括号运算符，读取属性p。 请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。 123456789var foo = &apos;bar&apos;;var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo] // 2 上面代码中，引用对象obj的foo属性时，如果使用点运算符，foo就是字符串；如果使用方括号运算符，但是不使用引号，那么foo就是一个变量，指向字符串bar。 方括号运算符内部还可以使用表达式。 12obj[&apos;hello&apos; + &apos; world&apos;]obj[3 + 3] 数字键可以不加引号，因为会自动转成字符串。 123456var obj = &#123; 0.7: &apos;Hello World&apos;&#125;;obj[&apos;0.7&apos;] // &quot;Hello World&quot;obj[0.7] // &quot;Hello World&quot; 上面代码中，对象obj的数字键0.7，加不加引号都可以，因为会被自动转为字符串。 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。 123456var obj = &#123; 123: &apos;hello world&apos;&#125;;obj.123 // 报错obj[123] // &quot;hello world&quot; 上面代码的第一个表达式，对数值键名123使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。 2.2 属性的赋值点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。 1234var obj = &#123;&#125;;obj.foo = &apos;Hello&apos;;obj[&apos;bar&apos;] = &apos;World&apos;; 上面代码中，分别使用点运算符和方括号运算符，对属性赋值。 JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。 123456var obj = &#123; p: 1 &#125;;// 等价于var obj = &#123;&#125;;obj.p = 1; 2.3 属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// [&apos;key1&apos;, &apos;key2&apos;] 2.4 属性的删除：delete 命令delete命令用于删除对象的属性，删除成功后返回true。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 1234567var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 123, configurable: false&#125;);obj.p // 123delete obj.p // false 上面代码之中，对象obj的p属性是不能删除的，所以delete命令返回false。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 2.5 属性是否存在：in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。 123var obj = &#123; p: 1 &#125;;&apos;p&apos; in obj // true&apos;toString&apos; in obj // true in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。 1234var obj = &#123;&#125;;if (&apos;toString&apos; in obj) &#123; console.log(obj.hasOwnProperty(&apos;toString&apos;)) // false&#125; 2.6 属性的遍历：for…in 循环for...in循环用来遍历一个对象的全部属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log(&apos;键名：&apos;, i); console.log(&apos;键值：&apos;, obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: &apos;老张&apos; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 3. with 语句with语句的格式如下： 123with (对象) &#123; 语句;&#125; 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 1234567891011121314151617181920212223// 例一var obj = &#123; p1: 1, p2: 2,&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123; console.log(href); console.log(title); console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 上面代码中，对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1。正确的写法应该是，先定义对象obj的属性p1，然后在with区块内操作它。 这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。 123with (obj) &#123; console.log(x);&#125; 单纯从上面的代码块，根本无法判断x到底是全局变量，还是对象obj的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。 1234567with(obj1.obj2.obj3) &#123; console.log(p1 + p2);&#125;// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2); 函数函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。 1. 概述1.1 函数的声明JavaScript 有三种声明函数的方法 （1）function 命令 function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。 123function print(s) &#123; console.log(s);&#125; 上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。 （2）函数表达式 除了用function命令声明函数，还可以采用变量赋值的写法。 123var print = function(s) &#123; console.log(s);&#125;; 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 123456789var print = function x()&#123; console.log(typeof x);&#125;;x// ReferenceError: x is not definedprint()// function 上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。 1var f = function f() &#123;&#125;; 需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。 （3）Function 构造函数 第三种声明函数的方式是Function构造函数。 12345678910var add = new Function( &apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos;);// 等同于function add(x, y) &#123; return x + y;&#125; 上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。 你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。 12345678var foo = new Function( &apos;return &quot;hello world&quot;;&apos;);// 等同于function foo() &#123; return &apos;hello world&apos;;&#125; Function构造函数可以不使用new命令，返回结果完全一样。 总的来说，这种声明函数的方式非常不直观，几乎无人使用。 1.2 函数的重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 123456789function f() &#123; console.log(1);&#125;f() // 2function f() &#123; console.log(2);&#125;f() // 2 上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升，前一次声明在任何时候都是无效的，这一点要特别注意。 1.3 圆括号运算符，return 语句和递归调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。 12345function add(x, y) &#123; return x + y;&#125;add(1, 1) // 2 上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。 函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。 函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。 1234567function fib(num) &#123; if (num === 0) return 0; if (num === 1) return 1; return fib(num - 2) + fib(num - 1);&#125;fib(6) // 8 上面代码中，fib函数内部又调用了fib，计算得到斐波那契数列的第6个元素是8。 1.4 第一等公民JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。 由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。 12345678910111213function add(x, y) &#123; return x + y;&#125;// 将函数赋值给一个变量var operator = add;// 将函数作为参数和返回值function a(op)&#123; return op;&#125;a(add)(1, 1)// 2 1.5 函数名的提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。 123f();function f() &#123;&#125; 表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。 123f();var f = function ()&#123;&#125;;// TypeError: undefined is not a function 上面的代码等同于下面的形式。 123var f;f();f = function () &#123;&#125;; 上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。因此，如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 123456789var f = function () &#123; console.log(&apos;1&apos;);&#125;function f() &#123; console.log(&apos;2&apos;);&#125;f() // 1 2. 函数的属性和方法2.1 name 属性函数的name属性返回函数的名字。 12function f1() &#123;&#125;f1.name // &quot;f1&quot; 如果是通过变量赋值定义的函数，那么name属性返回变量名。 12var f2 = function () &#123;&#125;;f2.name // &quot;f2&quot; 但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。 12var f3 = function myName() &#123;&#125;;f3.name // &apos;myName&apos; 上面代码中，f3.name返回函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。 name属性的一个用处，就是获取参数函数的名字。 1234567var myFunc = function () &#123;&#125;;function test(f) &#123; console.log(f.name);&#125;test(myFunc) // myFunc 上面代码中，函数test内部通过name属性，就可以知道传入的参数是什么函数。 2.2 length 属性函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 12function f(a, b) &#123;&#125;f.length // 2 上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。 length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。 2.3 toString()函数的toString方法返回一个字符串，内容是函数的源码。 123456789101112function f() &#123; a(); b(); c();&#125;f.toString()// function f() &#123;// a();// b();// c();// &#125; 函数内部的注释也可以返回。 12345678910function f() &#123;/* 这是一个 多行注释*/&#125;f.toString()// &quot;function f()&#123;/*// 这是一个// 多行注释// */&#125;&quot; 利用这一点，可以变相实现多行字符串。 12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split(&apos;\\n&apos;); return arr.slice(1, arr.length - 1).join(&apos;\\n&apos;);&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// &quot; 这是一个// 多行注释&quot; 3. 函数作用域3.1 定义作用域（scope）指的是变量存在的范围。在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。 函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。 12345678var v = 1;function f() &#123; console.log(v);&#125;f()// 1 上面的代码表明，函数f内部可以读取全局变量v。 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。 12345function f()&#123; var v = 1;&#125;v // ReferenceError: v is not defined 上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。 函数内部定义的变量，会在该作用域内覆盖同名全局变量。 123456789var v = 1;function f()&#123; var v = 2; console.log(v);&#125;f() // 2v // 1 上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v。 注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。 1234if (true) &#123; var x = 5;&#125;console.log(x); // 5 上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。 3.2 函数内部的变量提升与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 12345678910111213function foo(x) &#123; if (x &gt; 100) &#123; var tmp = x - 100; &#125;&#125;// 等同于function foo(x) &#123; var tmp; if (x &gt; 100) &#123; tmp = x - 100; &#125;;&#125; 3.3 函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。 很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量。 1234567891011var x = function () &#123; console.log(a);&#125;;function y(f) &#123; var a = 2; f();&#125;y(x)// ReferenceError: a is not defined 上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。 同样的，函数体内部声明的函数，作用域绑定函数体内部。 1234567891011function foo() &#123; var x = 1; function bar() &#123; console.log(x); &#125; return bar;&#125;var x = 2;var f = foo();f() // 1 上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了“闭包”现象。 4. 参数4.1 概述函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。 123456function square(x) &#123; return x * x;&#125;square(2) // 4square(3) // 9 上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。 4.2 参数的省略函数参数不是必需的，Javascript 允许省略参数。 123456789function f(a, b) &#123; return a;&#125;f(1, 2, 3) // 1f(1) // 1f() // undefinedf.length // 2 上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。 123456function f(a, b) &#123; return a;&#125;f( , 1) // SyntaxError: Unexpected token ,(…)f(undefined, 1) // undefined 上面代码中，如果省略第一个参数，就会报错。 4.3 传递方式函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。 12345678var p = 2;function f(p) &#123; p = 3;&#125;f(p);p // 2 上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 12345678var obj = &#123; p: 1 &#125;;function f(o) &#123; o.p = 2;&#125;f(obj);obj.p // 2 上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。 12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] 上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。 4.4 同名参数如果有同名的参数，则取最后出现的那个值。 12345function f(a, a) &#123; console.log(a);&#125;f(1, 2) // 2 上面代码中，函数f有两个参数，且参数名都是a。取值的时候，以后面的a为准，即使后面的a没有值或被省略，也是以其为准。 12345function f(a, a) &#123; console.log(a);&#125;f(1) // undefined 调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。 12345function f(a, a) &#123; console.log(arguments[0]);&#125;f(1) // 1 4.5 arguments 对象（1）定义 由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 12345678910var f = function (one) &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]);&#125;f(1, 2, 3)// 1// 2// 3 正常模式下，arguments对象可以在运行时修改。 1234567var f = function(a, b) &#123; arguments[0] = 3; arguments[1] = 2; return a + b;&#125;f(1, 1) // 5 上面代码中，函数f调用时传入的参数，在函数内部被修改成3和2。 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。 12345678var f = function(a, b) &#123; &apos;use strict&apos;; // 开启严格模式 arguments[0] = 3; // 无效 arguments[1] = 2; // 无效 return a + b;&#125;f(1, 1) // 2 上面代码中，函数体内是严格模式，这时修改arguments对象就是无效的。 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。 1234567function f() &#123; return arguments.length;&#125;f(1, 2, 3) // 3f(1) // 1f() // 0 （2）与数组的关系 需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; （3）callee 属性 arguments对象带有一个callee属性，返回它所对应的原函数。 12345var f = function () &#123; console.log(arguments.callee === f);&#125;f() // true 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 5. 函数的其他知识点5.1 闭包闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。 123456var n = 999;function f1() &#123; console.log(n);&#125;f1() // 999 上面代码中，函数f1可以读取全局变量n。 但是，函数外部无法读取函数内部声明的变量。 123456function f1() &#123; var n = 999;&#125;console.log(n)// Uncaught ReferenceError: n is not defined( 上面代码中，函数f1内部声明的变量n，函数外是无法读取的。 如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 123456function f1() &#123; var n = 999; function f2() &#123; console.log(n); // 999 &#125;&#125; 上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 12345678910function f1() &#123; var n = 999; function f2() &#123; console.log(n); &#125; return f2;&#125;var result = f1();result(); // 999 上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。 闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。 1234567891011function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7 上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。 为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 闭包的另一个用处，是封装对象的私有属性和私有方法。 12345678910111213141516171819function Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person(&apos;张三&apos;);p1.setAge(25);p1.getAge() // 25 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 5.2 立即调用的函数表达式（IIFE）在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。 有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。 12function()&#123; /* code */ &#125;();// SyntaxError: Unexpected token ( 产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。 12345// 语句function f() &#123;&#125;// 表达式var f = function f() &#123;&#125; 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。 123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。 注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。 123// 报错(function()&#123; /* code */ &#125;())(function()&#123; /* code */ &#125;()) 上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。 推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。 123var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;(); 甚至像下面这样写，也是可以的。 1234!function () &#123; /* code */ &#125;();~function () &#123; /* code */ &#125;();-function () &#123; /* code */ &#125;();+function () &#123; /* code */ &#125;(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 1234567891011// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () &#123; var tmp = newData; processData(tmp); storeData(tmp);&#125;()); 上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。 6. eval 命令6.1 基本用法eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。 12eval(&apos;var a = 1;&apos;);a // 1 上面代码将字符串当作语句运行，生成了变量a。 如果参数字符串无法当作语句运行，那么就会报错。 1eval(&apos;3x&apos;) // Uncaught SyntaxError: Invalid or unexpected token 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用。举例来说，下面的代码将会报错。 1eval(&apos;return;&apos;); // Uncaught SyntaxError: Illegal return statement 上面代码会报错，因为return不能单独使用，必须在函数中使用。 如果eval的参数不是字符串，那么会原样返回。 1eval(123) // 123 eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。 1234var a = 1;eval(&apos;a = 2&apos;);a // 2 上面代码中，eval命令修改了外部变量a的值。由于这个原因，eval有安全风险。 为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。 12345(function f() &#123; &apos;use strict&apos;; eval(&apos;var foo = 123&apos;); console.log(foo); // ReferenceError: foo is not defined&#125;)() 上面代码中，函数f内部是严格模式，这时eval内部声明的foo变量，就不会影响到外部。 不过，即使在严格模式下，eval依然可以读写当前作用域的变量。 123456(function f() &#123; &apos;use strict&apos;; var foo = 1; eval(&apos;foo = 2&apos;); console.log(foo); // 2&#125;)() 上面代码中，严格模式下，eval内部还是改写了外部变量，可见安全风险依然存在。 总之，eval的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，eval最常见的场合是解析JSON数据的字符串，不过正确的做法应该是使用原生的JSON.parse方法。 6.2 eval 的别名调用前面说过eval不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是eval。 123var m = eval;m(&apos;var x = 1&apos;);x // 1 上面代码中，变量m是eval的别名。静态代码分析阶段，引擎分辨不出m(&#39;var x = 1&#39;)执行的是eval命令。 为了保证eval的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。 123456789var a = 1;function f() &#123; var a = 2; var e = eval; e(&apos;console.log(a)&apos;);&#125;f() // 1 上面代码中，eval是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的a为全局变量。这样的话，引擎就能确认e()不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。 eval的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨eval()这一种形式是直接调用。 1234eval.call(null, &apos;...&apos;)window.eval(&apos;...&apos;)(1, eval)(&apos;...&apos;)(eval, eval)(&apos;...&apos;) 上面这些形式都是eval的别名调用，作用域都是全局作用域。 数组1. 定义数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。 1var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; 上面代码中的a、b、c就构成一个数组，两端的方括号是数组的标志。a是0号位置，b是1号位置，c是2号位置。 除了在定义时赋值，数组也可以先定义后赋值。 12345var arr = [];arr[0] = &apos;a&apos;;arr[1] = &apos;b&apos;;arr[2] = &apos;c&apos;; 任何类型的数据，都可以放入数组。 123456789var arr = [ &#123;a: 1&#125;, [1, 2, 3], function() &#123;return true;&#125;];arr[0] // Object &#123;a: 1&#125;arr[1] // [1, 2, 3]arr[2] // function ()&#123;return true;&#125; 上面数组arr的3个成员依次是对象、数组、函数。 如果数组的元素还是数组，就形成了多维数组。 123var a = [[1, 2], [3, 4]];a[0][1] // 2a[1][1] // 4 2. 数组的本质本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 1typeof [1, 2, 3] // &quot;object&quot; 上面代码表明，typeof运算符认为数组的类型就是对象。 数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];Object.keys(arr)// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] 上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。 由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr[&apos;0&apos;] // &apos;a&apos;arr[0] // &apos;a&apos; 上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。 注意，这点在赋值时也成立。如果一个值总是先转成字符串，再进行赋值。 1234var a = [];a[1.00] = 6;a[1] // 6 上面代码中，由于1.00转成字符串是1，所以通过数字键1可以读取值。 上一章说过，对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]）。但是，对于数值的键名，不能使用点结构。 12var arr = [1, 2, 3];arr.0 // SyntaxError 上面代码中，arr.0的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。 3. length 属性数组的length属性，返回数组的成员数量。 1[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].length // 3 JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（2^32 - 1）个，也就是说length属性的最大值就是 4294967295。 只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。 1234567891011var arr = [&apos;a&apos;, &apos;b&apos;];arr.length // 2arr[2] = &apos;c&apos;;arr.length // 3arr[9] = &apos;d&apos;;arr.length // 10arr[1000] = &apos;e&apos;;arr.length // 1001 上面代码表示，数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。 length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。 12345var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];arr.length // 3arr.length = 2;arr // [&quot;a&quot;, &quot;b&quot;] 上面代码表示，当数组的length属性设为2（即最大的整数键只能是1）那么整数键2（值为c）就已经不在数组中了，被自动删除了。 清空数组的一个有效方法，就是将length属性设为0。 1234var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];arr.length = 0;arr // [] 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。 1234var a = [&apos;a&apos;];a.length = 3;a[1] // undefined 上面代码表示，当length属性设为大于数组个数时，读取新增的位置都会返回undefined。 如果人为设置length为不合法的值，JavaScript 会报错。 1234567891011// 设置负值[].length = -1// RangeError: Invalid array length// 数组元素个数大于等于2的32次方[].length = Math.pow(2, 32)// RangeError: Invalid array length// 设置字符串[].length = &apos;abc&apos;// RangeError: Invalid array length 值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。 1234567var a = [];a[&apos;p&apos;] = &apos;abc&apos;;a.length // 0a[2.1] = &apos;abc&apos;;a.length // 0 上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。 1234567var arr = [];arr[-1] = &apos;a&apos;;arr[Math.pow(2, 32)] = &apos;b&apos;;arr.length // 0arr[-1] // &quot;a&quot;arr[4294967296] // &quot;b&quot; 上面代码中，我们为数组arr添加了两个不合法的数字键，结果length属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。 4. in 运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。 1234var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];2 in arr // true&apos;2&apos; in arr // true4 in arr // false 上面代码表明，数组存在键名为2的键。由于键名都是字符串，所以数值2会自动转成字符串。 注意，如果数组的某个位置是空位，in运算符返回false。 12345var arr = [];arr[100] = &apos;a&apos;;100 in arr // true1 in arr // false 上面代码中，数组arr只有一个成员arr[100]，其他位置的键名都会返回false。 5. for…in 循环和数组的遍历for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。 12345678var a = [1, 2, 3];for (var i in a) &#123; console.log(a[i]);&#125;// 1// 2// 3 但是，for...in不仅会遍历数组所有的数字键，还会遍历非数字键。 12345678910var a = [1, 2, 3];a.foo = true;for (var key in a) &#123; console.log(key);&#125;// 0// 1// 2// foo 上面代码在遍历数组时，也遍历到了非整数键foo。所以，不推荐使用for...in遍历数组。 数组的遍历可以考虑使用for循环或while循环。 123456789101112131415161718var a = [1, 2, 3];// for循环for(var i = 0; i &lt; a.length; i++) &#123; console.log(a[i]);&#125;// while循环var i = 0;while (i &lt; a.length) &#123; console.log(a[i]); i++;&#125;var l = a.length;while (l--) &#123; console.log(a[l]);&#125; 上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。 1234567var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];colors.forEach(function (color) &#123; console.log(color);&#125;);// red// green// blue 6. 数组的空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。 12var a = [1, , 1];a.length // 3 上面代码表明，数组的空位不影响length属性。 需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。 1234var a = [1, 2, 3,];a.length // 3a // [1, 2, 3] 上面代码中，数组最后一个成员后面有一个逗号，这不影响length属性的值，与没有这个逗号时效果一样。 数组的空位是可以读取的，返回undefined。 12var a = [, , ,];a[1] // undefined 使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。 12345var a = [1, 2, 3];delete a[1];a[1] // undefineda.length // 3 上面代码用delete命令删除了数组的第二个元素，这个位置就形成了空位，但是对length属性没有影响。也就是说，length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。 1234567891011121314var a = [, , ,];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;)// 不产生任何输出for (var i in a) &#123; console.log(i);&#125;// 不产生任何输出Object.keys(a)// [] 如果某个位置是undefined，遍历的时候就不会被跳过。 123456789101112131415161718var a = [undefined, undefined, undefined];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;);// 0. undefined// 1. undefined// 2. undefinedfor (var i in a) &#123; console.log(i);&#125;// 0// 1// 2Object.keys(a)// [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] 这就是说，空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。 7. 类似数组的对象如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。 1234567891011var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3&#125;;obj[0] // &apos;a&apos;obj[1] // &apos;b&apos;obj.length // 3obj.push(&apos;d&apos;) // TypeError: obj.push is not a function 上面代码中，对象obj就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。 “类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。 12345var obj = &#123; length: 0&#125;;obj[3] = &apos;d&apos;;obj.length // 0 上面代码为对象obj添加了一个数字键，但是length属性没变。这就说明了obj不是数组。 典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。 1234567891011121314151617// arguments对象function args() &#123; return arguments &#125;var arrayLike = args(&apos;a&apos;, &apos;b&apos;);arrayLike[0] // &apos;a&apos;arrayLike.length // 2arrayLike instanceof Array // false// DOM元素集var elts = document.getElementsByTagName(&apos;h3&apos;);elts.length // 3elts instanceof Array // false// 字符串&apos;abc&apos;[1] // &apos;b&apos;&apos;abc&apos;.length // 3&apos;abc&apos; instanceof Array // false 上面代码包含三个例子，它们都不是数组（instanceof运算符返回false），但是看上去都非常像数组。 数组的slice方法可以将“类似数组的对象”变成真正的数组。 1var arr = Array.prototype.slice.call(arrayLike); 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。 12345function print(value, index) &#123; console.log(index + &apos; : &apos; + value);&#125;Array.prototype.forEach.call(arrayLike, print); 上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。 下面的例子就是通过这种方法，在arguments对象上面调用forEach方法。 12345678910111213// forEach 方法function logArgs() &#123; Array.prototype.forEach.call(arguments, function (elem, i) &#123; console.log(i + &apos;. &apos; + elem); &#125;);&#125;// 等同于 for 循环function logArgs() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(i + &apos;. &apos; + arguments[i]); &#125;&#125; 字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。 123456Array.prototype.forEach.call(&apos;abc&apos;, function (chr) &#123; console.log(chr);&#125;);// a// b// c 注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。 1234567var arr = Array.prototype.slice.call(&apos;abc&apos;);arr.forEach(function (chr) &#123; console.log(chr);&#125;);// a// b// c"}],"posts":[{"title":"canvas","slug":"canvas","date":"2021-02-05T01:53:00.000Z","updated":"2021-02-26T16:49:29.479Z","comments":true,"path":"2021/02/05/canvas/","link":"","permalink":"https://akitsukiwong.github.io/2021/02/05/canvas/","excerpt":"","text":"什么是canvas？ HTML5 元素 是一个矩形区域画布，可以控制其每一像素，用于在网页上绘制图形 canvas 本身并没有绘图能力，通常是通过js绘制 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法 canvas 的历史和优势… 简单示例1&lt;canvas width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; width: 宽度 height: 高度 demo canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成 12345678&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;myCanvas&quot;); //根据 id 找到 canvas 元素 var cxt = canvas.getContext(&quot;2d&quot;); //getContext() 方法返回一个用于在画布上绘图的环境 cxt.fillStyle = &quot;#FF0000&quot;; //填充颜色 cxt.fillRect(0, 0, 100, 50); //规定了形状，位置，尺寸&lt;/script&gt; demo 基本形状线 圆 矩形 被填充的矩形 画一条正弦曲线 飘动的小红旗","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://akitsukiwong.github.io/tags/canvas/"}]},{"title":"PMP考试","slug":"PMP考试","date":"2020-11-23T08:01:00.000Z","updated":"2021-02-26T16:49:29.478Z","comments":true,"path":"2020/11/23/PMP考试/","link":"","permalink":"https://akitsukiwong.github.io/2020/11/23/PMP考试/","excerpt":"","text":"项目：独特性、临时性 收集需求 名义小组：通过匿名投票来排列主意的优先顺序 德尔菲：专家通过多轮匿名投票，打成一致意见 头脑风暴：参与人不限，公开交换意见 焦点小组：干系人与领域专家，公开交换意见 引导式讨论：","categories":[],"tags":[]},{"title":"Grid布局","slug":"Grid布局","date":"2020-09-04T07:25:47.000Z","updated":"2021-02-26T16:49:29.477Z","comments":true,"path":"2020/09/04/Grid布局/","link":"","permalink":"https://akitsukiwong.github.io/2020/09/04/Grid布局/","excerpt":"","text":"==参考资料== MDN-网格布局 阮一峰的网络日志-CSS Grid 网格布局教程 Grid布局兼容性 CSS终极之战：Grid vs Flexbox 简介网格布局，相交的水平线和垂直线，定义网格都列和行 传统布局 table float position flex 优势 固定或弹性的轨道尺寸 定位项目 创建额外的轨道来保存内容 对齐控制 控制重叠内容 grid vs flexflex一维布局 grid二维布局 配合使用","categories":[],"tags":[]},{"title":"高阶组件 与 render props","slug":"Untitled","date":"2020-09-04T07:25:14.000Z","updated":"2021-02-26T16:49:29.479Z","comments":true,"path":"2020/09/04/Untitled/","link":"","permalink":"https://akitsukiwong.github.io/2020/09/04/Untitled/","excerpt":"","text":"==参考资料== 高阶组件 Render Props React.js 小书 前言 在编码中如果要重复实现相同功能，如何处理？ 在react中有两种方法 高阶组件 和 render props 高阶组件（Higher-Order Components，HOC）先来介绍一下高阶组件 有时候人们很喜欢造一些名字很吓人的名词，让人一听这个名词就觉得自己不可能学会，从而让人望而却步。但是其实这些名词背后所代表的东西其实很简单不能说高阶组件就是这么一个东西。但是它是一个概念上很简单，但却非常常用、实用的东西，被大量 React.js 相关的第三方库频繁地使用。在前端的业务开发当中，你不掌握高阶组件其实也可以完成项目的开发，但是如果你能够灵活地使用高阶组件，可以让你代码更加优雅，复用性、灵活性更强。它是一个加分项，而且加的分还不少。 —– React.js 小书 高阶组件 其实不是什么高深莫测的东西，它类似于 高阶函数，就是一个纯函数，它会接受一个组件作为参数，然后返回一个新的组件。 那我们先来回顾一下 高阶函数 的定义 高阶函数(Higher-Order Function)在介绍 高阶函数 的定义之前，先简单的举几个例子 js中内置的很多方法其实都是高阶函数，如 setTimeout() 、setInterval()、some()、every()、filter()、map()、forEach()等 比如 setTimeout 用法：123setTimeout(() =&gt; &#123; alert(&quot;Hello&quot;); &#125;, 3000); 观察 setTimeout 中接受的参数 其中第一个参数是一个函数，是你想要在到期时间(delay毫秒)之后执行的函数。第二个参数是延迟的毫秒数。 像这样把函数作为参数的函数，其实就是一种 高阶函数。 这样我们再来看高阶函数的定义就很容易被理解了 高阶函数的定义 函数可以作为参数被传递 函数可以作为返回值输出 高阶组件（Higher-Order Components）联系高阶函数，高阶组件就很容易被理解了，它其实就是一个组件为参数的函数 先放个 官网文档 总结下： 高阶组件其实并不是一个组件而是一个函数 高阶组件就是接受一个组件作为参数并返回一个新组件的函数 高阶组件举例举个例子，我们在写代码中经常用到的高阶组件 react-router 中的 withRouter 就是一个高阶组件 看看withRouter官网用法 12345678910111213141516171819202122import React from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;import &#123; withRouter &#125; from &quot;react-router&quot;;// A simple component that shows the pathname of the current locationclass ShowTheLocation extends React.Component &#123; static propTypes = &#123; match: PropTypes.object.isRequired, location: PropTypes.object.isRequired, history: PropTypes.object.isRequired &#125;; render() &#123; const &#123; match, location, history &#125; = this.props; return &lt;div&gt;You are now at &#123;location.pathname&#125;&lt;/div&gt;; &#125;&#125;// Create a new component that is &quot;connected&quot; (to borrow redux// terminology) to the router.const ShowTheLocationWithRouter = withRouter(ShowTheLocation); 注意最后一行 withRouter() 是个函数，函数的参数是一个组件，这样的函数就叫做高阶组件 高阶函数的使用 直接包裹 higherOrderComponent(WrappedComponent) 使用装饰器 @higherOrderComponent 为什么需要高阶组件 多个组件都需要某个相同的功能，使用高阶组件可以减少重复实现 如何编写高阶组件 实现一个普通组件 将普通组件用函数包裹 render props以上我们对 高阶组件（HOC）有了基本的理解，那 render props 是什么呢？ 其实 render props 的作用和高阶组件类似 唬人的效果也跟高阶组件类似，看起来很复杂，其实也很简单，如果不知道render props是啥，那就先从props入手。 propsprops大家应该都很清楚，props是react组件的属性，子组件通过 props 来传递数据。 举个例子： 12345678910function Hello(props) &#123; return &lt;h1&gt;你好，&#123;props.name&#125;!&lt;/h1&gt;;&#125; const sayHello = &lt;Hello name=&quot;小明&quot;/&gt;; ReactDOM.render( sayHello, document.getElementById(&apos;example&apos;)); 在子组件Hello中，通过 props.name 就可以取到name属性传来的值 这就是组件上进行普通数据的传递 但其实 props 也是可以传递组件的，这种在组件上传递组件的方式，就叫做render props render props还是先放 官网文档 从官网示例来分析一下 render props 简单解释一下，就是组件中通过一个render的属性传递了一个组件 当然这个例子中属性叫做 render 只是凑巧了，这个属性名是可以随便起的 虽然叫做render props但是不一定得叫render的 比如也可以叫 “children props”，像这样： 123&lt;Mouse children=&#123;mouse =&gt; ( &lt;p&gt;The mouse position is &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt;)&#125;/&gt; 完全没问题 甚至不一定得放在属性中，可以直接置到元素的内部，变成真正的 “children props”，像这样： 12345&lt;Mouse&gt; &#123;mouse =&gt; ( &lt;p&gt;The mouse position is &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt; )&#125;&lt;/Mouse&gt; 回到例子，像这样的&lt;Mouse&gt;组件，组件的props中有一个 render（名字可以自己起）的方法，可以决定什么时候应该渲染&lt;Cat&gt;组件 ，并不是把 &lt;Cat&gt;组件硬写到 &lt;Mouse&gt; 组件里，的方式就是 render props 在Cat组件中，数据通过Mouse组件的state传过来，这样在Cat内部 高阶组件 https://codesandbox.io/s/hoc-fkv9b?file=/src/App.js renderProps https://codesandbox.io/s/renderprop-ke8k1","categories":[],"tags":[]},{"title":"ESLint","slug":"ESLint","date":"2020-09-04T07:24:16.000Z","updated":"2021-02-26T16:49:29.476Z","comments":true,"path":"2020/09/04/ESLint/","link":"","permalink":"https://akitsukiwong.github.io/2020/09/04/ESLint/","excerpt":"","text":"==参考== ESLint-Rules rules 配置规则1234rules: &#123; &quot;规则名&quot;: [规则值, 规则配置]&#125; 123&quot;off&quot;或者0 //关闭规则关闭&quot;warn&quot;或者1 //在打开的规则作为警告（不影响退出代码）&quot;error&quot;或者2 //把规则作为一个错误（退出代码触发时为1 rules 常用配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&quot;rules&quot;: &#123; &quot;quotes&quot;: [2, &quot;single&quot;], //单引号 &quot;no-console&quot;: 0, //不禁用console &quot;no-debugger&quot;: 2, //禁用debugger &quot;no-var&quot;: 0, //对var警告 &quot;semi&quot;: 0, //不强制使用分号 &quot;no-irregular-whitespace&quot;: 0, //不规则的空白不允许 &quot;no-trailing-spaces&quot;: 1, //一行结束后面有空格就发出警告 &quot;eol-last&quot;: 0, //文件以单一的换行符结束 &quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;], //不能有声明后未被使用的变量或参数 &quot;no-underscore-dangle&quot;: 0, //标识符不能以_开头或结尾 &quot;no-alert&quot;: 2, //禁止使用alert confirm prompt &quot;no-lone-blocks&quot;: 0, //禁止不必要的嵌套块 &quot;no-class-assign&quot;: 2, //禁止给类赋值 &quot;no-cond-assign&quot;: 2, //禁止在条件表达式中使用赋值语句 &quot;no-const-assign&quot;: 2, //禁止修改const声明的变量 &quot;no-delete-var&quot;: 2, //不能对var声明的变量使用delete操作符 &quot;no-dupe-keys&quot;: 2, //在创建对象字面量时不允许键重复 &quot;no-duplicate-case&quot;: 2, //switch中的case标签不能重复 &quot;no-dupe-args&quot;: 2, //函数参数不能重复 &quot;no-empty&quot;: 2, //块语句中的内容不能为空 &quot;no-func-assign&quot;: 2, //禁止重复的函数声明 &quot;no-invalid-this&quot;: 0, //禁止无效的this，只能用在构造器，类，对象字面量 &quot;no-redeclare&quot;: 2, //禁止重复声明变量 &quot;no-spaced-func&quot;: 2, //函数调用时 函数名与()之间不能有空格 &quot;no-this-before-super&quot;: 0, //在调用super()之前不能使用this或super &quot;no-undef&quot;: 2, //不能有未定义的变量 &quot;no-use-before-define&quot;: 2, //未定义前不能使用 &quot;camelcase&quot;: 0, //强制驼峰法命名 &quot;jsx-quotes&quot;: [2, &quot;prefer-double&quot;], //强制在JSX属性（jsx-quotes）中一致使用双引号 &quot;react/display-name&quot;: 0, //防止在React组件定义中丢失displayName &quot;react/forbid-prop-types&quot;: [2, &#123;&quot;forbid&quot;: [&quot;any&quot;]&#125;], //禁止某些propTypes &quot;react/jsx-boolean-value&quot;: 2, //在JSX中强制布尔属性符号 &quot;react/jsx-closing-bracket-location&quot;: 1, //在JSX中验证右括号位置 &quot;react/jsx-curly-spacing&quot;: [2, &#123;&quot;when&quot;: &quot;never&quot;, &quot;children&quot;: true&#125;], //在JSX属性和表达式中加强或禁止大括号内的空格。 &quot;react/jsx-indent-props&quot;: [2, 4], //验证JSX中的props缩进 &quot;react/jsx-key&quot;: 2, //在数组或迭代器中验证JSX具有key属性 &quot;react/jsx-max-props-per-line&quot;: [1, &#123;&quot;maximum&quot;: 1&#125;], // 限制JSX中单行上的props的最大数量 &quot;react/jsx-no-bind&quot;: 0, //JSX中不允许使用箭头函数和bind &quot;react/jsx-no-duplicate-props&quot;: 2, //防止在JSX中重复的props &quot;react/jsx-no-literals&quot;: 0, //防止使用未包装的JSX字符串 &quot;react/jsx-no-undef&quot;: 1, //在JSX中禁止未声明的变量 &quot;react/jsx-pascal-case&quot;: 0, //为用户定义的JSX组件强制使用PascalCase &quot;react/jsx-sort-props&quot;: 2, //强化props按字母排序 &quot;react/jsx-uses-react&quot;: 1, //防止反应被错误地标记为未使用 &quot;react/jsx-uses-vars&quot;: 2, //防止在JSX中使用的变量被错误地标记为未使用 &quot;react/no-danger&quot;: 0, //防止使用危险的JSX属性 &quot;react/no-did-mount-set-state&quot;: 0, //防止在componentDidMount中使用setState &quot;react/no-did-update-set-state&quot;: 1, //防止在componentDidUpdate中使用setState &quot;react/no-direct-mutation-state&quot;: 2, //防止this.state的直接变异 &quot;react/no-multi-comp&quot;: 2, //防止每个文件有多个组件定义 &quot;react/no-set-state&quot;: 0, //防止使用setState &quot;react/no-unknown-property&quot;: 2, //防止使用未知的DOM属性 &quot;react/prefer-es6-class&quot;: 2, //为React组件强制执行ES5或ES6类 &quot;react/prop-types&quot;: 0, //防止在React组件定义中丢失props验证 &quot;react/react-in-jsx-scope&quot;: 2, //使用JSX时防止丢失React &quot;react/self-closing-comp&quot;: 0, //防止没有children的组件的额外结束标签 &quot;react/sort-comp&quot;: 2, //强制组件方法顺序 &quot;no-extra-boolean-cast&quot;: 0, //禁止不必要的bool转换 &quot;react/no-array-index-key&quot;: 0, //防止在数组中遍历中使用数组key做索引 &quot;react/no-deprecated&quot;: 1, //不使用弃用的方法 &quot;react/jsx-equals-spacing&quot;: 2, //在JSX属性中强制或禁止等号周围的空格 &quot;no-unreachable&quot;: 1, //不能有无法执行的代码 &quot;comma-dangle&quot;: 2, //对象字面量项尾不能有逗号 &quot;no-mixed-spaces-and-tabs&quot;: 0, //禁止混用tab和空格 &quot;prefer-arrow-callback&quot;: 0, //比较喜欢箭头回调 &quot;arrow-parens&quot;: 0, //箭头函数用小括号括起来 &quot;arrow-spacing&quot;: 0 //=&gt;的前/后括号&#125;,","categories":[],"tags":[]},{"title":"vscode常用插件","slug":"vscode常用插件","date":"2020-03-27T09:22:28.000Z","updated":"2021-02-26T16:49:29.483Z","comments":true,"path":"2020/03/27/vscode常用插件/","link":"","permalink":"https://akitsukiwong.github.io/2020/03/27/vscode常用插件/","excerpt":"","text":"1- expand-region &lt;区域选中&gt;","categories":[],"tags":[]},{"title":"Chrome浏览器查看代码利用率","slug":"Chrome浏览器查看代码利用率","date":"2020-03-24T05:47:00.000Z","updated":"2021-02-26T16:49:29.472Z","comments":true,"path":"2020/03/24/Chrome浏览器查看代码利用率/","link":"","permalink":"https://akitsukiwong.github.io/2020/03/24/Chrome浏览器查看代码利用率/","excerpt":"","text":"代码利用率 = 你页面中实际被执行的代码 / 你页面中引入的代码 * 100% 打开 Chrome Dev Tool； 按下 Cmd + Shift + P or Ctrl + Shift + P ; 输入 Coverage，并选择第一个出现的选项；","categories":[],"tags":[]},{"title":"遇到了一个git错误，记录一下","slug":"今天遇到的一个git错误","date":"2020-03-20T06:15:11.000Z","updated":"2021-02-26T16:49:29.484Z","comments":true,"path":"2020/03/20/今天遇到的一个git错误/","link":"","permalink":"https://akitsukiwong.github.io/2020/03/20/今天遇到的一个git错误/","excerpt":"","text":"今天在工作中遇到了这个错误，在git中无论做什么操作都会报 Another git process seems to be running in this repository, e.g. an editor opened by &#39;git commit&#39;. Please make sure all processes are terminated then try again. If it still fails, a git process may have crashed in this repository earlier: remove the file manually to continue. 百度一下，大概意思是git崩溃了 解决方法： 删除项目根目录.git文件夹里的 index.lock文件 完美解决","categories":[],"tags":[]},{"title":"谷歌搜索小技巧","slug":"如何在谷歌上搜索","date":"2020-03-13T07:26:43.000Z","updated":"2021-02-26T16:49:29.485Z","comments":true,"path":"2020/03/13/如何在谷歌上搜索/","link":"","permalink":"https://akitsukiwong.github.io/2020/03/13/如何在谷歌上搜索/","excerpt":"","text":"比如我想学习别人的webpack.config.js文件配置 可以在google上搜素 1webpack.config.js site:github.com 可以找到 github 上的webpack配置 1webpack.config.js site:gitee.com 这样就可以搜码云上的","categories":[],"tags":[]},{"title":"webpack4+babel7构建React应用","slug":"webpack4-babel7构建React应用","date":"2020-03-12T08:54:33.000Z","updated":"2021-02-26T16:49:29.483Z","comments":true,"path":"2020/03/12/webpack4-babel7构建React应用/","link":"","permalink":"https://akitsukiwong.github.io/2020/03/12/webpack4-babel7构建React应用/","excerpt":"","text":"初始化项目创建一个新项目文件夹，进入并执行以下命令创建 package.json 文件1npm init 如果不想init时一步步配置项目，可以使用以下命令，所有配置项默认选择y1npm init -y 安装 webpack1npm i webpack webpack-cli webpack-dev-server -D 创建 webpack.config.js12345678module.exports = &#123; entry: &apos;&apos;, // 入口文件 output: &#123;&#125;, // 出口文件 module: &#123;&#125;, // 处理对应模块 plugins: [], // 对应的插件 devServer: &#123;&#125;, // 开发服务器配置 mode: &apos;development&apos; // 模式配置&#125; 修改 webpack.config.js123456789const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/index.js&apos;, // 入口文件 output: &#123; filename: &apos;bundle.js&apos;, // 打包后的文件名称 path: path.resolve(&apos;dist&apos;) // 打包后的目录，必须是绝对路径 &#125;&#125; 修改 package.json12345678&#123; ... &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server --mode development&quot;, &quot;build&quot;: &quot;webpack --mode production&quot; &#125; ...&#125; npm run build 尝试打包 npm start 启动尝试 安装Babel1npm i @babel/core babel-loader @babel/preset-env @babel/preset-react -D babel-loader：使用 Babel 转换 JavaScript依赖关系的 Webpack 加载器 @babel/core：即 babel-core，将 ES6 代码转换为 ES5 @babel/preset-env：即 babel-preset-env，根据您要支持的浏览器，决定使用哪些 transformations / plugins 和 polyfills，例如为旧浏览器提供现代浏览器的新特性 @babel/preset-react：即 babel-preset-react，针对所有 React 插件的 Babel 预设，例如将 JSX 转换为函数 创建.babelrc文件123456&#123; &quot;presets&quot;: [ &quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot; ]&#125; webpack.config.js 中配置 loader123456789101112131415module.exports = &#123; ... module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: &quot;babel-loader&quot; &#125; &#125; ] &#125; ...&#125;; 安装 html-webpack-plugin1npm i html-webpack-plugin -D webpack.config.js 中配置 html-webpack-plugin12345678910111213141516const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; ... plugins: [ new HtmlWebpackPlugin(&#123; // 用哪个html作为模板 // 在src目录下创建一个index.html页面当做模板来用 template: &apos;./src/index.html&apos;, filename: &apos;./index.html&apos;, hash: true, // 会在打包好的bundle.js后面加上hash串 &#125;), ] ...&#125;; 在 src 目录下创建 index.html 和 index.jsindex.html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; index.js12345678import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;const Index = () =&gt; &#123; return &lt;div&gt;Hello React!&lt;/div&gt;;&#125;;ReactDOM.render(&lt;Index /&gt;, document.getElementById(&apos;root&apos;)); npm run build 尝试打包 npm start 启动尝试 其它打包前清除文件夹1npm i clean-webpack-plugin -D webpack.config.js 配置 clean-webpack-plugin12345678910const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);module.exports = &#123; ... plugins: [ // 打包前清除dist文件夹 new CleanWebpackPlugin() ] ...&#125;; 注意引入 CleanWebpackPlugin 时要加花括号，一开始没加报错了","categories":[],"tags":[]},{"title":"使用SonarScanner进行代码质量检查","slug":"使用SonarScanner进行代码质量检查","date":"2020-03-11T08:12:12.000Z","updated":"2021-02-26T16:49:29.484Z","comments":true,"path":"2020/03/11/使用SonarScanner进行代码质量检查/","link":"","permalink":"https://akitsukiwong.github.io/2020/03/11/使用SonarScanner进行代码质量检查/","excerpt":"","text":"安装 官网下载SonarScanner 的最新版本 解压，放入喜欢的文件夹","categories":[],"tags":[]},{"title":"每天一个设计模式——工厂模式","slug":"每天一个设计模式——工厂模式","date":"2020-03-10T02:41:51.000Z","updated":"2021-02-26T16:49:29.486Z","comments":true,"path":"2020/03/10/每天一个设计模式——工厂模式/","link":"","permalink":"https://akitsukiwong.github.io/2020/03/10/每天一个设计模式——工厂模式/","excerpt":"","text":"理解类似于工厂，通过一个工厂函数，快速批量地建立一系列相同的类，也可以用来创建对象、方法。 工厂模式是用来创建对象的一种最常用的设计模式。我们不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。 判断 将 new 操作单独封装 遇到 new 时，就要考虑是否为工厂模式 示例简单的对象工厂例子123456789101112function PersonFactory(name) &#123; // 工厂函数 let obj = new Object(); obj.name = name; obj.sayName = function()&#123; return this.name; &#125; return obj;&#125;let person = new PersonFactory(&quot;张三&quot;);console.log(person.name); // 张三console.log(person.sayName()); // 张三 简单工厂模式就是一个工厂类和一个工厂函数，通过传入参数的不同，返回不同的实例。 123456789101112131415161718class Product &#123; constructor(name) &#123; this.name = name; &#125; fun() &#123; console.log(`我是&#123;this.name&#125;`) &#125;&#125;class Creator &#123; create(name) &#123; return new Product(name); &#125;&#125;let creator = new Creator()let p = creator.create(&quot;小明&quot;)p.fun();","categories":[],"tags":[]},{"title":"每天一个设计模式——单例模式","slug":"每天一个设计模式——单例模式","date":"2020-03-10T02:41:39.000Z","updated":"2021-02-26T16:49:29.486Z","comments":true,"path":"2020/03/10/每天一个设计模式——单例模式/","link":"","permalink":"https://akitsukiwong.github.io/2020/03/10/每天一个设计模式——单例模式/","excerpt":"","text":"==参考资料== 前端设计模式 理解单例模式：首先我们需要理解什么是单例。 单：指的是一个。 例：指的是创建的实例。 单例：指的是创建的总是同一个实例。也就是使用类创建的实例始终是相同的。 判断123456class Person&#123; constructor()&#123;&#125;&#125;let p1 = new Person();let p2 = new Person();console.log(p1===p2) //false 上面这段代码，定义了一个Person类，通过这个类创建了两个实例，我们可以看到最终这两个实例是不相等的，所以这并不是一个单例模式。","categories":[],"tags":[]},{"title":"理解高阶组件","slug":"高阶组件（Higher-Order Components）","date":"2019-11-18T02:12:22.000Z","updated":"2021-02-26T16:49:29.489Z","comments":true,"path":"2019/11/18/高阶组件（Higher-Order Components）/","link":"","permalink":"https://akitsukiwong.github.io/2019/11/18/高阶组件（Higher-Order Components）/","excerpt":"","text":"前言 有时候人们很喜欢造一些名字很吓人的名词，让人一听这个名词就觉得自己不可能学会，从而让人望而却步。但是其实这些名词背后所代表的东西其实很简单不能说高阶组件就是这么一个东西。但是它是一个概念上很简单，但却非常常用、实用的东西，被大量 React.js 相关的第三方库频繁地使用。在前端的业务开发当中，你不掌握高阶组件其实也可以完成项目的开发，但是如果你能够灵活地使用高阶组件，可以让你代码更加优雅，复用性、灵活性更强。它是一个加分项，而且加的分还不少。 —– React.js 小书 想要理解 高阶组件 ，我们得先来回顾一下 高阶函数 的定义 高阶函数(Higher-Order Function) 在介绍高阶函数的定义之前，先简单的举几个例子 js中内置的很多方法其实都是高阶函数，如 setTimeout() 、setInterval()、some()、every()、filter()、map()、forEach()等 比如 setTimeout 用法：123setTimeout(() =&gt; &#123; alert(&quot;Hello&quot;); &#125;, 3000); 观察 setTimeout 中接受的参数 其中第一个参数是一个函数，是你想要在到期时间(delay毫秒)之后执行的函数。第二个参数是延迟的毫秒数。 像这样把函数作为参数的函数，其实就是一种高阶函数。 这样我们再来看高阶函数的定义就很容易被理解了 高阶函数的定义 函数可以作为参数被传递 函数可以作为返回值输出 高阶组件（Higher-Order Components） 先放个官网文档 总结下： 高阶组件其实并不是一个组件而是一个函数 高阶组件就是接受一个组件作为参数并返回一个新组件的函数 联系高阶函数，高阶组件就很容易被理解了，它其实就是一个组件为参数的函数 高阶组件举例举个例子，我们在写代码中经常用到的高阶组件 react-router 中的 withRouter 就是一个高阶组件 看看官网用法 12345678910111213141516171819202122import React from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;import &#123; withRouter &#125; from &quot;react-router&quot;;// A simple component that shows the pathname of the current locationclass ShowTheLocation extends React.Component &#123; static propTypes = &#123; match: PropTypes.object.isRequired, location: PropTypes.object.isRequired, history: PropTypes.object.isRequired &#125;; render() &#123; const &#123; match, location, history &#125; = this.props; return &lt;div&gt;You are now at &#123;location.pathname&#125;&lt;/div&gt;; &#125;&#125;// Create a new component that is &quot;connected&quot; (to borrow redux// terminology) to the router.const ShowTheLocationWithRouter = withRouter(ShowTheLocation); withRouter() 函数的参数是一个组件，这样的函数就叫做高阶组件 高阶函数的使用 直接包裹 higherOrderComponent(WrappedComponent) 使用装饰器 @higherOrderComponent 为什么需要高阶组件 多个组件都需要某个相同的功能，使用高阶组件可以减少重复实现 编写高阶组件 实现一个普通组件 将普通组件用函数包裹","categories":[],"tags":[]},{"title":"React Hook","slug":"React-Hook","date":"2019-11-13T05:10:57.000Z","updated":"2021-02-26T16:49:29.478Z","comments":true,"path":"2019/11/13/React-Hook/","link":"","permalink":"https://akitsukiwong.github.io/2019/11/13/React-Hook/","excerpt":"","text":"Hook 简介Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 没有破坏性改动 完全可选的。 你无需重写任何已有代码就可以在一些组件中尝试 Hook。但是如果你不想，你不必现在就去学习或使用 Hook。 100% 向后兼容的。 Hook 不包含任何破坏性改动。 现在可用。 动机 在组件之间复用状态逻辑很难 复杂组件变得难以理解 难以理解的 class 用更少的代码，实现同样的效果 渐进策略 没有计划从 React 中移除 class。 Hook 不会影响你对 React 概念的理解。 Hook 和现有代码可以同时工作，你可以渐进式地使用他们。 基础 HookuseState1const [state, setState] = useState(initialState) 返回一个 state，以及更新 state 的函数。 useState 唯一的参数就是初始 state。 在初始渲染期间，返回的状态 (state) 与传入的第一个参数 (initialState) 值相同。 setState 函数用于更新 state。它接收一个新的 state 值并将组件的一次重新渲染加入队列。 类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。 1setState(newState); 在后续的重新渲染中，useState 返回的第一个值将始终是更新后最新的 state。 函数式更新如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 setState 的两种用法： 1234567891011function Counter(&#123;initialCount&#125;) &#123; const [count, setCount] = useState(initialCount); return ( &lt;&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 惰性初始 stateinitialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。 如果初始 state 需要通过复杂计算获得，则可以传入一个函数。 1234const [state, setState] = useState(() =&gt; &#123; const initialState = someExpensiveComputation(props); return initialState;&#125;); 跳过 state 更新调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。 需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 useMemo 来进行优化。 useEffect1useEffect(didUpdate); 该 Hook 接收一个包含命令式、且可能有副作用代码的函数。 跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。 在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。 跟 useState 一样，你可以在组件中多次使用 useEffect 默认情况下，effect 将在每轮渲染结束后执行，一旦 effect 的依赖发生变化，它就会被重新创建。 effect 的条件执行给 useEffect 传递第二个参数，它是 effect 所依赖的值数组。 123456789useEffect( () =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; subscription.unsubscribe(); &#125;; &#125;, [props.source],); 只有当 props.source 改变后才会重新创建订阅。 清除 effect通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，useEffect 函数需返回一个清除函数。 1234567useEffect(() =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; // 清除订阅 subscription.unsubscribe(); &#125;;&#125;); 为防止内存泄漏，清除函数会在组件卸载前执行。 如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。 effect 的执行时机与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。 这使得它适用于许多常见的副作用场景，比如如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。 虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。 useContext不使用组件嵌套就可以订阅 React 的 Context。 1const value = useContext(MyContext); 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。 当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。 useContext 的参数必须是 context 对象本身： 额外 HookuseReducer1const [state, dispatch] = useReducer(reducer, initialArg, init); useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。 在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。 reducer 重写 useState 一节的计数器示例： 1234567891011121314151617181920212223 const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &apos;increment&apos;: return &#123;count: state.count + 1&#125;; case &apos;decrement&apos;: return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;increment&apos;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;decrement&apos;&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 指定初始 state 有两种不同初始化 useReducer state 的方式，你可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 useReducer 是最简单的方法： 1234const [state, dispatch] = useReducer( reducer, &#123;count: initialCount&#125;); 惰性初始化 你可以选择惰性地创建初始 state。为此，需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)。 这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利： 1234567891011121314151617181920212223242526272829303132function init(initialCount) &#123; return &#123;count: initialCount&#125;;&#125;function reducer(state, action) &#123; switch (action.type) &#123; case &apos;increment&apos;: return &#123;count: state.count + 1&#125;; case &apos;decrement&apos;: return &#123;count: state.count - 1&#125;; case &apos;reset&apos;: return init(action.payload); default: throw new Error(); &#125;&#125;function Counter(&#123;initialCount&#125;) &#123; const [state, dispatch] = useReducer(reducer, initialCount, init); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;reset&apos;, payload: initialCount&#125;)&#125;&gt; Reset &lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;increment&apos;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;decrement&apos;&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 跳过 dispatch 如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。 useCallback 123456 const memoizedCallback = useCallback( () =&gt; &#123; doSomething(a, b); &#125;, [a, b],); 返回一个 memoized 回调函数。 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。 useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps) useMemo 1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 返回一个 memoized 值。 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。 记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。 你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的。 useRef 1const refContainer = useRef(initialValue); useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 一个常见的用例便是命令式地访问子组件： 12345678910111213 function TextInputWithFocusButton() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); &#125;; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; );&#125; 本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。 你应该熟悉 ref 这一种访问 DOM 的主要方式。如果你将 ref 对象以 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点。 然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。 这是因为它创建的是一个普通 Javascript 对象。而 useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。 请记住，当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。 useImperativeHandle1useImperativeHandle(ref, createHandle, [deps]) useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用： 12345678910function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; ... /&gt;;&#125;FancyInput = forwardRef(FancyInput); useLayoutEffect 其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 尽可能使用标准的 useEffect 以避免阻塞视觉更新。 useDebugValue1useDebugValue(value) useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。 1234567891011function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... // 在开发者工具中的这个 Hook 旁边显示标签 // e.g. &quot;FriendStatus: Online&quot; useDebugValue(isOnline ? &apos;Online&apos; : &apos;Offline&apos;); return isOnline;&#125; 延迟格式化 debug 值在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。 因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。 例如，一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用： 1useDebugValue(date, date =&gt; date.toDateString()); 自定义 Hook相当于使用了useState、useEffect的普通可重用函数","categories":[],"tags":[]},{"title":"Lottie","slug":"Lottie","date":"2019-10-22T01:08:40.000Z","updated":"2021-02-26T16:49:29.477Z","comments":true,"path":"2019/10/22/Lottie/","link":"","permalink":"https://akitsukiwong.github.io/2019/10/22/Lottie/","excerpt":"","text":"Lottie 是什么Lottie 是 Airbnb 开源的一个动画渲染库，可应用于 Android, iOS, Web, React Native 等平台。 Lottie 支持渲染播放 AE 动画，通过Bodymovin解析AE动画，并导出可在移动端和web端渲染动画的json文件。换言之，设计师用AE把动画效果做出来，再用Bodymovin导出相应地json文件给到前端，前端使用Lottie库就可以实现动画效果。 为什么使用 Lottie设计使用AE设计出炫酷动画，开发实现十分困难，极其复杂。毕竟开发工程师要通过代码把动效实现出来，数值什么的都是开发通过设计给了效果图去猜测，实现出来了也都存在还原度的问题。 使用 Lottie 不仅可以 100% 还原动效，而且无需动效标注。直接通过 AE 输出动效文件给开发。开发人员直接调用，然后完美还原。 Lottie支持的AE属性 效果预览https://lottiefiles.com/ 前端使用 Lottie静态url1https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.5.9/lottie.min.js NPM1npm install lottie-web 使用1234567lottie.loadAnimation(&#123; container: element, renderer: &apos;svg&apos;, loop: true, autoplay: true, path: &apos;data.json&apos; &#125;);","categories":[],"tags":[]},{"title":"mobx","slug":"mobx","date":"2019-10-15T05:48:21.000Z","updated":"2021-02-26T16:49:29.481Z","comments":true,"path":"2019/10/15/mobx/","link":"","permalink":"https://akitsukiwong.github.io/2019/10/15/mobx/","excerpt":"","text":"介绍 mobx 对比 redux 开发难度低 开发代码量少 渲染性能好 核心思想状态变化引起的副作用应该被自动触发 原则单向数据流，动作改变状态 Mobx的核心原理是通过action触发state的变化，进而触发state的衍生对象。 当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。 所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。 计算值 是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I / O）操作时。 如果视图不再使用，那么它会自动被垃圾回收。 所有的计算值都应该是纯净的。它们不应该用来改变状态。 语法observableobservable 是一种让数据的变化可以被观察的方法 对 observable 作出响应computed计算完成之后是一个新的可观察数据 autorun立即触发，可观察数据修改之后会自动再次触发 when条件执行，接收两个参数，可观察数组返回值若为真，执行后面 reaction与autorun类似，函数不会立即执行","categories":[],"tags":[]},{"title":"tslint.json的配置项说明","slug":"tslint-json的配置项说明","date":"2019-09-26T05:21:58.000Z","updated":"2021-02-26T16:49:29.482Z","comments":true,"path":"2019/09/26/tslint-json的配置项说明/","link":"","permalink":"https://akitsukiwong.github.io/2019/09/26/tslint-json的配置项说明/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667extends: 内设配置项名称rules: 规则 &#123; //ts专用 adjacent-overload-signatures ： true, // Enforces function overloads to be consecutive. ban-comma-operator：true, //禁止逗号运算符。 ban-type: [true, [&quot;object&quot;,&quot;User &#123;&#125; instead.&quot;],[&quot;string&quot;]] //禁止类型 member-access： [true , &quot;no-public&quot;||&quot;check-accessor&quot;|| &quot;check-constructor&quot; || &quot;check-parameter-property&quot; ] , //类成员必须声明 private public .... member-order: [true, &#123;order:....&#125;], //类声明排序 no-any: true,//不需使用any类型 no-empty-interface:true //禁止空接口 &#123;&#125; no-import-side-effect: [true, &#123;&quot;ignore-module&quot;: &quot;(\\\\.html|\\\\.css)$&quot;&#125;], //禁止导入带有副作用的语句 no-inferrable-types：[true, &quot;ignore-params&quot;, &quot;ignore-properties&quot;]， //不允许将变量或参数初始化为数字，字符串或布尔值的显式类型声明。 no-internal-module:true， //不允许内部模块 no-magic-numbers: [true,1,2,3], //不允许在变量赋值之外使用常量数值。当没有指定允许值列表时，默认允许-1,0和1 no-namespace: [ true,&quot;allpw-declarations&quot;], //不允许使用内部modules和命名空间 no-non-null-assertion: true , //不允许使用!后缀操作符的非空断言。 no-parameter-reassignment: true, //不允许重新分配参数 no-reference: true, // 禁止使用/// &lt;reference path=&gt; 导入 ，使用import代替 no-unnecessary-type-assertion： true, //如果类型断言没有改变表达式的类型就发出警告 no-var-requires： true, //不允许使用var module = require(&quot;module&quot;),用 import foo = require(&apos;foo&apos;)导入 only-arrow-functions：[true，&quot;allow-declarations&quot;，&quot;allow-named-functions&quot;], //允许箭头表达式，不需要传统表达式 ； 允许独立的函数声明 ；允许表达，function foo() &#123;&#125;但不是function() &#123;&#125; prefer-for-of:true, //建议使用for(..of) promise-function-async: true, 要求异步函数返回promise typedef: [true, &quot;call-signature&quot;, &quot;parameter&quot;, &quot;member-variable-declaration&quot;], //需要定义的类型存在 typedef-whitespace： true, //类型声明的冒号之前是否需要空格 unified-signatures： true, //重载可以被统一联合成一个 //function 专用 await-promise： true, //警告不是一个promise的await ban: [ true, &quot;eval&quot;, &#123;&quot;name&quot;: &quot;$&quot;, &quot;message&quot;: &quot;please don&apos;t&quot;&#125;, [&quot;describe&quot;, &quot;only&quot;], &#123;&quot;name&quot;: [&quot;it&quot;, &quot;only&quot;], &quot;message&quot;: &quot;don&apos;t focus tests&quot;&#125;, &#123; &quot;name&quot;: [&quot;chai&quot;, &quot;assert&quot;, &quot;equal&quot;], &quot;message&quot;: &quot;Use &apos;strictEqual&apos; instead.&quot; &#125;, &#123;&quot;name&quot;: [&quot;*&quot;, &quot;forEach&quot;], &quot;message&quot;: &quot;Use a regular for loop instead.&quot;&#125; ], curly: true, //for if do while 要有括号 forin:true, //用for in 必须用if进行过滤 import-blacklist:true, //允许使用import require导入具体的模块 label-postion: true, //允许在do/for/while/swith中使用label no-arg:true, //不允许使用 argument.callee no-bitwise:true, //不允许使用按位运算符 no-conditional-assignmen: true, //不允许在do-while/for/if/while判断语句中使用赋值语句 no-console：true, //不能使用console no-construct: true, //不允许使用 String/Number/Boolean的构造函数 no-debugger： true, //不允许使用debugger no-duplicate-super: true, //构造函数两次用super会发出警告 no-empty:true, //不允许空的块 no-eval: true, //不允许使用eval no-floating-promises: true, //必须正确处理promise的返回函数 no-for-in-array: true, //不允许使用for in 遍历数组 no-implicit-dependencies: true, //不允许在项目的package.json中导入未列为依赖项的模块 no-inferred-empty-object-type： true， //不允许在函数和构造函数中使用&#123;&#125;的类型推断 no-invalid-template-strings： true, //警告在非模板字符中使用$&#123; no-invalid-this：true, //不允许在非class中使用 this关键字 no-misused-new: true, //禁止定义构造函数或new class no-null-keyword: true, //不允许使用null关键字 no-object-literal-type-assertion：true, //禁止objext出现在类型断言表达式中 no-return-await：true, //不允许return await arrow-parens： true, //箭头函数定义的参数需要括号 &#125;","categories":[],"tags":[]},{"title":"mac 生成树形目录图","slug":"mac-生成文件tree","date":"2019-09-19T06:07:26.000Z","updated":"2021-02-26T16:49:29.481Z","comments":true,"path":"2019/09/19/mac-生成文件tree/","link":"","permalink":"https://akitsukiwong.github.io/2019/09/19/mac-生成文件tree/","excerpt":"","text":"方法一：mac本身可以使用如下命令来生成树形图：1find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g&apos; 方法二：使用tree工具：1brew install tree 123tree #打印所有目录层级tree -L 2 #遍历2层tree &gt; README.md #输出结果到 Markdown 文档","categories":[],"tags":[]},{"title":"lodash学习","slug":"lodash学习","date":"2019-09-03T10:54:25.000Z","updated":"2021-02-26T16:49:29.481Z","comments":true,"path":"2019/09/03/lodash学习/","link":"","permalink":"https://akitsukiwong.github.io/2019/09/03/lodash学习/","excerpt":"","text":"为什么选择 LodashLodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。Lodash 的模块化方法 非常适用于： 遍历 array、object 和 string 对值进行操作和检测 创建符合功能的函数 Array_.chunk将数组（array）拆分成多个 size 长度的区块，并将这些区块组成一个新数组。 如果array 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。 12345_.chunk([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;], 2);// =&gt; [[&apos;a&apos;, &apos;b&apos;], [&apos;c&apos;, &apos;d&apos;]] _.chunk([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;], 3);// =&gt; [[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [&apos;d&apos;]] _.compact创建一个新数组，包含原数组中所有的非假值元素。例如false, null, 0, “”, undefined, 和 NaN 都是被认为是“假值”。 12_.compact([0, 1, false, 2, &apos;&apos;, 3]);// =&gt; [1, 2, 3] _.concat创建一个新数组，将array与任何数组 或 值连接在一起。 12345678var array = [1];var other = _.concat(array, 2, [3], [[4]]); console.log(other);// =&gt; [1, 2, 3, [4]] console.log(array);// =&gt; [1] _.difference创建一个具有唯一array值的数组，每个值不包含在其他给定的数组中。（即创建一个新数组，这个数组中的值，为第一个数字（array 参数）排除了给定数组中的值。） 返回值：返回一个过滤值后的新数组12_.difference([3, 2, 1], [4, 2]);// =&gt; [3, 1] _.differenceBy这个方法类似 _.difference ，除了它接受一个 iteratee （迭代器）， 调用array 和 values 中的每个元素以产生比较的标准。 结果值是从第一数组中选择。iteratee 会调用一个参数：(value)。（首先使用迭代器分别迭代array 和 values中的每个元素，返回的值作为比较值）。 123456_.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);// =&gt; [3.1, 1.3] // The `_.property` iteratee shorthand._.differenceBy([&#123; &apos;x&apos;: 2 &#125;, &#123; &apos;x&apos;: 1 &#125;], [&#123; &apos;x&apos;: 1 &#125;], &apos;x&apos;);// =&gt; [&#123; &apos;x&apos;: 2 &#125;] _.differenceWith这个方法类似 _.difference ，除了它接受一个 comparator （比较器），它调用比较array，values中的元素。 结果值是从第一数组中选择。 1234var objects = [&#123; &apos;x&apos;: 1, &apos;y&apos;: 2 &#125;, &#123; &apos;x&apos;: 2, &apos;y&apos;: 1 &#125;]; _.differenceWith(objects, [&#123; &apos;x&apos;: 1, &apos;y&apos;: 2 &#125;], _.isEqual);// =&gt; [&#123; &apos;x&apos;: 2, &apos;y&apos;: 1 &#125;] _.drop创建一个切片数组，去除array前面的n个元素。（n默认值为1。） 1234567891011_.drop([1, 2, 3]);// =&gt; [2, 3] _.drop([1, 2, 3], 2);// =&gt; [3] _.drop([1, 2, 3], 5);// =&gt; [] _.drop([1, 2, 3], 0);// =&gt; [1, 2, 3] _.dropRight创建一个切片数组，去除array尾部的n个元素。（n默认值为1。） 1234567891011_.dropRight([1, 2, 3]);// =&gt; [1, 2] _.dropRight([1, 2, 3], 2);// =&gt; [1] _.dropRight([1, 2, 3], 5);// =&gt; [] _.dropRight([1, 2, 3], 0);// =&gt; [1, 2, 3] _.dropRightWhile创建一个切片数组，去除array中从 predicate 返回假值开始到尾部的部分。 1234567891011121314151617181920var users = [ &#123; &apos;user&apos;: &apos;barney&apos;, &apos;active&apos;: true &#125;, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;active&apos;: false &#125;, &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;active&apos;: false &#125;]; _.dropRightWhile(users, function(o) &#123; return !o.active; &#125;);// =&gt; objects for [&apos;barney&apos;] // The `_.matches` iteratee shorthand._.dropRightWhile(users, &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;active&apos;: false &#125;);// =&gt; objects for [&apos;barney&apos;, &apos;fred&apos;] // The `_.matchesProperty` iteratee shorthand._.dropRightWhile(users, [&apos;active&apos;, false]);// =&gt; objects for [&apos;barney&apos;] // The `_.property` iteratee shorthand._.dropRightWhile(users, &apos;active&apos;);// =&gt; objects for [&apos;barney&apos;, &apos;fred&apos;, &apos;pebbles&apos;] _.dropWhile1_.dropWhile(array, [predicate=_.identity]) 创建一个切片数组，去除array中从起点开始到 predicate 返回假值结束部分。predicate 会传入3个参数： (value, index, array)。 1234567891011121314151617181920var users = [ &#123; &apos;user&apos;: &apos;barney&apos;, &apos;active&apos;: false &#125;, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;active&apos;: false &#125;, &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;active&apos;: true &#125;]; _.dropWhile(users, function(o) &#123; return !o.active; &#125;);// =&gt; objects for [&apos;pebbles&apos;] // The `_.matches` iteratee shorthand._.dropWhile(users, &#123; &apos;user&apos;: &apos;barney&apos;, &apos;active&apos;: false &#125;);// =&gt; objects for [&apos;fred&apos;, &apos;pebbles&apos;] // The `_.matchesProperty` iteratee shorthand._.dropWhile(users, [&apos;active&apos;, false]);// =&gt; objects for [&apos;pebbles&apos;] // The `_.property` iteratee shorthand._.dropWhile(users, &apos;active&apos;);// =&gt; objects for [&apos;barney&apos;, &apos;fred&apos;, &apos;pebbles&apos;] _.fill使用 value 值来填充（替换） array，从start位置开始, 到end位置结束（但不包含end位置）。 1234567891011var array = [1, 2, 3]; _.fill(array, &apos;a&apos;);console.log(array);// =&gt; [&apos;a&apos;, &apos;a&apos;, &apos;a&apos;] _.fill(Array(3), 2);// =&gt; [2, 2, 2] _.fill([4, 6, 8, 10], &apos;*&apos;, 1, 3);// =&gt; [4, &apos;*&apos;, &apos;*&apos;, 10] _.findIndex1_.findIndex(array, [predicate=_.identity], [fromIndex=0]) 该方法类似 _.find，区别是该方法返回第一个通过 predicate 判断为真值的元素的索引值（index），而不是元素本身。 1234567891011121314151617181920var users = [ &#123; &apos;user&apos;: &apos;barney&apos;, &apos;active&apos;: false &#125;, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;active&apos;: false &#125;, &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;active&apos;: true &#125;]; _.findIndex(users, function(o) &#123; return o.user == &apos;barney&apos;; &#125;);// =&gt; 0 // The `_.matches` iteratee shorthand._.findIndex(users, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;active&apos;: false &#125;);// =&gt; 1 // The `_.matchesProperty` iteratee shorthand._.findIndex(users, [&apos;active&apos;, false]);// =&gt; 0 // The `_.property` iteratee shorthand._.findIndex(users, &apos;active&apos;);// =&gt; 2","categories":[],"tags":[]},{"title":"重构个人网站","slug":"重构个人网站","date":"2019-09-01T11:58:00.000Z","updated":"2021-02-26T16:49:29.487Z","comments":true,"path":"2019/09/01/重构个人网站/","link":"","permalink":"https://akitsukiwong.github.io/2019/09/01/重构个人网站/","excerpt":"","text":"之前写的个人网站是 vue + express + mysql，后端使用iview-admin 准备重构成 react + typescript + nestjs + mysql，后端基于antd-admin 编辑器使用markdown编辑器：for-editor","categories":[],"tags":[]},{"title":"TS分享准备","slug":"TS分享准备","date":"2019-08-21T08:02:48.000Z","updated":"2021-02-26T16:49:29.479Z","comments":true,"path":"2019/08/21/TS分享准备/","link":"","permalink":"https://akitsukiwong.github.io/2019/08/21/TS分享准备/","excerpt":"","text":"为什么要使用typeScript1. IDE代码提示，类型推论，自动补全，提高敲代码的效率 typeScript极大优化了编辑器的友好度，代码的提示功能会在您输入字符的同时自动在光标的相应位置弹出。 其提示列表是基于一定的顺序排列，并非按照字母顺序排列，十分好用。 当代码中没有明确的指定类型时，ts会依照类型推论的规则自动推断出类型。 使用ts之后你就会发现磨刀不误砍柴工，你为类型正确花费的时间是值得的 2. 增加代码可读性 类型是最好的注释 3. 采用TypeScript进行改造可以移除Babel全家桶，减小包体积，同时增加强类型约束从而避免今后开发时可能的问题 ts自带了语法转换 4. Ts是Js的超集，所以JavaScript 能做的，它能做。JavaScript 不能做的，它也能做。 安装 TS1npm install -g typescript 编译 Ts 文件1tsc hello.ts VScode 实时渲染 新建文件夹 拖入VScode 新建index.ts文件 执行 tsc --init，生成tsconfig.json 修改tsconfig.json中的outDir为想要输出的路径 VScode上方任务栏 终端 -&gt; 运行任务 -&gt; watch -tsconfig.json 枚举类型（enum）在程序设计语言中，一般用一个数值来代表某一状态，，这种处理方法不直观，可读性差例如：性别、月份、星期、颜色、单位名等也就是说在程序中用自然语言中相映的单词来代表某一状态，则程序就很容易阅读和理解也就是说，事先考虑到某一变量可能取的值，尽量用自然语言中含义清楚的单词来表示它的每一个值，这种方法叫做枚举方法，用这种方法定义的类型成为枚举类型","categories":[],"tags":[]},{"title":"tsconfig.json配置项","slug":"tsconfig-json","date":"2019-08-15T08:25:00.000Z","updated":"2021-02-26T16:49:29.482Z","comments":true,"path":"2019/08/15/tsconfig-json/","link":"","permalink":"https://akitsukiwong.github.io/2019/08/15/tsconfig-json/","excerpt":"","text":"编译选项1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; &quot;compilerOptions&quot;: &#123; /* 基本选项 */ &quot;target&quot;: &quot;es5&quot;, // 指定 ECMAScript 目标版本: &apos;ES3&apos; (default), &apos;ES5&apos;, &apos;ES2015&apos;, &apos;ES2016&apos;, &apos;ES2017&apos;, or &apos;ESNEXT&apos; &quot;module&quot;: &quot;commonjs&quot;, // 指定使用模块: &apos;commonjs&apos;, &apos;amd&apos;, &apos;system&apos;, &apos;umd&apos; or &apos;es2015&apos; &quot;lib&quot;: [], // 指定要包含在编译中的库文件 &quot;allowJs&quot;: true, // 允许编译 javascript 文件 &quot;checkJs&quot;: true, // 报告 javascript 文件中的错误 &quot;jsx&quot;: &quot;preserve&quot;, // 指定 jsx 代码的生成: &apos;preserve&apos;, &apos;react-native&apos;, or &apos;react&apos; &quot;declaration&quot;: true, // 生成相应的 &apos;.d.ts&apos; 文件 &quot;sourceMap&quot;: true, // 生成相应的 &apos;.map&apos; 文件 &quot;outFile&quot;: &quot;./&quot;, // 将输出文件合并为一个文件 &quot;outDir&quot;: &quot;./&quot;, // 指定输出目录 &quot;rootDir&quot;: &quot;./&quot;, // 用来控制输出目录结构 --outDir. &quot;removeComments&quot;: true, // 删除编译后的所有的注释 &quot;noEmit&quot;: true, // 不生成输出文件 &quot;importHelpers&quot;: true, // 从 tslib 导入辅助工具函数 &quot;isolatedModules&quot;: true, // 将每个文件做为单独的模块 （与 &apos;ts.transpileModule&apos; 类似）. /* 严格的类型检查选项 */ &quot;strict&quot;: true, // 启用所有严格类型检查选项 &quot;noImplicitAny&quot;: true, // 在表达式和声明上有隐含的 any类型时报错 &quot;strictNullChecks&quot;: true, // 启用严格的 null 检查 &quot;noImplicitThis&quot;: true, // 当 this 表达式值为 any 类型的时候，生成一个错误 &quot;alwaysStrict&quot;: true, // 以严格模式检查每个模块，并在每个文件里加入 &apos;use strict&apos; /* 额外的检查 */ &quot;noUnusedLocals&quot;: true, // 有未使用的变量时，抛出错误 &quot;noUnusedParameters&quot;: true, // 有未使用的参数时，抛出错误 &quot;noImplicitReturns&quot;: true, // 并不是所有函数里的代码都有返回值时，抛出错误 &quot;noFallthroughCasesInSwitch&quot;: true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ &quot;moduleResolution&quot;: &quot;node&quot;, // 选择模块解析策略： &apos;node&apos; (Node.js) or &apos;classic&apos; (TypeScript pre-1.6) &quot;baseUrl&quot;: &quot;./&quot;, // 用于解析非相对模块名称的基目录 &quot;paths&quot;: &#123;&#125;, // 模块名到基于 baseUrl 的路径映射的列表 &quot;rootDirs&quot;: [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 &quot;typeRoots&quot;: [], // 包含类型声明的文件列表 &quot;types&quot;: [], // 需要包含的类型声明文件名列表 &quot;allowSyntheticDefaultImports&quot;: true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ &quot;sourceRoot&quot;: &quot;./&quot;, // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 &quot;mapRoot&quot;: &quot;./&quot;, // 指定调试器应该找到映射文件而不是生成文件的位置 &quot;inlineSourceMap&quot;: true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 &quot;inlineSources&quot;: true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ &quot;experimentalDecorators&quot;: true, // 启用装饰器 &quot;emitDecoratorMetadata&quot;: true // 为装饰器提供元数据的支持 &#125;&#125; 使用了哪些文件？12345&#123; &quot;files&quot;: [ &quot;./some/file.ts&quot; ]&#125; 或者，你可以使用 include 和 exclude 选项来指定需要包含的文件，和排除的文件： 123456789&#123; &quot;include&quot;: [ &quot;./folder&quot; ], &quot;exclude&quot;: [ &quot;./folder/**/*.spec.ts&quot;, &quot;./folder/someSubFolder&quot; ]&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://akitsukiwong.github.io/categories/笔记/"}],"tags":[]},{"title":"SSR(ShadowsocksX-NG-R)","slug":"SSR","date":"2019-08-14T05:15:00.000Z","updated":"2021-02-26T16:49:29.479Z","comments":true,"path":"2019/08/14/SSR/","link":"","permalink":"https://akitsukiwong.github.io/2019/08/14/SSR/","excerpt":"","text":"下载 服务购买","categories":[{"name":"工具","slug":"工具","permalink":"https://akitsukiwong.github.io/categories/工具/"}],"tags":[]},{"title":"node版本控制工具nvm","slug":"node版本控制工具nvm","date":"2019-08-14T02:27:00.000Z","updated":"2021-02-26T16:49:29.482Z","comments":true,"path":"2019/08/14/node版本控制工具nvm/","link":"","permalink":"https://akitsukiwong.github.io/2019/08/14/node版本控制工具nvm/","excerpt":"","text":"安装 nvm 安装 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 验证nvm安装完成 1command -v nvm 如果安装完成，就会显示如下 1nvm 查看 nvm 可以安装的 node 版本 查看可以安装的版本 1nvm ls-remote 查看所有可以安装的LTS版本（长期支持版） 1nvm ls-remote --lts 安装指定版本的 node官方推荐的安装方式 nvm install &lt;版本号&gt; 1$ nvm install v5.5.0 但是推荐使用速度更快的方式：使用淘宝源安装 1$ NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm install 6 默认会安装一个系列中最新的版本 12345678$ NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm install 6 Downloading and installing node v6.10.2...Downloading https://npm.taobao.org/mirrors/node/v6.10.2/node-v6.10.2-darwin-x64.tar.gz...######################################################################## 100.0%Computing checksum with shasum -a 256Checksums matched!Now using node v6.10.2 (npm v3.10.10)Creating default alias: default -&gt; 6 (-&gt; v6.10.2) 也可以在最后指定版本号 1$ NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm install 6.10.2 1234567$ NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm install 7.9.0Downloading and installing node v7.9.0...Downloading https://npm.taobao.org/mirrors/node/v7.9.0/node-v7.9.0-darwin-x64.tar.gz...######################################################################## 100.0%Computing checksum with shasum -a 256Checksums matched!Now using node v7.9.0 (npm v4.2.0) 查看已经安装的 node查看安装的版本 nvm ls 123456$ nvm ls v6.10.2-&gt; v7.9.0default -&gt; 6 (-&gt; v6.10.2)node -&gt; stable (-&gt; v7.9.0) (default)stable -&gt; 7.9 (-&gt; v7.9.0) (default) 也可以通过目录查看 123/Users/macroot [macroot@macroots-MacBook-Pro] [9:06]&gt; ls -a ~/.nvm/versions/node. .. v6.10.2 v7.9.0 切换 node 版本切换node版本 nvm use &lt;版本号&gt; 切换至指定版本 12$ nvm use v6.10.2Now using node v6.10.2 (npm v3.10.10) 用node -v确认12$ node -v v6.10.2 设定默认的 node 版本设定默认的node版本 nvm alias default &lt;版本号&gt;12$ nvm alias default v6.6.0default -&gt; v6.6.0 打开新的终端，用nvm current查看当前版本显示123$ nvm currentv6.6.0 卸载指定版本的 node 用户权限提升 当使用nvm uninstall &lt;node版本号&gt;的时候，通常会被提示：1234567$ nvm uninstall v6.6.0file is not writable or self-owned: $NVM_DIR/versions/node/v6.6.0/bin/cnpmCannot uninstall, incorrect permissions on installation folder.This is usually caused by running `npm install -g` as root. Run the following commands as root to fix the permissions and then try again. chown -R username &quot;$NVM_DIR/versions/node/v6.6.0&quot; chmod -R u+w &quot;$NVM_DIR/versions/node/v6.6.0&quot; 最后两行的意思是： 第1行：把指定目录的所有者改为 username 所有，这里 username 是用户名，可以改成 $(whoami) 避免输入错误。所以先输入以下命令（使用sudo）：1$ sudo chown -R $(whoami) &quot;$NVM_DIR/versions/node/v6.6.0&quot; 第2行：u+w中u表示所有者，+表示增加权限，w表示可写入。整句表示对目录所有者增加写入权限。所以再输入（使用sudo）：1$ sudo chmod -R u+w &quot;$NVM_DIR/versions/node/v6.6.0&quot; 删除指定版本 node 当用户有了权限之后，就可以删除指定版本的 node12$ nvm uninstall v6.6.0Uninstalled node v6.6.0","categories":[{"name":"工具","slug":"工具","permalink":"https://akitsukiwong.github.io/categories/工具/"}],"tags":[]},{"title":"npm scripts 使用","slug":"npm-scripts-使用指南","date":"2019-08-08T07:25:00.000Z","updated":"2021-02-26T16:49:29.482Z","comments":true,"path":"2019/08/08/npm-scripts-使用指南/","link":"","permalink":"https://akitsukiwong.github.io/2019/08/08/npm-scripts-使用指南/","excerpt":"","text":"npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。 由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。 npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。 通配符由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。 12&quot;lint&quot;: &quot;jshint *.js&quot;&quot;lint&quot;: &quot;jshint **/*.js&quot; 上面代码中，*表示任意文件名，**表示任意一层子目录。 如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。 1&quot;test&quot;: &quot;tap test/\\*.js&quot; 传参向 npm 脚本传入参数，要使用–标明。 1&quot;lint&quot;: &quot;jshint **.js&quot; 向上面的npm run lint命令传入参数，必须写成下面这样。 1$ npm run lint -- --reporter checkstyle &gt; checkstyle.xml 也可以在package.json里面再封装一个命令。 12&quot;lint&quot;: &quot;jshint **.js&quot;,&quot;lint:checkstyle&quot;: &quot;npm run lint -- --reporter checkstyle &gt; checkstyle.xml&quot; 执行顺序如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。 如果是并行执行（即同时的平行执行），可以使用&amp;符号。 1$ npm run script1.js &amp; npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。 1$ npm run script1.js &amp;&amp; npm run script2.js 这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun","categories":[{"name":"学习","slug":"学习","permalink":"https://akitsukiwong.github.io/categories/学习/"}],"tags":[]},{"title":"mac 终端主题配置","slug":"test","date":"2019-08-05T01:20:00.000Z","updated":"2021-02-26T16:49:29.482Z","comments":true,"path":"2019/08/05/test/","link":"","permalink":"https://akitsukiwong.github.io/2019/08/05/test/","excerpt":"","text":"shell的偏好设置mac自带zsh，所以直接修改偏好设置 安装 Oh-My-Zsh：1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 就这俩步，其它花里胡哨的不需要了，一个终端而已，字体弄大点，看得清就行了","categories":[{"name":"工具","slug":"工具","permalink":"https://akitsukiwong.github.io/categories/工具/"}],"tags":[]},{"title":"前端面试题(vue)","slug":"前端面试总结","date":"2019-07-16T04:30:00.000Z","updated":"2021-02-26T16:49:29.485Z","comments":true,"path":"2019/07/16/前端面试总结/","link":"","permalink":"https://akitsukiwong.github.io/2019/07/16/前端面试总结/","excerpt":"","text":"对MVVM的理解MVVM分为Model、View、ViewModel Model 代表数据模型，数据和业务逻辑都在Model层中定义 View 代表UI视图，负责数据的展示 ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作 Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom Vue常用指令v-for 、 v-if 、v-bind、v-on、v-show、v-else、v-html等等 v-if 和 v-show 有什么区别v-if按照条件是否渲染，v-show是display的block或none； v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理 Vue实现数据双向绑定的原理vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新 12345678vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 &#123;&#123;&#125;&#125;），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 js实现简单的双向绑定123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;&#125; Object.defineProperty(obj, &apos;txt&apos;, &#123; get: function () &#123; return obj &#125;, set: function (newValue) &#123; document.getElementById(&apos;txt&apos;).value = newValue document.getElementById(&apos;show&apos;).innerHTML = newValue &#125; &#125;) document.addEventListener(&apos;keyup&apos;, function (e) &#123; obj.txt = e.target.value &#125;)&lt;/script&gt; Vue组件间的参数传递1.父组件与子组件传值父组件传给子组件：子组件通过props方法接受数据;子组件传给父组件：$emit方法传递参数 2.非父子组件间的数据传递，兄弟组件传值eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。 Vue中如何监控某个属性值的变化比如现在需要监控data中，obj.a 的变化 12345678watch: &#123; obj: &#123; handler (newValue, oldValue) &#123; console.log(&apos;obj changed&apos;) &#125;, deep: true &#125; &#125; deep属性表示深层遍历，但是这么写会监控obj的所有属性变化，并不是我们想要的效果，所以做点修改： 1234567watch: &#123; &apos;obj.a&apos;: &#123; handler (newName, oldName) &#123; console.log(&apos;obj.a changed&apos;) &#125; &#125; &#125; 还有一种方法，可以通过computed 来实现 12345computed: &#123; a1 () &#123; return this.obj.a &#125;&#125; Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？Vue创建实例时，如果obj.b没有声明，是不会被转换为响应式属性的，不会触发视图的更新，需要使用Vue的全局api $set() 1this.$set(this.obj, &apos;b&apos;, &apos;obj.b&apos;) $set()方法相当于手动的去把obj.b处理成一个响应式的属性 delete和Vue.delete删除数组的区别delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。Vue.delete直接删除了数组 改变了数组的键值。 123456var a=[1,2,3,4] var b=[1,2,3,4] delete a[1] console.log(a) this.$delete(b,1) console.log(b) 如何优化SPA应用的首屏加载速度慢的问题 加一个首屏 loading 图，提升用户体验 将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度 在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件 什么是vue生命周期Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期 vue生命周期的作用是什么它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑 第一次页面加载会触发哪几个钩子会触发 beforeCreate, created, beforeMount, mounted Vue的生命周期 beforeCreate（创建前） 在数据观测和初始化事件还未开始 created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来 beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。 beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。 destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 Vue的路由实现：hash模式 和 history模式hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。” Vue与Angular以及React的区别1.与AngularJS的区别相同点：都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。 不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。 2.与React的区别相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。不同点：React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。 vue路由的钩子函数首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next： to：route即将进入的目标路由对象， from：route当前导航正要离开的路由 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 vuex是什么？怎么使用？哪种功能场景使用它？只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车 state Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。 存放的数据状态，不可以直接修改里面的数据。 mutations mutations定义的方法动态state中的状态数据 getters 类似vue的计算属性，主要用来过滤一些数据。 action 异步处理方法，异步操作数据 actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 vue-cli如何新增自定义指令1.创建局部指令 1234567891011121314151617181920var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; &#125;, // 创建指令(可以多个) directives: &#123; // 指令名称 dir1: &#123; inserted(el) &#123; // 指令中第一个参数是当前使用指令的DOM console.log(el); console.log(arguments); // 对DOM进行操作 el.style.width = &apos;200px&apos;; el.style.height = &apos;200px&apos;; el.style.background = &apos;#000&apos;; &#125; &#125; &#125;&#125;) 2.全局指令 12345Vue.directive(&apos;dir2&apos;, &#123; inserted(el) &#123; console.log(el); &#125;&#125;) 3.指令的使用 1234&lt;div id=&quot;app&quot;&gt; &lt;div v-dir1&gt;&lt;/div&gt; &lt;div v-dir2&gt;&lt;/div&gt;&lt;/div&gt; vue如何自定义一个过滤器？html代码：1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt; &#123;&#123;msg| capitalize &#125;&#125;&lt;/div&gt; JS代码： 12345678910111213var vm=new Vue(&#123; el:&quot;#app&quot;, data:&#123; msg:&apos;&apos; &#125;, filters: &#123; capitalize: function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) 全局定义过滤器 12345Vue.filter(&apos;capitalize&apos;, function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;) 对keep-alive 的了解keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 css只在当前组件起作用在style标签中写入scoped $route和$router的区别$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。 vue.js的两个核心是什么数据驱动、组件系统 vue常用的修饰符.trim：如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符 .prevent: 提交事件不再重载页面； .stop: 阻止单击事件冒泡； .self: 当事件发生在该元素本身而不是子元素的时候会触发； .capture: 事件侦听，事件发生的时候会调用 v-on 可以绑定多个方法吗可以 vue中 key 值的作用当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 key的作用主要是为了高效的更新虚拟DOM","categories":[{"name":"面试","slug":"面试","permalink":"https://akitsukiwong.github.io/categories/面试/"}],"tags":[]},{"title":"TypeScript学习","slug":"TypeScript学习","date":"2019-06-27T05:46:00.000Z","updated":"2021-02-26T16:49:29.479Z","comments":true,"path":"2019/06/27/TypeScript学习/","link":"","permalink":"https://akitsukiwong.github.io/2019/06/27/TypeScript学习/","excerpt":"","text":"TypeScript 基础知识什么是 TypeScript JavaScript的超集，又叫类型化的JavaScript，最终编译成JavaScript。微软出品。 官网：https://www.tslang.cn 特点 始于JavaScript，归于JavaScript 可以编译出纯净、 简洁的JavaScript代码，并且可以运行在任何浏览器上、Node.js环境中和任何支持ECMAScript 3（或更高版本）的JavaScript引擎中。 强大的工具构建 大型应用程序 类型允许JavaScript开发者在开发JavaScript应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。 类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有JavaScript库的行为。 先进的 JavaScript 提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和Decorators，以帮助建立健壮的组件。 意义JavaScript是弱类型的语言，是它的优点同时也是弱点。优点是比较随意，写的代码可能会少点；弱点是代码出错检查起来比较困难，当一个变量可能被赋予多个类型的值的时候，对每个类型进行处理需要相对应的判断处理。 在写代码的时候，对于未定义值得变量，编译器无法推断出具体的类型，在调用相应的函数或者属性的时候，无法借助于编辑器的智能提示，如下代码编辑器就无法提示 123var a;function f(a, b) &#123; &#125; 当去调用一个对象的属性或者方法的时候，编译器无法知道它是否存在，只有等到运行的时候才能确定，如下所示 123456var a = &#123; &#125;function f() &#123; // 编译器无法知道say是否存在，万一你在其他的某个地方给加上了呢？ a.say()&#125; 当然，上面只是列举了部分，都是无类型化引起的，为了解决这些痛点，TypeScript应运而生，给变量加上类型标识，限制了灵活性，但是极大的改善了更多的不确定性。 时刻要注意的是，类型一旦确定，就只能接受指定类型的值，赋予其他类型的值，就会出错。当然编辑器会提醒你的~ 下面简单的看看TypeScript，更多的东西当然是借助于官方文档。 TypeScript示例类型标识的基本格式 1变量名:类型 只要在原来的JavaScript变量定义或声明的地方标识一下类型就可以转换成TypeScript代码了，当然这样粗略的转换后的代码一般是有问题的，可能需要额外的修补才能完美转换 当变量有初值的时候，若类型和初值类型一致，可以省略类型标识 首先介绍一下类型基本类型也就是基本的JavaScript类型 number string boolean null undefined 更多的内置类型，如Object, Number, String, RegExp等 any 随意类型，相当于是没有类型 枚举只能为固定的值 123456enum Color &#123; Red, Green, Blue&#125;let c: Color = Color.Green; 类型数组基本格式类型[]，这样可以标识出这个数组里面装的是指定类型的数据 还可以通过Array&lt;类型&gt;来标识 另外每个位置指定类型也行[类型1, 类型2] 接口1234interface Interface1 &#123; a: number b: string&#125; 只需要把属性或者方法列出来就好了 接口可以继承已有接口，相同的属性声明可以放在父接口里面 123interface Interface2 extends Interface1 &#123; c: boolean&#125; 类1234class Class1 &#123; a: number = 1 b: string = &apos;hello&apos;&#125; 类似于接口，不过声明的属性得有相应的初值才行，值得注意的是 当指定属性可能为undefined的时候，在变量后面添加? 当指定属性是通过其他方式赋予的初值，在变量后面添加! 可以在构造函数中声明带访问修饰符的属性，这样可以省略显示的属性声明，如下，与上面代码等价 1234class Class1 &#123; a: number = 1 constructor(public b: string = &apos;hello&apos;) &#123; &#125;&#125; 联合类型类型1 | 类型2使用|联合多种类型，表示可能变量可能的类型 函数比较通用的是使用Function来标识函数类型，当需要指定具体的参数和返回类型的时候，可以使用箭头函数，前面为参数声明，后面为返回类型，如 1var f: (a: number, b: string) =&gt; string 上面指定了f为一个函数，接收一个数字类型a和一个字符串类型b，返回一个string类型 要注意区分函数的定义与实现，定义只要定义好输入值以及返回值行了 类型别名type 类型别名 = 类型给类型起一个别名，如type Phone = string，就可以给电话号码字符串起一个好听点的名字 字面量类型直接把类型换成 1234&#123; a: number b: string&#125; 就如定义接口一样的写法 根据对象推断类型可以根据一个对象推断类型，如下 12345var obj = &#123; a: 1, b: &apos;hello&apos;&#125;type T = typeof obj 以上T就为obj相对应的类型，类似于以下这种形式 1234&#123; a: number b: string&#125; 泛型通俗的讲就是比较广泛的类型，通常出现在接口，类，以及函数中，当数据类型是不确定的，或者说是根据调用来确定的。 TypeScript官网的描述 软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 可能对于没有接触过强类型语言的人来说，开始会有点懵逼。可以把泛型理解成一个类型占位符，当调用的时候根据需要指定你想要的类型。这样可以达到为了完成某些除类型不一样但实现的功能类似的代码。站在更高角度的抽象，增加了灵活性。 下面我用几个简单的例子加以说明，力图能表达清楚。 就拿官网的例子，一个identity函数，返回传给它的值 若不用泛型实现，那么假如我可能传两种类型(只是可能，不意味着哪天高兴了需要更多的类型)，number和string 1234567function identity(arg: number): number &#123; return arg;&#125;function identity2(arg: string): string &#123; return arg;&#125; 从上面看，当需要更多的时候，是不是需要一个一个的定义，挺麻烦的，而且功能还差不多 当然你可以用下面的代码 123function identity(arg: any): any &#123; return arg&#125; 虽然能实现相应的功能，但是不要忘了，我们需要类型，有了类型才能借助于编译器帮我们检查以及利用编辑器的智能提示 下面看看利用泛型如何实现 123function identity&lt;T&gt;(arg: T): T &#123; return arg&#125; 上面跟再上的代码差不多，但是功能更加强大，可以接受任意类型，并且返回指定类型，下面让我们看看如何用 数字 identity(123)，编译器就可以知道返回值为数字了 字符串 identity(‘hello’) 布尔值 identity(true) 更多其他类型…以上对于编译器来说返回值是什么就一目了然了 注意T是可以换成别的任何一个标识符的，只是一个占位符而已 另外看看接口中如何定义和使用(类中类似) 12345678interface Interface1&lt;T&gt; &#123; aa: T bb: number&#125;var t: Interface1&lt;string&gt; = &#123; aa: &apos;hello&apos;, bb: 123&#125; 当需要什么类型的时候，指定好就行了 1234567当有多个类型不确定的时候，在&lt;&gt;里面指定任意数量的类型，使用,进行分隔function identity&lt;T1, T2&gt;(t1: T1, t2: T2): string &#123; return &apos;xxxxxxxxxxxxxxx&apos;&#125;调用的时候，按照定义顺序传递相应的类型identity&lt;number, string&gt;(1, &apos;hello&apos;) 总结上面简要的介绍了下TypeScript的基础知识，需要更全面的了解，还是应该去官网。 平时的开发过程中，注意给变量标识好类型，尽量少用any，由于TypeScript是JavaScript的超集，所以’js’代码也是可以编译通过的，但会给你一系列的报错和警告。 vue2.5 + TypeScript 构建项目 安装vue-cli 安装ts依赖 配置 webpack 添加 tsconfig.json 添加 tslint.json 让 ts 识别 .vue 改造 .vue文件 vue-cli拉取1.5模板123npm install -g @vue/cli-init# `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同vue init webpack my-project 引入 TypeScript安装必要插件 12345安装vue的官方插件npm i vue-class-component vue-property-decorator --save// ts-loader typescript 必须安装，其他的相信你以后也会装上的npm i ts-loader typescript tslint tslint-loader tslint-config-standard --save-dev 插件作用： vue-class-component：强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件 vue-property-decorator：在 vue-class-component 上增强更多的结合 Vue 特性的装饰器 ts-loader：TypeScript 为 Webpack 提供了 ts-loader，其实就是为了让webpack识别 .ts .tsx文件 tslint-loader跟tslint：我想你也会在.ts .tsx文件 约束代码格式（作用等同于eslint） tslint-config-standard：tslint 配置 standard风格的约束 1.3 配置 webpack首先找到./build/webpack.base.conf.js 找到entry.app 将main.js 改成 main.ts, 顺便把项目文件中的main.js也改成main.ts, 里面内容保持不变 entry: { app: &#39;./src/main.ts&#39; } 找到resolve.extensions 里面加上.ts 后缀 （是为了之后引入.ts的时候不写后缀） 123456resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;, &apos;.ts&apos;], alias: &#123; &apos;@&apos;: resolve(&apos;src&apos;) &#125; &#125; 找到module.rules 添加webpack对.ts的解析 1234567891011121314151617181920212223242526272829module: &#123; rules: [ &#123; test: /\\.(js|vue)$/, loader: &apos;eslint-loader&apos;, enforce: &apos;pre&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)], options: &#123; formatter: require(&apos;eslint-friendly-formatter&apos;) &#125; &#125;,// 从这里复制下面的代码就可以了 &#123; test: /\\.ts$/, exclude: /node_modules/, enforce: &apos;pre&apos;, loader: &apos;tslint-loader&apos; &#125;, &#123; test: /\\.tsx?$/, loader: &apos;ts-loader&apos;, exclude: /node_modules/, options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125; &#125;,// 复制以上的 &#125;&#125; 解释： ts-loader 会检索当前目录下的 tsconfig.json 文件，根据里面定义的规则来解析.ts文件（就跟.babelrc的作用一样） tslint-loader 作用等同于 eslint-loader 添加 tsconfig.json根路径下创建tsconfig.json文件 参考配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; // 编译选项 &quot;compilerOptions&quot;: &#123; // 输出目录 &quot;outDir&quot;: &quot;./output&quot;, // 是否包含可以用于 debug 的 sourceMap &quot;sourceMap&quot;: true, // 以严格模式解析 &quot;strict&quot;: true, // 采用的模块系统 &quot;module&quot;: &quot;esnext&quot;, // 如何处理模块 &quot;moduleResolution&quot;: &quot;node&quot;, // 编译输出目标 ES 版本 &quot;target&quot;: &quot;es5&quot;, // 允许从没有设置默认导出的模块中默认导入 &quot;allowSyntheticDefaultImports&quot;: true, // 将每个文件作为单独的模块 &quot;isolatedModules&quot;: false, // 启用装饰器 &quot;experimentalDecorators&quot;: true, // 启用设计类型元数据（用于反射） &quot;emitDecoratorMetadata&quot;: true, // 在表达式和声明上有隐含的any类型时报错 &quot;noImplicitAny&quot;: false, // 不是函数的所有返回路径都有返回值时报错。 &quot;noImplicitReturns&quot;: true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等 &quot;importHelpers&quot;: true, // 编译过程中打印文件名 &quot;listFiles&quot;: true, // 移除注释 &quot;removeComments&quot;: true, &quot;suppressImplicitAnyIndexErrors&quot;: true, // 允许编译javascript文件 &quot;allowJs&quot;: true, // 解析非相对模块名的基准目录 &quot;baseUrl&quot;: &quot;./&quot;, // 指定特殊模块的路径 &quot;paths&quot;: &#123; &quot;jquery&quot;: [ &quot;node_modules/jquery/dist/jquery&quot; ] &#125;, // 编译过程中需要引入的库文件的列表 &quot;lib&quot;: [ &quot;dom&quot;, &quot;es2015&quot;, &quot;es2015.promise&quot; ] &#125;&#125; 我的配置： 123456789101112131415161718192021222324&#123; &quot;include&quot;: [ &quot;src/**/*&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot; ], &quot;compilerOptions&quot;: &#123; &quot;allowSyntheticDefaultImports&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;allowJs&quot;: true, &quot;module&quot;: &quot;esnext&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;isolatedModules&quot;: true, &quot;lib&quot;: [ &quot;dom&quot;, &quot;es5&quot;, &quot;es2015.promise&quot; ], &quot;sourceMap&quot;: true, &quot;pretty&quot;: true &#125;&#125; 1.5 添加 tslint.json根路径下创建tslint.json文件,引入 ts的 tandard规范 123456&#123; &quot;extends&quot;: &quot;tslint-config-standard&quot;, &quot;globals&quot;: &#123; &quot;require&quot;: true &#125;&#125; 让 ts 识别 .vue由于 TypeScript 默认并不支持 *.vue后缀的文件，所以在 vue 项目中引入的时候需要创建一个vue-shim.d.ts文件，放在项目项目对应使用目录下，例如src/vue-shim.d.ts 1234declare module &quot;*.vue&quot; &#123; import Vue from &quot;vue&quot;; export default Vue;&#125; 意思是告诉TypeScript *.vue后缀的文件可以交给vue模块来处理。 而在代码中导入 *.vue文件的时候，需要写上 .vue 后缀。原因还是因为TypeScript 默认只识别 *.ts文件，不识别*.vue 文件： 1import Component from &apos;components/component.vue&apos; 改造 .vue 文件修改App.vue文件 在script标签上加上 lang=&quot;ts&quot;, 意思是让webpack将这段代码识别为typescript而非javascript 修改vue组件的构造方式( 跟react组件写法有点类似, 详见官方 )， 如下图 用vue-property-decorator语法改造之前代码 修改成： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import Vue from &apos;vue&apos;import Component from &apos;vue-class-component&apos;@Component(&#123;&#125;)export default class App extends Vue &#123;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 相同的方式修改HelloWorld.vue 最后npm run dev","categories":[{"name":"学习","slug":"学习","permalink":"https://akitsukiwong.github.io/categories/学习/"}],"tags":[{"name":"TS","slug":"TS","permalink":"https://akitsukiwong.github.io/tags/TS/"}]},{"title":"设计模式学习","slug":"面向对象","date":"2019-05-17T03:07:39.000Z","updated":"2021-02-26T16:49:29.487Z","comments":true,"path":"2019/05/17/面向对象/","link":"","permalink":"https://akitsukiwong.github.io/2019/05/17/面向对象/","excerpt":"","text":"面向对象三要素： 继承（子类继承父类） 继承可以将公共方法抽离出来，提高复用，减少冗余 封装（数据多权限和保密） public 完全开放 protected 对子类开放 private 对自己开放 减少耦合，不该外漏的不外漏 利于数据，接口的权限管理 多态（同一接口的不同实现） 同一个接口，不同的表现 保持子类的开放性和灵活性 面向接口编程 super关键字 12345super([arguments]); // 调用 父对象/父类 的构造函数super.functionOnParent([arguments]); // 调用 父对象/父类 上的方法 uml类图Unified Modeling Language 统一建模语言 123+ ：表示public- ：表示private#：表示protected 设计原则 UNIX / LINUX 设计哲学准则 小即是美 让每个程序之做好一件事 快速建立原型 舍弃高效率而取可移植性 采用纯文本来存储数据 充分利用软件的杠杆效应(软件复用) 使用 shell 脚本来提高杠杆效应和可移植性 避免强制性的用户界面 让每个程序都称为过滤器 小准则 允许用户定制环境 尽量是操作系统内核小而轻量化 使用小写字母并尽量简写 沉默是金 各部分之和大于整体 寻求90%的解决方案(2/8定律) SOLID 设计原则S - 单一指责原则（SRP）O - 开放封闭原则（OCP）L - 里氏置换原则（LSP）I - 接口独立原则（ISP）D - 依赖倒置原则（DIP） 设计模式 创建型 组合型 行为型","categories":[],"tags":[]},{"title":"前端面试题（js）","slug":"js-面试题","date":"2019-04-01T02:35:14.000Z","updated":"2021-02-26T16:49:29.480Z","comments":true,"path":"2019/04/01/js-面试题/","link":"","permalink":"https://akitsukiwong.github.io/2019/04/01/js-面试题/","excerpt":"","text":"js的基本数据类型 Undefined、 Null、 Boolean、 Number、 String、 ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 ) js有哪些内置对象 Object 是 JavaScript 中所有对象的父对象 数据封装类对象： Object、 Array、 Boolean、 Number 和 String 其他对象： Function、 Arguments、 Math、 Date、 RegExp、 Error 原型与原型链proto是每个对象都有的一个属性， 而prototype是函数才会有的属性!!! 123Object.__proto__ === Function.prototype;Function.prototype.__proto__ === Object.prototype;Object.prototype.__proto__ === null; 题目 1 1234567891011121314var A = function() &#123;&#125;;A.prototype.n = 1;var b = new A();A.prototype = &#123; n: 2, m: 3&#125;var c = new A();console.log(b.n);console.log(b.m);console.log(c.n);console.log(c.m); 请写出上面编程的输出结果是什么？ 题目 2 1234567891011121314151617var F = function() &#123;&#125;;Object.prototype.a = function() &#123; console.log(&apos;a&apos;);&#125;;Function.prototype.b = function() &#123; console.log(&apos;b&apos;);&#125;var f = new F();f.a();f.b();F.a();F.b(); 请写出上面编程的输出结果是什么？ 题目 3 1234function Person(name) &#123; this.name = name&#125;let p = new Person(&apos;Tom&apos;); 问题1： 1. p.proto等于什么？问题2： Person.proto等于什么？ 题目 4 12345678910var foo = &#123;&#125;, F = function() &#123;&#125;;Object.prototype.a = &apos;value a&apos;;Function.prototype.b = &apos;value b&apos;;console.log(foo.a);console.log(foo.b);console.log(F.a);console.log(F.b); 请写出上面编程的输出结果是什么？ 题目 1 答案：b.n -&gt; 1b.m -&gt; undefined;c.n -&gt; 2;c.m -&gt; 3; 题目 2 答案：f.a() -&gt; af.b() -&gt; f.b is not a functionF.a() -&gt; aF.b() -&gt; b 题目 3 答案答案1： Person.prototype答案2： Function.prototype 题目 4 答案foo.a =&gt; value afoo.b =&gt; undefinedF.a =&gt; value aF.b =&gt; value b 什么是深拷贝？ 什么是浅拷贝？简单来说， 有两个对象 A 和 B， B = A， 当你修改 A 时， B 的值也跟着发生了变化， 这时候就叫浅拷贝。 如果不发生变化， 就叫深拷贝。 new的实现原理是什么？ 创建一个空对象，构造函数中的this指向这个空对象 这个新对象被执行 [[原型]] 连接 执行构造函数方法，属性和方法被添加到this引用的对象中 如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。","categories":[],"tags":[]},{"title":"前端面试题（css）","slug":"CSS面试题","date":"2019-04-01T02:34:30.000Z","updated":"2021-02-26T16:49:29.472Z","comments":true,"path":"2019/04/01/CSS面试题/","link":"","permalink":"https://akitsukiwong.github.io/2019/04/01/CSS面试题/","excerpt":"","text":"页面导入样式时，使用link和@import有什么区别？1234- link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;- 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;- import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;- link支持使用js控制DOM去改变样式，而@import不支持; 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？123（1）有两种， IE 盒子模型、W3C 盒子模型；（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；（3）区 别： IE的content部分把 border 和 padding计算了进去; CSS选择符有哪些？哪些属性可以继承？12345678910111213* 1.id选择器（ # myid） 2.类选择器（.myclassname） 3.标签选择器（div, h1, p） 4.相邻选择器（h1 + p） 5.子选择器（ul &gt; li） 6.后代选择器（li a） 7.通配符选择器（ * ） 8.属性选择器（a[rel = &quot;external&quot;]） 9.伪类选择器（a:hover, li:nth-child）* 可继承的样式： font-size font-family color, UL LI DL DD DT;* 不可继承的样式：border padding margin width height ; 如何居中div？水平居中：给div设置一个宽度，然后添加margin:0 auto属性1234div&#123; width:200px; margin:0 auto; &#125; 让绝对定位的div居中1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */&#125; 水平垂直居中一12345678910111213确定容器的宽高 宽500 高 300 的层设置层的外边距div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */ &#125; 水平垂直居中二123456789101112未知容器的宽高，利用 `transform` 属性div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /* 方便看效果 */&#125; 水平垂直居中三1234567891011121314利用 flex 布局实际使用时应考虑兼容性.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */&#125;.container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */&#125; display有哪些值？说明他们的作用。1234567block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。none 元素不显示，并从文档流中移除。inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。list-item 象块类型元素一样显示，并添加样式列表标记。table 此元素会作为块级表格来显示。inherit 规定应该从父元素继承 display 属性的值。 position的值relative和absolute定位原点是？12345678910 absolute生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。 relative生成相对定位的元素，相对于其正常位置进行定位。 static默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit规定从父元素继承 position 属性的值。 用纯CSS创建一个三角形的原理是什么？12345678把上、左、右三条边隐藏掉（颜色设为 transparent）#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; css定义的权重12345678910111213141516171819202122以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：/*权重为1*/div&#123;&#125;/*权重为10*/.class1&#123;&#125;/*权重为100*/#id1&#123;&#125;/*权重为100+1=101*/#id1 div&#123;&#125;/*权重为10+1=11*/.class1 div&#123;&#125;/*权重为10+10+1=21*/.class1 .class2 div&#123;&#125;如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 请解释一下为什么需要清除浮动？清除浮动的方式清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。123456789101112131415161718192021222324252627282930311、父级div定义height；2、父级div 也一起浮动；3、常规的使用一个class； .clearfix::before, .clearfix::after &#123; content: &quot; &quot;; display: table; &#125; .clearfix::after &#123; clear: both; &#125; .clearfix &#123; *zoom: 1; &#125;4、SASS编译的时候，浮动元素的父级div定义伪类:after &amp;::after,&amp;::before&#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; &#125;解析原理：1) display:block 使生成的元素以块级元素显示,占满剩余空间;2) height:0 避免生成内容破坏原有布局的高度。3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;4）通过 content:&quot;.&quot;生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:&quot;.&quot;,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”&quot; 仍然会产生额外的空隙；5）zoom：1 触发IE hasLayout。通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。","categories":[],"tags":[]},{"title":"前端面试题（html）","slug":"HTML面试题","date":"2019-04-01T02:34:02.000Z","updated":"2021-02-26T16:49:29.477Z","comments":true,"path":"2019/04/01/HTML面试题/","link":"","permalink":"https://akitsukiwong.github.io/2019/04/01/HTML面试题/","excerpt":"","text":"HTML行内元素、块状元素、行内块状元素的区别块级元素：块级大多为结构性标记 12345678910111213141516171819&lt;address&gt;...&lt;/adderss&gt; &lt;center&gt;...&lt;/center&gt; 地址文字&lt;h1&gt;...&lt;/h1&gt; 标题一级&lt;h2&gt;...&lt;/h2&gt; 标题二级&lt;h3&gt;...&lt;/h3&gt; 标题三级&lt;h4&gt;...&lt;/h4&gt; 标题四级&lt;h5&gt;...&lt;/h5&gt; 标题五级&lt;h6&gt;...&lt;/h6&gt; 标题六级&lt;hr&gt; 水平分割线&lt;p&gt;...&lt;/p&gt; 段落&lt;pre&gt;...&lt;/pre&gt; 预格式化&lt;blockquote&gt;...&lt;/blockquote&gt; 段落缩进 前后5个字符&lt;marquee&gt;...&lt;/marquee&gt; 滚动文本&lt;ul&gt;...&lt;/ul&gt; 无序列表&lt;ol&gt;...&lt;/ol&gt; 有序列表&lt;dl&gt;...&lt;/dl&gt; 定义列表&lt;table&gt;...&lt;/table&gt; 表格&lt;form&gt;...&lt;/form&gt; 表单&lt;div&gt;...&lt;/div&gt; 行内元素：行内大多为描述性标记 123456789101112131415&lt;span&gt;...&lt;/span&gt;&lt;a&gt;...&lt;/a&gt; 链接&lt;br&gt; 换行&lt;b&gt;...&lt;/b&gt; 加粗&lt;strong&gt;...&lt;/strong&gt; 加粗&lt;img &gt; 图片&lt;sup&gt;...&lt;/sup&gt; 上标&lt;sub&gt;...&lt;/sub&gt; 下标&lt;i&gt;...&lt;/i&gt; 斜体&lt;em&gt;...&lt;/em&gt; 斜体&lt;del&gt;...&lt;/del&gt; 删除线&lt;u&gt;...&lt;/u&gt; 下划线&lt;input&gt;...&lt;/input&gt; 文本框&lt;textarea&gt;...&lt;/textarea&gt; 多行文本&lt;select&gt;...&lt;/select&gt; 下拉列表 互相转换 display:inline;转换为行内元素 display:block;转换为块状元素 display:inline-block;转换为行内块状元素 对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 常见的浏览器内核有哪些？ Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭","categories":[],"tags":[]},{"title":"关于HotApp","slug":"关于HotApp","date":"2018-12-22T06:24:51.000Z","updated":"2021-02-26T16:49:29.484Z","comments":true,"path":"2018/12/22/关于HotApp/","link":"","permalink":"https://akitsukiwong.github.io/2018/12/22/关于HotApp/","excerpt":"","text":"新单位主要是写小程序 闲的时候发现了 hotapp 这玩意可以代理小程序接口 所以就不需要自己费时费力去备案什么的 备案贼鸡儿麻烦 必须要买服务器一个服务器又只能有五个备案号 购买虚拟主机都必须要买三个月以上才可以备案真是头疼 现在只要在小程序后台把request安全域名修改为https://wxapi.hotapp.cn 就可以开心的开发小程序了 我采用的方法是代理到我的github 完美","categories":[],"tags":[]},{"title":"wepy学习","slug":"wepy学习","date":"2018-12-07T06:51:00.000Z","updated":"2021-02-26T16:49:29.483Z","comments":true,"path":"2018/12/07/wepy学习/","link":"","permalink":"https://akitsukiwong.github.io/2018/12/07/wepy学习/","excerpt":"","text":"快速入门全局安装1npm install wepy-cli -g 生成Demo开发项目1wepy init standard myproject 安装依赖1npm install 实时编译1wepy build --watch 设置微信开发者工具 选项中关闭ES6转ES5 选项中关闭上传代码时样式自动补全 选项中关闭代码压缩上传 选项中打开不检查安全域名（如果已配置好安全域名则建议关闭） @符号 原 bindtap=&quot;click&quot; 替换为 @tap=&quot;click&quot; 原 catchtap=&quot;click&quot; 替换为 @tap.stop=&quot;click&quot; 原 capture-bind:tap=&quot;click&quot; 替换为@tap.capture=&quot;click&quot; 原 capture-catch:tap=&quot;click&quot; 替换为@tap.capture.stop=&quot;click&quot; 1bindtap=&quot;click&quot; data-index= &#123;&#123;index&#125;&#125; 替换为1@tap=&quot;click(&#123;&#123;index&#125;&#125;)&quot;","categories":[],"tags":[{"name":"wepy","slug":"wepy","permalink":"https://akitsukiwong.github.io/tags/wepy/"}]},{"title":"SQL语句学习","slug":"SQL语句学习","date":"2018-10-25T06:55:00.000Z","updated":"2021-02-26T16:49:29.478Z","comments":true,"path":"2018/10/25/SQL语句学习/","link":"","permalink":"https://akitsukiwong.github.io/2018/10/25/SQL语句学习/","excerpt":"","text":"SQL语句学习上周试着用Express去搭后台 , 搭好了一个基础的框架 , 后端还是挺有意思的 我如果需要更丰富的功能就需要学习更多的SQL语句 , 所以这周的计划是学习SQL语句 学习的主要途径是看W3C的文档 链接 SQL 简介SQL 是用于访问和处理数据库的标准的计算机语言。 什么是 SQL？ SQL 指结构化查询语言 SQL 使我们有能力访问数据库 SQL 是一种 ANSI (美国国家标准化组织) 的标准计算机语言 SQL 能做什么？ SQL 面向数据库执行查询 SQL 可从数据库取回数据 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 SQL 可创建新数据库 SQL 可在数据库中创建新表 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 SQL 语法数据库表一个数据库通常包含一个或多个表。每个表由一个名字标识（例如“客户”或者“订单”）。表包含带有数据的记录（行）。 下面的例子是一个名为 “Persons” 的表： Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 上面的表包含三条记录（每一条对应一个人）和五个列（Id、姓、名、地址和城市）。 SQL 语句您需要在数据库上执行的大部分工作都由 SQL 语句完成。 下面的语句从表中选取 LastName 列的数据： 1SELECT LastName FROM Persons 结果集类似这样： LastName Adams Bush Carter 在本教程中，我们将为您讲解各种不同的 SQL 语句。 重要事项 : 一定要记住，SQL 对大小写不敏感！ SQL DML 和 DDL可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。 SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。 查询和更新指令构成了 SQL 的 DML 部分： SELECT - 从数据库表中获取数据 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。 SQL 中最重要的 DDL 语句: CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL SELECT 语句SQL SELECT 语句SELECT 语句用于从表中选取数据。 结果被存储在一个结果表中（称为结果集）。 SQL SELECT 语法1SELECT 列名称 FROM 表名称 以及： 1SELECT * FROM 表名称 注释：SQL 语句对大小写不敏感。SELECT 等效于 select。 SQL SELECT 实例如需获取名为 “LastName” 和 “FirstName” 的列的内容（从名为 “Persons” 的数据库表），请使用类似这样的 SELECT 语句： 1SELECT LastName,FirstName FROM Persons “Persons” 表: Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 结果： LastName FirstName Adams John Bush George Carter Thomas SQL SELECT * 实例现在我们希望从 “Persons” 表中选取所有的列。 请使用符号 * 取代列的名称，就像这样： 1SELECT * FROM Persons 提示：星号（*）是选取所有列的快捷方式。 结果： Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing SQL SELECT DISTINCT 语句SQL SELECT DISTINCT 语句在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。 关键词 DISTINCT 用于返回唯一不同的值。 语法： 1SELECT DISTINCT 列名称 FROM 表名称 使用 DISTINCT 关键词如果要从 “Company” 列中选取所有的值，我们需要使用 SELECT 语句： 1SELECT Company FROM Orders “Orders”表： Company OrderNumber IBM 3532 W3School 2356 Apple 4698 W3School 6953 结果： Company IBM W3School Apple W3School 请注意，在结果集中，W3School 被列出了两次。 如需从 Company” 列中仅选取唯一不同的值，我们需要使用 SELECT DISTINCT 语句： 1SELECT DISTINCT Company FROM Orders 现在，在结果集中，”W3School” 仅被列出了一次。 SQL WHERE 子句WHERE 子句用于规定选择的标准。WHERE 子句如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。 语法 1SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 下面的运算符可在 WHERE 子句中使用： 操作符 描述 = 等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 注释：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。 使用 WHERE 子句如果只希望选取居住在城市 “Beijing” 中的人，我们需要向 SELECT 语句添加 WHERE 子句： 1SELECT * FROM Persons WHERE City=&apos;Beijing&apos; “Persons” 表 LastName FirstName Address City Year Adams John Oxford Street London 1970 Bush George Fifth Avenue New York 1975 Carter Thomas Changan Street Beijing 1980 Gates Bill Xuanwumen 10 Beijing 1985 结果： LastName FirstName Address City Year Carter Thomas Changan Street Beijing 1980 Gates Bill Xuanwumen 10 Beijing 1985 引号的使用 请注意，我们在例子中的条件值周围使用的是单引号。 SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。 文本值： 12345这是正确的：SELECT * FROM Persons WHERE FirstName=&apos;Bush&apos;这是错误的：SELECT * FROM Persons WHERE FirstName=Bush 数值： 12345这是正确的：SELECT * FROM Persons WHERE Year&gt;1965这是错误的：SELECT * FROM Persons WHERE Year&gt;&apos;1965&apos; SQL AND &amp; OR 运算符AND 和 OR 运算符用于基于一个以上的条件对记录进行过滤。AND 和 OR 运算符AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。 原始的表 (用在例子中的)： LastName FirstName Address City Adams John Oxford Street London Bush George Fifth Avenue New York Carter Thomas Changan Street Beijing Carter William Xuanwumen 10 Beijing AND 运算符实例使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人： 1SELECT * FROM Persons WHERE FirstName=&apos;Thomas&apos; AND LastName=&apos;Carter&apos; 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing OR 运算符实例使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人： 1SELECT * FROM Persons WHERE firstname=&apos;Thomas&apos; OR lastname=&apos;Carter&apos; 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Carter William Xuanwumen 10 Beijing 结合 AND 和 OR 运算符我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）: 12SELECT * FROM Persons WHERE (FirstName=&apos;Thomas&apos; OR FirstName=&apos;William&apos;)AND LastName=&apos;Carter&apos; 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Carter William Xuanwumen 10 Beijing SQL ORDER BY 子句ORDER BY 语句用于对结果集进行排序。ORDER BY 语句ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 原始的表 (用在例子中的)： Orders 表: Company OrderNumber IBM 3532 W3School 2356 Apple 4698 W3School 6953 实例 1 以字母顺序显示公司名称： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company 结果： Company OrderNumber Apple 4698 IBM 3532 W3School 6953 W3School 2356 实例 2 以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber 结果： Company OrderNumber Apple 4698 IBM 3532 W3School 2356 W3School 6953 实例 3 以逆字母顺序显示公司名称： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC 结果： Company OrderNumber W3School 6953 W3School 2356 IBM 3532 Apple 4698 实例 4 以逆字母顺序显示公司名称，并以数字顺序显示顺序号： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC 结果： Company OrderNumber W3School 2356 W3School 6953 IBM 3532 Apple 4698 注意：在以上的结果中有两个相等的公司名称 (W3School)。只有这一次，在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 nulls 时，情况也是这样的。 SQL INSERT INTO 语句INSERT INTO 语句用于向表格中插入新的行。 1INSERT INTO 表名称 VALUES (值1, 值2,....) 我们也可以指定所要插入数据的列： 1INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://akitsukiwong.github.io/tags/SQL/"}]},{"title":"vue生命周期钩子","slug":"vue生命周期钩子","date":"2018-10-02T06:55:00.000Z","updated":"2021-02-26T16:49:29.483Z","comments":true,"path":"2018/10/02/vue生命周期钩子/","link":"","permalink":"https://akitsukiwong.github.io/2018/10/02/vue生命周期钩子/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message : &quot;xuxiao is boy&quot; &#125;, beforeCreate: function () &#123; console.group(&apos;beforeCreate 创建前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, created: function () &#123; console.group(&apos;created 创建完毕状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group(&apos;beforeMount 挂载前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + (this.$el)); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group(&apos;mounted 挂载结束状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group(&apos;beforeUpdate 更新前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, updated: function () &#123; console.group(&apos;updated 更新完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeDestroy: function () &#123; console.group(&apos;beforeDestroy 销毁前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, destroyed: function () &#123; console.group(&apos;destroyed 销毁完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"Document 节点","slug":"Document-节点","date":"2018-09-29T00:47:00.000Z","updated":"2021-02-26T16:49:29.475Z","comments":true,"path":"2018/09/29/Document-节点/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/29/Document-节点/","excerpt":"","text":"Document 节点概述document节点对象代表整个文档，每张网页都有自己的document对象。window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。 document对象有不同的办法可以获取。 正常的网页，直接使用document或window.document。iframe框架里面的网页，使用iframe节点的contentDocument属性。Ajax操作返回的文档，使用XMLHttpRequest对象的responseXML属性。内部节点的ownerDocument属性。document对象继承了EventTarget接口、Node接口、ParentNode接口。这意味着，这些接口的方法都可以在document对象上调用。除此之外，document对象还有很多自己的属性和方法。 属性快捷方式属性以下属性是指向文档内部的某个节点的快捷方式。 （1）document.defaultViewdocument.defaultView属性返回document对象所属的window对象。如果当前文档不属于window对象，该属性返回null。 1document.defaultView === window // true （2）document.doctype对于 HTML 文档来说，document对象一般有两个子节点。第一个子节点是document.doctype，指向&lt;DOCTYPE&gt;节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成&lt;!DOCTYPE html&gt;。如果网页没有声明 DTD，该属性返回null。 123var doctype = document.doctype;doctype // &quot;&lt;!DOCTYPE html&gt;&quot;doctype.name // &quot;html&quot; document.firstChild通常就返回这个节点。 （3）document.documentElementdocument.documentElement属性返回当前文档的根元素节点（root）。它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。HTML网页的该属性，一般是节点。 （4）document.body，document.headdocument.body属性指向&lt;body&gt;节点，document.head属性指向&lt;head&gt;节点。 这两个属性总是存在的，如果网页源码里面省略了&lt;head&gt;或&lt;body&gt;，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。 （5）document.scrollingElementdocument.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。 标准模式下，这个属性返回的文档的根元素document.documentElement（即）。兼容（quirk）模式下，返回的是元素，如果该元素不存在，返回null。 12// 页面滚动到浏览器顶部document.scrollingElement.scrollTop = 0; （6）document.activeElementdocument.activeElement属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;等表单元素，如果当前没有焦点元素，返回&lt;body&gt;元素或null。 （7）document.fullscreenElementdocument.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。 123if (document.fullscreenElement.nodeName == &apos;VIDEO&apos;) &#123; console.log(&apos;全屏播放视频&apos;);&#125; 上面代码中，通过document.fullscreenElement可以知道&lt;video&gt;元素有没有处在全屏状态，从而判断用户行为。 节点集合属性以下属性返回一个HTMLCollection实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。 （1）document.linksdocument.links属性返回当前文档所有设定了href属性的&lt;a&gt;及&lt;area&gt;节点。 12345// 打印文档所有的链接var links = document.links;for(var i = 0; i &lt; links.length; i++) &#123; console.log(links[i]);&#125; （2）document.formsdocument.forms属性返回所有&lt;form&gt; 表单节点。 1var selectForm = document.forms[0]; 上面代码获取文档第一个表单。 除了使用位置序号，id属性和name属性也可以用来引用表单。 12345/* HTML 代码如下 &lt;form name=&quot;foo&quot; id=&quot;bar&quot;&gt;&lt;/form&gt;*/document.forms[0] === document.forms.foo // truedocument.forms.bar === document.forms.foo // true （3）document.imagesdocument.images属性返回页面所有图片节点。 1234567var imglist = document.images;for(var i = 0; i &lt; imglist.length; i++) &#123; if (imglist[i].src === &apos;banner.gif&apos;) &#123; // ... &#125;&#125; 上面代码在所有img标签中，寻找某张图片。 （4）document.embeds，document.pluginsdocument.embeds属性和document.plugins属性，都返回所有&lt;embed&gt;节点。 （5）document.scriptsdocument.scripts属性返回所有&lt;script&gt;节点。 1234var scripts = document.scripts;if (scripts.length !== 0 ) &#123; console.log(&apos;当前网页有脚本&apos;);&#125; （6）document.styleSheetsdocument.styleSheets属性返回文档内嵌或引入的样式表集合 （7）小结除了document.styleSheets，以上的集合属性返回的都是HTMLCollection实例。 12345document.links instanceof HTMLCollection // truedocument.images instanceof HTMLCollection // truedocument.forms instanceof HTMLCollection // truedocument.embeds instanceof HTMLCollection // truedocument.scripts instanceof HTMLCollection // true HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。 123// HTML 代码如下// &lt;form name=&quot;myForm&quot;&gt;document.myForm === document.forms.myForm // true 文档静态信息属性以下属性返回文档信息。 （1）document.documentURI，document.URLdocument.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；URL继承自HTMLDocument接口，只能用于 HTML 文档。 12345document.URL// http://www.example.com/aboutdocument.documentURI === document.URL// true 如果文档的锚点（#anchor）变化，这两个属性都会跟着变化。 （2）document.domaindocument.domain属性返回当前文档的域名，不包含协议和接口。比如，网页的网址是http://www.example.com:80/hello.html，那么domain属性就等于www.example.com。如果无法获取域名，该属性返回null。 document.domain基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把document.domain设为对应的上级域名。比如，当前域名是a.sub.example.com，则document.domain属性可以设置为sub.example.com，也可以设为example.com。修改后，document.domain相同的两个网页，可以读取对方的资源，比如设置的 Cookie。 另外，设置document.domain会导致端口被改成null。因此，如果通过设置document.domain来进行通信，双方网页都必须设置这个值，才能保证端口相同。 （3）document.locationLocation对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。 （4）document.lastModifieddocument.lastModified属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。 12document.lastModified// &quot;03/07/2018 11:18:27&quot; 注意，document.lastModified属性的值是字符串，所以不能直接用来比较。Date.parse方法将其转为Date实例，才能比较两个网页。 1234var lastVisitedDate = Date.parse(&apos;01/01/2018&apos;);if (Date.parse(document.lastModified) &gt; lastVisitedDate) &#123; console.log(&apos;网页已经变更&apos;);&#125; 如果页面上有 JavaScript 生成的内容，document.lastModified属性返回的总是当前时间。 （5）document.titledocument.title属性返回当前文档的标题。默认情况下，返回&lt;title&gt;节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。 12document.title = &apos;新标题&apos;;document.title // &quot;新标题&quot; （6）document.characterSetdocument.characterSet属性返回当前文档的编码，比如UTF-8、ISO-8859-1等等。 （7）document.referrerdocument.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。 12document.referrer// &quot;https://example.com/path&quot; 如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，document.referrer返回一个空字符串。 document.referrer的值，总是与 HTTP 头信息的Referer字段保持一致。但是，document.referrer的拼写有两个r，而头信息的Referer字段只有一个r。 （8）document.dirdocument.dir返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。 ####（9）document.compatMode compatMode属性返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）。 一般来说，如果网页代码的第一行设置了明确的DOCTYPE（比如&lt;!doctype html&gt;），document.compatMode的值都为CSS1Compat。 文档状态属性（1）document.hiddendocument.hidden属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。 这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。 （2）document.visibilityStatedocument.visibilityState返回文档的可见状态。 它的值有四种可能。 visible：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。 hidden： 页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。 prerender：页面处于正在渲染状态，对于用于来说，该页面不可见。 unloaded：页面从内存里面卸载了。 这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。 （3）document.readyStatedocument.readyState属性返回当前文档的状态，共有三种可能的值。 loading：加载 HTML 代码阶段（尚未完成解析） interactive：加载外部资源阶段 complete：加载完成 这个属性变化的过程如下。 浏览器开始解析 HTML 文档，document.readyState属性等于loading。 浏览器遇到 HTML 文档中的&lt;script&gt;元素，并且没有async或defer属性，就暂停解析，开始执行脚本，这时document.readyState属性还是等于loading。 HTML 文档解析完成，document.readyState属性变成interactive。 浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，document.readyState属性变成complete。 下面的代码用来检查网页是否加载成功。 123456789101112// 基本检查if (document.readyState === &apos;complete&apos;) &#123; // ...&#125;// 轮询检查var interval = setInterval(function() &#123; if (document.readyState === &apos;complete&apos;) &#123; clearInterval(interval); // ... &#125;&#125;, 100); 另外，每次状态变化都会触发一个readystatechange事件。 document.cookiedocument.cookie属性用来操作浏览器 Cookie document.designModedocument.designMode属性控制当前文档是否可编辑。该属性只有两个值on和off，默认值为off。一旦设为on，用户就可以编辑整个文档的内容。 下面代码打开iframe元素内部文档的designMode属性，就能将其变为一个所见即所得的编辑器。 1234// HTML 代码如下// &lt;iframe id=&quot;editor&quot; src=&quot;about:blank&quot;&gt;&lt;/iframe&gt;var editor = document.getElementById(&apos;editor&apos;);editor.contentDocument.designMode = &apos;on&apos;; document.implementationdocument.implementation属性返回一个DOMImplementation对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。 DOMImplementation.createDocument()：创建一个 XML 文档。 DOMImplementation.createHTMLDocument()：创建一个 HTML 文档。 DOMImplementation.createDocumentType()：创建一个 DocumentType 对象。 下面是创建 HTML 文档的例子。 123456789var doc = document.implementation.createHTMLDocument(&apos;Title&apos;);var p = doc.createElement(&apos;p&apos;);p.innerHTML = &apos;hello world&apos;;doc.body.appendChild(p);document.replaceChild( doc.documentElement, document.documentElement); 上面代码中，第一步生成一个新的 HTML 文档doc，然后用它的根元素document.documentElement替换掉document.documentElement。这会使得当前文档的内容全部消失，变成hello world。 方法document.open()，document.close()document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。 document.close方法用来关闭document.open()打开的文档。 123document.open();document.write(&apos;hello world&apos;);document.close(); document.write()，document.writeln()document.write方法用于向当前文档写入内容。 在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行document.close()），document.write写入的内容就会追加在已有内容的后面。 12345// 页面显示“helloworld”document.open();document.write(&apos;hello&apos;);document.write(&apos;world&apos;);document.close(); 注意，document.write会当作 HTML 代码解析，不会转义。 1document.write(&apos;&lt;p&gt;hello world&lt;/p&gt;&apos;); 上面代码中，document.write会将&lt;p&gt;当作 HTML 标签解释。 如果页面已经解析完成（DOMContentLoaded事件发生之后），再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。 12345678910document.addEventListener(&apos;DOMContentLoaded&apos;, function (event) &#123; document.write(&apos;&lt;p&gt;Hello World!&lt;/p&gt;&apos;);&#125;);// 等同于document.addEventListener(&apos;DOMContentLoaded&apos;, function (event) &#123; document.open(); document.write(&apos;&lt;p&gt;Hello World!&lt;/p&gt;&apos;); document.close();&#125;); 如果在页面渲染过程中调用write方法，并不会自动调用open方法。（可以理解成，open方法已调用，但close方法还未调用。） 12345678&lt;html&gt;&lt;body&gt;hello&lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;world&quot;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器打开上面网页，将会显示hello world。 document.write是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对innerHTML属性赋值）。所以，除了某些特殊情况，应该尽量避免使用document.write这个方法。 document.writeln方法与write方法完全一致，除了会在输出内容的尾部添加换行符。 123456789document.write(1);document.write(2);// 12document.writeln(1);document.writeln(2);// 1// 2// 注意，writeln方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入&lt;br&gt;。 document.querySelector()，document.querySelectorAll()document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。 12var el1 = document.querySelector(&apos;.myclass&apos;);var el2 = document.querySelector(&apos;#myParent &gt; [ng-click]&apos;); document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。 1234elementList = document.querySelectorAll(&apos;.myclass&apos;);``` 这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。 var matches = document.querySelectorAll(‘div.note, div.alert’);1234上面代码返回`class`属性是`note`或`alert`的`div`元素。这两个方法都支持复杂的 CSS 选择器。 // 选中 data-foo-bar 属性等于 someval 的元素document.querySelectorAll(‘[data-foo-bar=”someval”]’); // 选中 myForm 表单中所有不通过验证的元素document.querySelectorAll(‘#myForm :invalid’); // 选中div元素，那些 class 含 ignore 的除外document.querySelectorAll(‘DIV:not(.ignore)’); // 同时选中 div，a，script 三类元素document.querySelectorAll(‘DIV, A, SCRIPT’);12345678910但是，它们不支持 CSS 伪元素的选择器（比如`:first-line`和`:first-letter`）和伪类的选择器（比如`:link`和`:visited`），即无法选中伪元素和伪类。如果`querySelectorAll`方法的参数是字符串`*`，则会返回文档中的所有元素节点。另外，`querySelectorAll`的返回结果不是动态集合，不会实时反映元素节点的变化。最后，这两个方法除了定义在`document`对象上，还定义在元素节点上，即在元素节点上也可以调用。### document.getElementsByTagName()`document.getElementsByTagName`方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（`HTMLCollection`实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。 var paras = document.getElementsByTagName(‘p’);paras instanceof HTMLCollection // true123456上面代码返回当前文档的所有`p`元素节点。HTML 标签名是大小写不敏感的，因此`getElementsByTagName`方法也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。如果传入`*`，就可以返回文档中所有 HTML 元素。 var allElements = document.getElementsByTagName(‘*’);12注意，元素节点本身也定义了`getElementsByTagName`方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在`document`对象上调用，也可以在任何元素节点上调用。 var firstPara = document.getElementsByTagName(‘p’)[0];var spans = firstPara.getElementsByTagName(‘span’);123456上面代码选中第一个`p`元素内部的所有`span`元素。### document.getElementsByClassName()`document.getElementsByClassName`方法返回一个类似数组的对象（`HTMLCollection`实例），包括了所有`class`名字符合指定条件的元素，元素的变化实时反映在返回结果中。 var elements = document.getElementsByClassName(names);1234由于`class`是保留字，所以 JavaScript 一律使用`className`表示 CSS 的`class`。参数可以是多个`class`，它们之间使用空格分隔。 var elements = document.getElementsByClassName(‘foo bar’);12345678910上面代码返回同时具有`foo`和`bar`两个`class`的元素，`foo`和`bar`的顺序不重要。注意，正常模式下，CSS 的`class`是大小写敏感的。（`quirks mode`下，大小写不敏感。）与`getElementsByTagName`方法一样，`getElementsByClassName`方法不仅可以在`document`对象上调用，也可以在任何元素节点上调用。### document.getElementsByName() `document.getElementsByName`方法用于选择拥有`name`属性的 HTML 元素（比如`&lt;form&gt;`、`&lt;radio&gt;`、`&lt;img&gt;`、`&lt;frame&gt;`、`&lt;embed&gt;`和`&lt;object&gt;`等），返回一个类似数组的的对象（`NodeList`实例），因为`name`属性相同的元素可能不止一个。 // 表单为 var forms = document.getElementsByName(‘x’);forms[0].tagName // “FORM”1234### document.getElementById()`document.getElementById`方法返回匹配指定`id`属性的元素节点。如果没有发现匹配的节点，则返回`null`。 var elem = document.getElementById(‘para1’);1234注意，该方法的参数是大小写敏感的。比如，如果某个节点的`id`属性是`main`，那么`document.getElementById(&apos;Main&apos;)`将返回`null`。`document.getElementById`方法与`document.querySelector`方法都能获取元素节点，不同之处是`document.querySelector`方法的参数使用 CSS 选择器语法，`document.getElementById`方法的参数是元素的`id`属性。 document.getElementById(‘myElement’)document.querySelector(‘#myElement’)12345678上面代码中，两个方法都能选中`id`为`myElement`的元素，但是`document.getElementById()`比`document.querySelector()`效率高得多。另外，这个方法只能在`document`对象上使用，不能在其他元素节点上使用。### document.elementFromPoint()，document.elementsFromPoint() `document.elementFromPoint`方法返回位于页面指定位置最上层的元素节点。 var element = document.elementFromPoint(50, 50);123456上面代码选中在(50, 50)这个坐标位置的最上层的那个 HTML 元素。elementFromPoint方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回null。document.elementsFromPoint()返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。 var elements = document.elementsFromPoint(x, y);1234### document.caretPositionFromPoint()`document.caretPositionFromPoint()`返回一个 `CaretPosition` 对象，包含了指定坐标点在节点对象内部的位置信息。`CaretPosition` 对象就是光标插入点的概念，用于确定光标点在文本对象内部的具体位置。 var range = document.caretPositionFromPoint(clientX, clientY);12345678910上面代码中，`range`是指定坐标点的 `CaretPosition` 对象。该对象有两个属性。- CaretPosition.offsetNode：该位置的节点对象- CaretPosition.offset：该位置在offsetNode对象内部，与起始位置相距的字符数。### document.createElement()`document.createElement`方法用来生成元素节点，并返回该节点。 var newDiv = document.createElement(‘div’);12`createElement`方法的参数为元素的标签名，即元素节点的`tagName`属性，对于 HTML 网页大小写不敏感，即参数为`div`或`DIV`返回的是同一种节点。如果参数里面包含尖括号（即`&lt;`和`&gt;`）会报错。 document.createElement(‘‘);// DOMException: The tag name provided (‘‘) is not a valid name12注意，`document.createElement`的参数可以是自定义的标签名。 document.createElement(‘foo’);1234### document.createTextNode()`document.createTextNode`方法用来生成文本节点（`Text`实例），并返回该节点。它的参数是文本节点的内容。 var newDiv = document.createElement(‘div’);var newContent = document.createTextNode(‘Hello’);newDiv.appendChild(newContent);1234上面代码新建一个`div`节点和一个文本节点，然后将文本节点插入`div`节点。这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。 var div = document.createElement(‘div’);div.appendChild(document.createTextNode(‘Foo &amp; bar‘));console.log(div.innerHTML)// &lt;span&gt;Foo &amp; bar&lt;/span&gt;1234上面代码中，`createTextNode`方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。 function escapeHtml(str) { var div = document.createElement(‘div’); div.appendChild(document.createTextNode(str)); return div.innerHTML;}; var userWebsite = ‘“ onmouseover=”alert(\\’derp\\’)” “‘;var profileLink = ‘Bob‘;var div = document.getElementById(‘target’);div.innerHTML = profileLink;// Bob123456上面代码中，由于`createTextNode`方法不转义双引号，导致`onmouseover`方法被注入了代码。### document.createAttribute() `document.createAttribute`方法生成一个新的属性节点（`Attr`实例），并返回它。 var attribute = document.createAttribute(name);12`document.createAttribute`方法的参数`name`，是属性的名称。 var node = document.getElementById(‘div1’); var a = document.createAttribute(‘my_attrib’);a.value = ‘newVal’; node.setAttributeNode(a);// 或者node.setAttribute(‘my_attrib’, ‘newVal’);123456上面代码为`div1`节点，插入一个值为`newVal`的`my_attrib`属性。### document.createComment() `document.createComment`方法生成一个新的注释节点，并返回该节点。 var CommentNode = document.createComment(data);`","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://akitsukiwong.github.io/tags/js/"}]},{"title":"面向对象编程","slug":"面向对象编程","date":"2018-09-29T00:46:17.000Z","updated":"2021-02-26T16:49:29.488Z","comments":true,"path":"2018/09/29/面向对象编程/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/29/面向对象编程/","excerpt":"","text":"面向对象编程 实例对象与 new 命令 this 关键字 对象的继承 Object 对象的相关方法 严格模式 实例对象与 new 命令JavaScript 语言具有很强的面向对象编程能力，本章介绍 JavaScript 面向对象编程的基础知识。 1. 对象是什么面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。 那么，“对象”（object）到底是什么？我们从两个层次来理解。 （1）对象是单个实物的抽象。 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 （2）对象是一个容器，封装了属性（property）和方法（method）。 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 2. 构造函数面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。 JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。 构造函数就是一个普通的函数，但是有自己的特征和用法。 123var Vehicle = function () &#123; this.price = 1000;&#125;; 上面代码中，Vehicle 就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。 构造函数的特点有两个。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。 下面先介绍new命令。 3. new 命令3.1 基本用法new 命令的作用，就是执行构造函数，返回一个实例对象。 123456var Vehicle = function () &#123; this.price = 1000;&#125;;var v = new Vehicle();v.price // 1000 上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle得到了price属性。new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，值是1000。 使用new命令时，根据需要，构造函数也可以接受参数。 12345var Vehicle = function (p) &#123; this.price = p;&#125;;var v = new Vehicle(500); new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。 1234// 推荐的写法var v = new Vehicle();// 不推荐的写法var v = new Vehicle; 一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？ 这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。 1234567var Vehicle = function ()&#123; this.price = 1000;&#125;;var v = Vehicle();v // undefinedprice // 1000 上面代码中，调用Vehicle构造函数时，忘了加上new命令。结果，变量v变成了undefined，而price属性变成了全局变量。因此，应该非常小心，避免不使用new命令、直接调用构造函数。 为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。 12345678function Fubar(foo, bar)&#123; &apos;use strict&apos;; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError: Cannot set property &apos;_foo&apos; of undefined 上面代码的Fubar为构造函数，use strict命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的this不能指向全局对象，默认等于undefined，导致不加new调用会报错（JavaScript 不允许对undefined添加属性）。 另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。 1234567891011function Fubar(foo, bar) &#123; if (!(this instanceof Fubar)) &#123; return new Fubar(foo, bar); &#125; this._foo = foo; this._bar = bar;&#125;Fubar(1, 2)._foo // 1(new Fubar(1, 2))._foo // 1 上面代码中的构造函数，不管加不加new命令，都会得到同样的结果。 3.2 new 命令的原理使用new命令时，它后面的函数依次执行下面的步骤。 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。 1234567var Vehicle = function () &#123; this.price = 1000; return 1000;&#125;;(new Vehicle()) === 1000// false 上面代码中，构造函数Vehicle的return语句返回一个数值。这时，new命令就会忽略这个return语句，返回“构造”后的this对象。 但是，如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。 1234567var Vehicle = function ()&#123; this.price = 1000; return &#123; price: 2000 &#125;;&#125;;(new Vehicle()).price// 2000 上面代码中，构造函数Vehicle的return语句，返回的是一个新对象。new命令会返回这个对象，而不是this对象。 另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。 12345678function getMessage() &#123; return &apos;this is a message&apos;;&#125;var msg = new getMessage();msg // &#123;&#125;typeof msg // &quot;object&quot; 上面代码中，getMessage是一个普通函数，返回一个字符串。对它使用new命令，会得到一个空对象。这是因为new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。本例中，return语句返回的是字符串，所以new命令就忽略了该语句。 new命令简化的内部流程，可以用下面的代码表示。 123456789101112131415function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) &#123; // 将 arguments 对象转为数组 var args = [].slice.call(arguments); // 取出构造函数 var constructor = args.shift(); // 创建一个空对象，继承构造函数的 prototype 属性 var context = Object.create(constructor.prototype); // 执行构造函数 var result = constructor.apply(context, args); // 如果返回结果是对象，就直接返回，否则返回 context 对象 return (typeof result === &apos;object&apos; &amp;&amp; result != null) ? result : context;&#125;// 实例var actor = _new(Person, &apos;张三&apos;, 28); 3.3 new.target函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。 123456function f() &#123; console.log(new.target === f);&#125;f() // falsenew f() // true 使用这个属性，可以判断函数调用的时候，是否使用new命令。 12345678function f() &#123; if (!new.target) &#123; throw new Error(&apos;请使用 new 命令调用！&apos;); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ 上面代码中，构造函数f调用时，没有使用new命令，就抛出一个错误。 4. Object.create() 创建实例对象构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。 123456789101112var person1 = &#123; name: &apos;张三&apos;, age: 38, greeting: function() &#123; console.log(&apos;Hi! I\\&apos;m &apos; + this.name + &apos;.&apos;); &#125;&#125;;var person2 = Object.create(person1);person2.name // 张三person2.greeting() // Hi! I&apos;m 张三. 上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法。 this 关键字1. 涵义this关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。 前一章已经提到，this可以用在构造函数之中，表示实例对象。除此之外，this还可以用在别的场合。但不管是什么场合，this都有一个共同点：它总是返回一个对象。 简单说，this就是属性或方法“当前”所在的对象。 1this.property 上面代码中，this就代表property属性当前所在的对象。 下面是一个实际的例子。 123456789var person = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;person.describe()// &quot;姓名：张三&quot; 上面代码中，this.name表示name属性所在的那个对象。由于this.name是在describe方法中调用，而describe方法所在的当前对象是person，因此this指向person，this.name就是person.name。 由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。 1234567891011121314var A = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var B = &#123; name: &apos;李四&apos;&#125;;B.describe = A.describe;B.describe()// &quot;姓名：李四&quot; 上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。 稍稍重构这个例子，this的动态指向就能看得更清楚。 12345678910111213141516function f() &#123; return &apos;姓名：&apos;+ this.name;&#125;var A = &#123; name: &apos;张三&apos;, describe: f&#125;;var B = &#123; name: &apos;李四&apos;, describe: f&#125;;A.describe() // &quot;姓名：张三&quot;B.describe() // &quot;姓名：李四&quot; 上面代码中，函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。 只要函数被赋给另一个变量，this的指向就会变。 12345678910var A = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var name = &apos;李四&apos;;var f = A.describe;f() // &quot;姓名：李四&quot; 上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。 再看一个网页编程的例子。 12345678&lt;input type=&quot;text&quot; name=&quot;age&quot; size=3 onChange=&quot;validate(this, 18, 99);&quot;&gt;&lt;script&gt;function validate(obj, lowval, hival)&#123; if ((obj.value &lt; lowval) || (obj.value &gt; hival)) console.log(&apos;Invalid Value!&apos;);&#125;&lt;/script&gt; 上面代码是一个文本输入框，每当用户输入一个值，就会调用onChange回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此this就代表传入当前对象（即文本框），然后就可以从this.value上面读到用户的输入值。 总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。 2. 实质JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。 1var obj = &#123; foo: 5 &#125;; 上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。 12345678&#123; foo: &#123; [[value]]: 5 [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125; 注意，foo属性的值保存在属性描述对象的value属性里面。 这样的结构是很清晰的，问题在于属性的值可能是一个函数。 1var obj = &#123; foo: function () &#123;&#125; &#125;; 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。 123456&#123; foo: &#123; [[value]]: 函数的地址 ... &#125;&#125; 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f = function () &#123;&#125;;var obj = &#123; f: f &#125;;// 单独执行f()// obj 环境执行obj.f() JavaScript 允许在函数体内部，引用当前环境的其他变量。 123var f = function () &#123; console.log(x);&#125;; 上面代码中，函数体里面使用了变量x。该变量由运行环境提供。 现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 123var f = function () &#123; console.log(this.x);&#125; 上面代码中，函数体里面的this.x就是指当前运行环境的x。 123456789101112131415var f = function () &#123; console.log(this.x);&#125;var x = 1;var obj = &#123; f: f, x: 2,&#125;;// 单独执行f() // 1// obj 环境执行obj.f() // 2 上面代码中，函数f在全局环境执行，this.x指向全局环境的x；在obj环境执行，this.x指向obj.x。 3. 使用场合this主要有以下几个使用场合。 （1）全局环境 全局环境使用this，它指的就是顶层对象window。 123456this === window // truefunction f() &#123; console.log(this === window);&#125;f() // true 上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。 （2）构造函数 构造函数中的this，指的是实例对象。 123var Obj = function (p) &#123; this.p = p;&#125;; 上面代码定义了一个构造函数Obj。由于this指向实例对象，所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性。 12var o = new Obj(&apos;Hello World!&apos;);o.p // &quot;Hello World!&quot; （3）对象的方法 如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。 但是，这条规则很不容易把握。请看下面的代码。 1234567var obj =&#123; foo: function () &#123; console.log(this); &#125;&#125;;obj.foo() // obj 上面代码中，obj.foo方法执行时，它内部的this指向obj。 但是，下面这几种用法，都会改变this的指向。 123456// 情况一(obj.foo = obj.foo)() // window// 情况二(false || obj.foo)() // window// 情况三(1, obj.foo)() // window 上面代码中，obj.foo就是一个值。这个值真正调用的时候，运行环境已经不是obj了，而是全局环境，所以this不再指向obj。 可以这样理解，JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二。obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境。上面三种情况等同于下面的代码。 123456789101112131415161718// 情况一(obj.foo = function () &#123; console.log(this);&#125;)()// 等同于(function () &#123; console.log(this);&#125;)()// 情况二(false || function () &#123; console.log(this);&#125;)()// 情况三(1, function () &#123; console.log(this);&#125;)() 如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。 12345678910var a = &#123; p: &apos;Hello&apos;, b: &#123; m: function() &#123; console.log(this.p); &#125; &#125;&#125;;a.b.m() // undefined 上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b，因为实际执行的是下面的代码。 123456789101112var b = &#123; m: function() &#123; console.log(this.p); &#125;&#125;;var a = &#123; p: &apos;Hello&apos;, b: b&#125;;(a.b).m() // 等同于 b.m() 如果要达到预期效果，只有写成下面这样。 12345678var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: &apos;Hello&apos; &#125;&#125;; 如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。 1234567891011var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: &apos;Hello&apos; &#125;&#125;;var hello = a.b.m;hello() // undefined 上面代码中，m是多层对象内部的一个方法。为求简便，将其赋值给hello变量，结果调用时，this指向了顶层对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。 12var hello = a.b;hello.m() // Hello 4. 使用注意点4.1 避免多层 this由于this的指向是不确定的，所以切勿在函数中包含多层的this。 123456789101112var o = &#123; f1: function () &#123; console.log(this); var f2 = function () &#123; console.log(this); &#125;(); &#125;&#125;o.f1()// Object// Window 上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。 12345678910var temp = function () &#123; console.log(this);&#125;;var o = &#123; f1: function () &#123; console.log(this); var f2 = temp(); &#125;&#125; 一个解决方法是在第二层改用一个指向外层this的变量。 12345678910111213var o = &#123; f1: function() &#123; console.log(this); var that = this; var f2 = function() &#123; console.log(that); &#125;(); &#125;&#125;o.f1()// Object// Object 上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。 事实上，使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。 JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。 12345678910var counter = &#123; count: 0&#125;;counter.inc = function () &#123; &apos;use strict&apos;; this.count++&#125;;var f = counter.inc;f()// TypeError: Cannot read property &apos;count&apos; of undefined 上面代码中，inc方法通过’use strict’声明采用严格模式，这时内部的this一旦指向顶层对象，就会报错。 4.2 避免数组处理方法中的 this数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。 12345678910111213var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + &apos; &apos; + item); &#125;); &#125;&#125;o.f()// undefined a1// undefined a2 上面代码中，foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。原因跟上一段的多层this是一样的，就是内层的this不指向外部，而指向顶层对象。 解决这个问题的一种方法，就是前面提到的，使用中间变量固定this。 1234567891011121314var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; var that = this; this.p.forEach(function (item) &#123; console.log(that.v+&apos; &apos;+item); &#125;); &#125;&#125;o.f()// hello a1// hello a2 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。 12345678910111213var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + &apos; &apos; + item); &#125;, this); &#125;&#125;o.f()// hello a1// hello a2 4.3 避免回调函数中的 this回调函数中的this往往会改变指向，最好避免使用。 1234567var o = new Object();o.f = function () &#123; console.log(this === o);&#125;// jQuery 的写法$(&apos;#button&apos;).on(&apos;click&apos;, o.f); 上面代码中，点击按钮以后，控制台会显示false。原因是此时this不再指向o对象，而是指向按钮的 DOM 对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。 为了解决这个问题，可以采用下面的一些方法对this进行绑定，也就是使得this固定指向某个对象，减少不确定性。 5. 绑定 this 的方法this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。 5.1 Function.prototype.call()函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 12345678var obj = &#123;&#125;;var f = function () &#123; return this;&#125;;f() === window // truef.call(obj) === obj // true 上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。 call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。 123456789101112var n = 123;var obj = &#123; n: 456 &#125;;function a() &#123; console.log(this.n);&#125;a.call() // 123a.call(null) // 123a.call(undefined) // 123a.call(window) // 123a.call(obj) // 456 上面代码中，a函数中的this关键字，如果指向全局对象，返回结果为123。如果使用call方法将this关键字指向obj对象，返回结果为456。可以看到，如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象。 如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。 123456var f = function () &#123; return this;&#125;;f.call(5)// Number &#123;[[PrimitiveValue]]: 5&#125; 上面代码中，call的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定f内部的this。 call方法还可以接受多个参数。 1func.call(thisValue, arg1, arg2, ...) call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。 12345function add(a, b) &#123; return a + b;&#125;add.call(this, 1, 2) // 3 上面代码中，call方法指定函数add内部的this绑定当前环境（对象），并且参数为1和2，因此函数add运行后得到3。 call方法的一个应用是调用对象的原生方法。 12345678910var obj = &#123;&#125;;obj.hasOwnProperty(&apos;toString&apos;) // false// 覆盖掉继承的 hasOwnProperty 方法obj.hasOwnProperty = function () &#123; return true;&#125;;obj.hasOwnProperty(&apos;toString&apos;) // trueObject.prototype.hasOwnProperty.call(obj, &apos;toString&apos;) // false 上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。 5.2 Function.prototype.apply()apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。 1func.apply(thisValue, [arg1, arg2, ...]) apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。 123456function f(x, y)&#123; console.log(x + y);&#125;f.call(null, 1, 1) // 2f.apply(null, [1, 1]) // 2 上面代码中，f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。 利用这一点，可以做一些有趣的应用。 （1）找出数组最大元素 JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。 12var a = [10, 2, 4, 15, 9];Math.max.apply(null, a) // 15 （2）将数组的空元素变为undefined 通过apply方法，利用Array构造函数将数组的空元素变成undefined。 12Array.apply(null, [&apos;a&apos;, ,&apos;b&apos;])// [ &apos;a&apos;, undefined, &apos;b&apos; ] 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 1234567891011121314var a = [&apos;a&apos;, , &apos;b&apos;];function print(i) &#123; console.log(i);&#125;a.forEach(print)// a// bArray.apply(null, a).forEach(print)// a// undefined// b （3）转换类似数组的对象 另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。 1234Array.prototype.slice.apply(&#123;0: 1, length: 1&#125;) // [1]Array.prototype.slice.apply(&#123;0: 1&#125;) // []Array.prototype.slice.apply(&#123;0: 1, length: 2&#125;) // [1, undefined]Array.prototype.slice.apply(&#123;length: 1&#125;) // [undefined] 上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。 （4）绑定回调函数的对象 前面的按钮点击事件的例子，可以改写如下。 12345678910111213var o = new Object();o.f = function () &#123; console.log(this === o);&#125;var f = function ()&#123; o.f.apply(o); // 或者 o.f.call(o);&#125;;// jQuery 的写法$(&apos;#button&apos;).on(&apos;click&apos;, f); 上面代码中，点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。 5.3 Function.prototype.bind()bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 12345var d = new Date();d.getTime() // 1481869925657var print = d.getTime;print() // Uncaught TypeError: this is not a Date object. 上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。 bind方法可以解决这个问题。 12var print = d.getTime.bind(d);print() // 1481869925657 上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。 bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。 12345678910var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc.bind(counter);func();counter.count // 1 上面代码中，counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。 this绑定到其他对象也是可以的。 12345678910111213var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var obj = &#123; count: 100&#125;;var func = counter.inc.bind(obj);func();obj.count // 101 上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。 bind还可以接受更多的参数，将这些参数绑定原函数的参数。 1234567891011var add = function (x, y) &#123; return x * this.m + y * this.n;&#125;var obj = &#123; m: 2, n: 2&#125;;var newAdd = add.bind(obj, 5);newAdd(5) // 20 上面代码中，bind方法除了绑定this对象，还将add函数的第一个参数x绑定成5，然后返回一个新函数newAdd，这个函数只要再接受一个参数y就能运行了。 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）。 123456function add(x, y) &#123; return x + y;&#125;var plus5 = add.bind(null, 5);plus5(10) // 15 上面代码中，函数add内部并没有this，使用bind方法的主要目的是绑定参数x，以后每次运行新函数plus5，就只需要提供另一个参数y就够了。而且因为add内部没有this，所以bind的第一个参数是null，不过这里如果是其他对象，也没有影响。 bind方法有一些使用注意点。 （1）每一次返回一个新函数 bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。 1element.addEventListener(&apos;click&apos;, o.m.bind(o)); 上面代码中，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。 1element.removeEventListener(&apos;click&apos;, o.m.bind(o)); 正确的方法是写成下面这样： 1234var listener = o.m.bind(o);element.addEventListener(&apos;click&apos;, listener);// ...element.removeEventListener(&apos;click&apos;, listener); （2）结合回调函数使用 回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。解决方法就是使用bind方法，将counter.inc绑定counter。 1234567891011121314var counter = &#123; count: 0, inc: function () &#123; &apos;use strict&apos;; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 上面代码中，callIt方法会调用回调函数。这时如果直接把counter.inc传入，调用时counter.inc内部的this就会指向全局对象。使用bind方法将counter.inc绑定counter以后，就不会有这个问题，this总是指向counter。 还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。 123456789101112var obj = &#123; name: &apos;张三&apos;, times: [1, 2, 3], print: function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;); &#125;&#125;;obj.print()// 没有任何输出 上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。 12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this === window); &#125;);&#125;;obj.print()// true// true// true 解决这个问题，也是通过bind方法绑定this。 12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;.bind(this));&#125;;obj.print()// 张三// 张三// 张三 （3）结合call方法使用 利用bind方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的slice方法为例。 123[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1] 上面的代码中，数组的slice方法从[1, 2, 3]里面，按照指定位置和长度切分出另一个数组。这样做的本质是在[1, 2, 3]上面调用Array.prototype.slice方法，因此可以用call方法表达这个过程，得到同样的结果。 call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写。 12var slice = Function.prototype.call.bind(Array.prototype.slice);slice([1, 2, 3], 0, 1) // [1] 上面代码的含义就是，将Array.prototype.slice变成Function.prototype.call方法所在的对象，调用时就变成了Array.prototype.slice.call。类似的写法还可以用于其他数组方法。 123456789var push = Function.prototype.call.bind(Array.prototype.push);var pop = Function.prototype.call.bind(Array.prototype.pop);var a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 如果再进一步，将Function.prototype.call方法绑定到Function.prototype.bind对象，就意味着bind的调用形式也可以被改写。 1234567function f() &#123; console.log(this.v);&#125;var o = &#123; v: 123 &#125;;var bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123 上面代码的含义就是，将Function.prototype.bind方法绑定在Function.prototype.call上面，所以bind方法就可以直接使用，不需要在函数实例上使用。","categories":[],"tags":[]},{"title":"nginx反向代理","slug":"nginx反向代理","date":"2018-09-29T00:45:22.000Z","updated":"2021-02-26T16:49:29.481Z","comments":true,"path":"2018/09/29/nginx反向代理/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/29/nginx反向代理/","excerpt":"","text":"###nginx反向代理 1.下载nginx http://nginx.org/en/download.html 下载稳定版本，以nginx/Windows-1.12.2为例，直接下载 nginx-1.12.2.zip 2.启动nginx 有很多种方法启动nginx (1)直接双击nginx.exe，双击后一个黑色的弹窗一闪而过 (2)打开cmd命令窗口，切换到nginx解压目录下，输入命令 nginx.exe 或者 start nginx ，回车即可 3.检查nginx是否启动成功 直接在浏览器地址栏输入网址 http://localhost:80，回车，出现以下页面说明启动成功 反向代理1.定义 跨域是指a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是浏览器的限制。理解这一点很重要！！！ 2.跨域访问示例 假设有两个网站，A网站部署在：http://localhost:81 即本地ip端口81上；B网站部署在：http://localhost:82 即本地ip端口82上。 关于nginx的配置可以查看另一篇博文：http://www.cnblogs.com/renjing/p/6126284.html。找到nginx的配置文件“nginx.conf”，修改一下信息 123456789101112131415161718server &#123; listen 80; #监听80端口，可以改成其他端口 server_name localhost; # 当前服务的域名 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://localhost:81; proxy_redirect default; &#125; location /apis &#123; #添加访问目录为/apis的代理配置 rewrite ^/apis/(.*)$ /$1 break; proxy_pass http://localhost:82; &#125;#以下配置省略 配置解释： 1.由配置信息可知，我们让nginx监听localhost的80端口，网站A与网站B的访问都是经过localhost的80端口进行访问。 2.我们特殊配置了一个“/apis”目录的访问，并且对url执行了重写，最后使以“/apis”开头的地址都转到“http://localhost:82”进行处理。 3.rewrite ^/apis/(.*)$ /$1 break; 代表重写拦截进来的请求，并且只能对域名后边以“/apis”开头的起作用，例如www.a.com/apis/msg?x=1重写。只对/apis重写。 rewrite后面的参数是一个简单的正则 ^/apis/(.*)$ ,$1代表正则中的第一个(),$2代表第二个()的值,以此类推。 break代表匹配一个之后停止匹配。 访问地址修改 既然配置了nginx，那么所有的访问都要走nginx，而不是走网站原本的地址（A网站localhost:81,B网站localhost:82）。所以要修改A网站中的ajax访问地址，把访问地址由 “http://localhost:82/api/values”改成》》》“/apis/api/values”。","categories":[],"tags":[]},{"title":"webpack之proxyTable设置跨域","slug":"webpack之proxyTable设置跨域","date":"2018-09-29T00:44:03.000Z","updated":"2021-02-26T16:49:29.483Z","comments":true,"path":"2018/09/29/webpack之proxyTable设置跨域/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/29/webpack之proxyTable设置跨域/","excerpt":"","text":"###webpack之proxyTable设置跨域 使用vue-cli搭建的vue项目可以使用在项目内设置代理（proxyTable）的方式来解决跨域问题。 123456789proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://www.ykt.com/&apos;,//接口域名 changeOrigin: true,//是否跨域 pathRewrite: &#123; &apos;^/api&apos;: &apos;/index/index&apos;//需要rewrite重写 &#125; &#125; &#125; 实现效果： 1localhost:8080/api/getbuildcate ===&gt; www.ykt.com/index/index/getbuildcate","categories":[],"tags":[]},{"title":"SPA （单页应用程序）","slug":"SPA-（单页应用程序）","date":"2018-09-29T00:42:59.000Z","updated":"2021-02-26T16:49:29.478Z","comments":true,"path":"2018/09/29/SPA-（单页应用程序）/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/29/SPA-（单页应用程序）/","excerpt":"","text":"#SPA （单页应用程序） 先简单复制粘贴一下什么是SPA 百度百科单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 应用介绍单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。 特点速度：更好的用户体验，让用户在web app感受native app的速度和流畅， MVVM：经典MVVM开发模式，前后端各负其责。 ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交。 路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载。 笔记初次学习vue-cli做的SPA代码在这 记个笔记 一. 流程1. 全局安装 vue-cli1npm install -g vue-cli 2. 初始化1vue init webpack 项目名称 3. 安装模块1npm install 4. 启动服务器1npm run dev 5. 打包1npm run build","categories":[],"tags":[]},{"title":"JS语法专题","slug":"JS语法专题","date":"2018-09-29T00:40:19.000Z","updated":"2021-02-26T16:49:29.477Z","comments":true,"path":"2018/09/29/JS语法专题/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/29/JS语法专题/","excerpt":"","text":"https://wangdoc.com/javascript/features/index.html 语法专题 数据类型的转换 错误处理机制 编程风格 console 对象与控制台 数据类型的转换1. 概述JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。 1var x = y ? 1 : &apos;a&apos;; 上面代码中，变量x到底是数值还是字符串，取决于另一个变量y的值。y为true时，x是一个数值；y为false时，x是一个字符串。这意味着，x的类型没法在编译阶段就知道，必须等到运行时才能知道。 虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。 1&apos;4&apos; - &apos;3&apos; // 1 上面代码中，虽然是两个字符串相减，但是依然会得到结果数值1，原因就在于 JavaScript 将运算子自动转为了数值。 本章讲解数据类型自动转换的规则。在此之前，先讲解如何手动强制转换数据类型。 2. 强制转换强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。 2.1 Number()使用Number函数，可以将任意类型的值转化成数值。 下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。 （1）原始类型值 原始类型值的转换规则如下。 123456789101112131415161718192021// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&apos;324&apos;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&apos;324abc&apos;) // NaN// 空字符串转为0Number(&apos;&apos;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0 Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。 12parseInt(&apos;42 cats&apos;) // 42Number(&apos;42 cats&apos;) // NaN 上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。 另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 12parseInt(&apos;\\t\\v\\r12.34\\n&apos;) // 12Number(&apos;\\t\\v\\r12.34\\n&apos;) // 12.34 （2）对象 简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 123Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5 之所以会这样，是因为Number背后的转换规则比较复杂。 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 请看下面的例子。 123456789var obj = &#123;x: 1&#125;;Number(obj) // NaN// 等同于if (typeof obj.valueOf() === &apos;object&apos;) &#123; Number(obj.toString());&#125; else &#123; Number(obj.valueOf());&#125;","categories":[],"tags":[]},{"title":"函数式编程学习","slug":"函数式编程学习","date":"2018-09-24T07:10:00.000Z","updated":"2021-02-26T16:49:29.484Z","comments":true,"path":"2018/09/24/函数式编程学习/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/24/函数式编程学习/","excerpt":"","text":"什么是函数式编程函数式编程不是一种具体的工具，而是一种编写代码的方式 是一种强调以函数为主的软件开发风格","categories":[{"name":"学习","slug":"学习","permalink":"https://akitsukiwong.github.io/categories/学习/"}],"tags":[]},{"title":"插件","slug":"写插件教程","date":"2018-09-07T06:45:37.000Z","updated":"2021-02-26T16:49:29.484Z","comments":true,"path":"2018/09/07/写插件教程/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/07/写插件教程/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #demo-1, #demo-2 &#123; width: 200px; height: 200px; border: 1px solid #ddd; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;点击add可以添加个自input的内容到div里并实现变颜色&lt;/h3&gt; &lt;!--组件实例1--&gt; &lt;div id=&quot;demo-1&quot;&gt; &lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;好的&quot; /&gt; &lt;button id=&quot;add-1&quot;&gt;add&lt;/button&gt; &lt;/div&gt; &lt;br /&gt; &lt;br /&gt; &lt;!--组件实例2--&gt; &lt;div id=&quot;demo-2&quot;&gt; &lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;11&quot; /&gt; &lt;button id=&quot;add-2&quot;&gt;add&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //这里是插件的代码；我为了方便都写到一个html中了；请把这个script标签中的内容单独写在一个js文件里 //整个插件写在一个立即执行函数里；就是function()&#123;&#125;();函数自执行；保证里面的变量不会与外界互相影响 //头部的win啊,doc啊 $ 啊都是底部的window,document,jQuery的映射；方便内部直接调用； //当然你不引用jq的话头部的$和底部的jQuery干掉；你若引用了更过的依赖可以依次添加； //最后面的undefined可不写；最好写了；保证里面再出现的undefined是未定义的意思；不被其他东西赋值； //好了下面是时候展现真正的技术了 //function前的!号(叹号)或者;(分号)这不是写错了,为了防止那个二货写的js结束没有分号；而可能发生报错 /* ;function(win,doc,$,undefined)&#123; &#125;(window,document,jQuery) 或者写在一个闭包里(function()&#123; &#125;()) */ (function(win, doc, undefined) &#123; //我们随便写一个插件吧 比如你要点击按钮 添加input的值到 div里 var addHtml = function(demo, btn) &#123; //插件名，调用的时候直接new一下插件名就行了并传参数或者传对象(一般这个函数名手写字母大写比较好，构造函数嘛，其实也是函数) //很明显我要传id名；这里传什么都可以的其实； this.div = doc.getElementById(demo); //为什么把获取的id传给this.div呢？this的指向为调用的实例；我们此时姑且认为this就指向这个函数；因为这样我们之后再想获取这个div就可以直接用this.div了好吗；而不是在document.getElementById（。。。。） this.btn = doc.getElementById(btn); this.Input = this.div.getElementsByTagName(&quot;input&quot;)[0]; //既然找到了div我们在找下div下面的input；当然你要不input用获取id的形式传参数我没有意见 this.num = 0; //你也可以写一些其他的默认的东西；比如默认的变量啦；方便下面调用；这里写了什么都不会报错；只是有用没用的问题这行可以忽略 this.author = &quot;lianxiaozhuang&quot;; this.init(); //执行下你下面写的函数吧；你想想；如果整个插件没有执行函数；多不好；一堆方法function就不调用；对；这里是调用的时候最开始执行的函数 &#125; //；给构造函数addHtml对象原型里添加属性（方法） addHtml.prototype = &#123; //给函数写方法；这里可能不止一个函数；你还记得你在全局里写一个个的function吗；贼乱； //找也不好找；把一个个函数都写到对象的属性里；调用函数就直接调用对象的属性； constructor: addHtml, //构造器指向构造函数；这行其实不写没啥毛病；不过有时候防止构造器指向Object的情况；你还是装逼写上吧； init: function() &#123; //这里的init；你也可以写成 nimade:function()&#123; &#125;都没有问题；就是在addHtml函数里this.init();执行下；你明白了这里的this了吧；整个插件里this都是只得这个函数（实例）；除非你又引入了其他的函数里的（其他函数里的可能指向就是window了） var _self = this; ////把this保存下来防止在局部函数内部取不到（局部函数内部取得this可能是别的） this.btn.onclick = function() &#123; var _val = _self.Input.value; var tempdiv = doc.createElement(&quot;div&quot;); //创建临时div存放获取input的值 tempdiv.innerHTML = _val; //console.log(tempdiv); _self.div.appendChild(tempdiv); _self.setColor(); //你把所有方法都写在init里绝对没问题；还是那句话；说好的松耦合呢；说好的不写一堆堆的function一层层乱套呢 &#125;; &#125;, setColor: function() &#123; //console.log(this.div) this.div.style.color = &quot;red&quot; &#125; /*, otherFun()&#123; //当然你还可以扩展其他方法；这些方法之间都可以互相调用； 只要用this.方法名 就行了；如果在取不到this比如上面的click函数中的this指向点击的button；只要在写var _self = this;就可以用_self 代替this（函数实例）了；当然_self 也可以写成别的 比如$this等自定义的 &#125;*/ &#125; win.addHtml = addHtml; //把这个对象附给window底下的 名字叫addHtml的对象；要不你调用的时候 new addHtml() 怕在window的环境下找不到； &#125;(window, document)) &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; new addHtml(&quot;demo-1&quot;, &quot;add-1&quot;); //这里是实例1调用插件的代码 new addHtml(&quot;demo-2&quot;, &quot;add-2&quot;); //这里是实例2调用插件的代码 //是不是明白为什么要写插件了；要封装；两个相同组件即使有相同的class名在dom操作的时候也不会相互冲突；因为他们都new出来了个自的实例；有自己的this；有自己的一套方法了（其实方法都在原型里是公用的；操作各自的dom） &lt;/script&gt; &lt;!--这里是最简单的插件写法；当然还有传对象参数的插件等等。。。。--&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"ES6学习笔记","slug":"ES6学习笔记","date":"2018-09-07T01:26:41.000Z","updated":"2021-02-26T16:49:29.476Z","comments":true,"path":"2018/09/07/ES6学习笔记/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/07/ES6学习笔记/","excerpt":"","text":"ES6学习笔记ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准 let 和 const 命令1. let命令用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 2. 块级作用域为什么要使用块级作用域 ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域 let实际上为 JavaScript 新增了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 1&#123;&#123;&#123;&#123;&#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。 1234&#123;&#123;&#123;&#123; &#123;let insane = &apos;Hello World&apos;&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。 1234&#123;&#123;&#123;&#123; let insane = &apos;Hello World&apos;; &#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125;","categories":[],"tags":[]},{"title":"js数据类型","slug":"js数据类型","date":"2018-09-07T01:25:27.000Z","updated":"2021-02-26T16:49:29.480Z","comments":true,"path":"2018/09/07/js数据类型/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/07/js数据类型/","excerpt":"","text":"JS数据类型 概述 null，undefined 和布尔值 数值 字符串 对象 函数 数组 概述简介JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object） 数组（array） 函数（function） 狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。 typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof 运算符 instanceof 运算符 Object.prototype.toString 方法 instanceof运算符和Object.prototype.toString方法，将在后文介绍。这里介绍typeof运算符。 typeof运算符可以返回一个值的数据类型。 数值、字符串、布尔值分别返回number、string、boolean。 123typeof 123 // &quot;number&quot;typeof &apos;123&apos; // &quot;string&quot;typeof false // &quot;boolean&quot; 函数返回function。 123function f() &#123;&#125;typeof f// &quot;function&quot; undefined返回undefined。 12typeof undefined// &quot;undefined 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// &quot;undefined&quot; 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === &quot;undefined&quot;) &#123; // ...&#125; 对象返回object。 123typeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot; 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释。 12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true null返回object。 1typeof null // &quot;object&quot; null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。 null, undefined 和布尔值1. null 和 undefined1.1 概述null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 123var a = undefined;// 或者var a = null; 上面代码中，变量a分别被赋值为undefined和null，这两种写法的效果几乎等价。 在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log(&apos;undefined is false&apos;);&#125;// undefined is falseif (!null) &#123; console.log(&apos;null is false&apos;);&#125;// null is falseundefined == null// true 从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有null，没有undefined！ 既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。 1995年 JavaScript 诞生时，最初像 Java 一样，只设置了null表示”无”。根据 C 语言的传统，null可以自动转为0。 12Number(null) // 05 + null // 5 上面代码中，null转为数字时，自动变成0。 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，null就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果null自动转为0，很不容易发现错误。 因此，他又设计了一个undefined。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 12Number(undefined) // NaN5 + undefined // NaN 1.2 用法和含义对于null和undefined，大致可以像下面这样理解。 null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 2. 布尔值布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。 下列运算符会返回布尔值： 两元逻辑运算符：&amp;&amp; (And)，|| (Or) 前置逻辑运算符： !(Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 布尔值往往用于程序流程的控制，请看一个例子。 1234if (&apos;&apos;) &#123; console.log(&apos;true&apos;);&#125;// 没有任何输出 上面代码中，if命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出。 注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。 123456789if ([]) &#123; console.log(&apos;true&apos;);&#125;// trueif (&#123;&#125;) &#123; console.log(&apos;true&apos;);&#125;// true 数值1. 概述1.1 整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 123456780.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false 1.2 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位 1(-1)^符号位 * 1.xx...xx * 2^指数部分 上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。 精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。 1234567891011121314Math.pow(2, 53)// 9007199254740992 Math.pow(2, 53) + 1// 9007199254740992Math.pow(2, 53) + 2// 9007199254740994Math.pow(2, 53) + 3// 9007199254740996Math.pow(2, 53) + 4// 9007199254740996 上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。 123456Math.pow(2, 53)// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111// 9007199254740992000 上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。 1.3 数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 1Math.pow(2, -1075) // 0 下面是一个实际的例子 1234567var x = 0.5;for(var i = 0; i &lt; 25; i++) &#123; x = x * x;&#125;x // 0 上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 2. 数值的表示法JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。 数值也可以采用科学计数法表示，下面是几个科学计数法的例子。 1234123e3 // 123000123e-3 // 0.123-3.1E+12.1e-23 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。 （1）小数点前的数字多于21位。 123451234567890123456789012// 1.2345678901234568e+21123456789012345678901// 123456789012345680000 （2）小数点后的零多于5个。 123456// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003 // 3e-7// 否则，就保持原来的字面形式0.000003 // 0.000003 3. 数值的进制使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 1230xff // 2550o377 // 2550b11 // 3 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 1230xzz // 报错0o88 // 报错0b22 // 报错 上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。 通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。 120888 // 8880777 // 511 前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 4.特殊数值JavaScript 提供了几个特殊的数值。 4.1 正零和负零前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连0也不例外。 JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。 123-0 === +0 // true0 === -0 // true0 === +0 // true 几乎所有场合，正零和负零都会被当作正常的0。 1234+0 // 0-0 // 0(-0).toString() // &apos;0&apos;(+0).toString() // &apos;0&apos; 唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。 1(1 / +0) === (1 / -0) // false 上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的（关于Infinity详见下文）。 4.2 NaN4.2.1 含义NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 15 - &apos;x&apos; // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 10 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // &apos;number&apos; 4.2.2 运算规则NaN不等于任何值，包括它本身。 1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。 1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。 1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN 4.3 Infinity4.3.1 含义Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 1234567// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity 上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回Infinity。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。 1234Infinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity 上面代码中，非零正数除以-0，会得到-Infinity，负数除以-0，会得到Infinity。 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。 Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。 12Infinity &gt; 1000 // true-Infinity &lt; -1000 // true Infinity与NaN比较，总是返回false。 12345Infinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false 4.3.2 运算规则Infinity的四则运算，符合无穷的数学计算规则。 12345 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。 1230 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity Infinity加上或乘以Infinity，返回的还是Infinity。 12Infinity + Infinity // InfinityInfinity * Infinity // Infinity Infinity减去或除以Infinity，得到NaN。 12Infinity - Infinity // NaNInfinity / Infinity // NaN Infinity与null计算时，null会转成0，等同于与0的计算。 123null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity Infinity与undefined计算，返回的都是NaN。 12345undefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN 5. 与数值相关的全局方法5.1 parseInt()5.1.1 基本用法parseInt方法用于将字符串转为整数。 1parseInt(&apos;123&apos;) // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(&apos; 81&apos;) // 81 如果parseInt的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23) // 1// 等同于parseInt(&apos;1.23&apos;) // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt(&apos;8a&apos;) // 8parseInt(&apos;12**&apos;) // 12parseInt(&apos;12.34&apos;) // 12parseInt(&apos;15e2&apos;) // 15parseInt(&apos;15px&apos;) // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt(&apos;abc&apos;) // NaNparseInt(&apos;.3&apos;) // NaNparseInt(&apos;&apos;) // NaNparseInt(&apos;+&apos;) // NaNparseInt(&apos;+1&apos;) // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt(&apos;0x10&apos;) // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt(&apos;011&apos;) // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt(&apos;1e+21&apos;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&apos;8e-7&apos;) // 8 5.1.2 进制转换parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 123parseInt(&apos;1000&apos;) // 1000// 等同于parseInt(&apos;1000&apos;, 10) // 1000 下面是转换指定进制的数的例子。 123parseInt(&apos;1000&apos;, 2) // 8parseInt(&apos;1000&apos;, 6) // 216parseInt(&apos;1000&apos;, 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt(&apos;10&apos;, 37) // NaNparseInt(&apos;10&apos;, 1) // NaNparseInt(&apos;10&apos;, 0) // 10parseInt(&apos;10&apos;, null) // 10parseInt(&apos;10&apos;, undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 12parseInt(&apos;1546&apos;, 2) // 1parseInt(&apos;546&apos;, 2) // NaN 上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt(&apos;17&apos;, 36)parseInt(&apos;17&apos;, 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 1234567parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2) 上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 5.2 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 1parseFloat(&apos;3.14&apos;) // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat(&apos;314e-2&apos;) // 3.14parseFloat(&apos;0.0314E+2&apos;) // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat(&apos;3.14more non-digit characters&apos;) // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat(&apos;\\t\\v\\r12.34\\n &apos;) // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat(&apos;FF2&apos;) // NaNparseFloat(&apos;&apos;) // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat(&apos;&apos;) // NaNNumber(&apos;&apos;) // 0parseFloat(&apos;123.45#&apos;) // 123.45Number(&apos;123.45#&apos;) // NaN 5.3 isNaN()isNaN方法可以用来判断一个值是否为NaN。 12isNaN(NaN) // trueisNaN(123) // false 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。 123isNaN(&apos;Hello&apos;) // true// 相当于isNaN(Number(&apos;Hello&apos;)) // true 出于同样的原因，对于对象和数组，isNaN也返回true。 1234567isNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // trueisNaN([&apos;xzy&apos;]) // true// 等同于isNaN(Number([&apos;xzy&apos;])) // true 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 123isNaN([]) // falseisNaN([123]) // falseisNaN([&apos;123&apos;]) // false 上面代码之所以返回false，原因是这些数组能被Number函数转成数值。 因此，使用isNaN之前，最好判断一下数据类型。 123function myIsNaN(value) &#123; return typeof value === &apos;number&apos; &amp;&amp; isNaN(value);&#125; 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。 123function myIsNaN(value) &#123; return value !== value;&#125; 5.4 isFinite()isFinite方法返回一个布尔值，表示某个值是否为正常的数值。 123456isFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。 字符串1. 概述1.1 定义字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。 12&apos;abc&apos;&quot;abc&quot; 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12&apos;key = &quot;value&quot;&apos;&quot;It&apos;s a long journey&quot; 上面两个都是合法的字符串。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 12345&apos;Did she say \\&apos;Hello\\&apos;?&apos;// &quot;Did she say &apos;Hello&apos;?&quot;&quot;Did she say \\&quot;Hello\\&quot;?&quot;// &quot;Did she say &quot;Hello&quot;?&quot; 由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。 字符串默认只能写在一行内，分成多行将会报错。 1234&apos;abc&apos;// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript 就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = &apos;Long \\long \\long \\string&apos;;longString// &quot;Long long long string&quot; 上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = &apos;Long &apos; + &apos;long &apos; + &apos;long &apos; + &apos;string&apos;; 如果想输出多行字符串，有一种利用多行注释的变通方法。 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split(&apos;\\n&apos;).slice(1, -1).join(&apos;\\n&apos;)// &quot;line 1// line 2// line 3&quot; 上面的例子中，输出的字符串就是多行。 1.2 转义反斜杠（\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些。 \\0 ：null（\\u0000） \\b ：后退键（\\u0008） \\f ：换页符（\\u000C） \\n ：换行符（\\u000A） \\r ：回车键（\\u000D） \\t ：制表符（\\u0009） \\v ：垂直制表符（\\u000B） \\&#39; ：单引号（\\u0027） \\&quot; ：双引号（\\u0022） \\\\ ：反斜杠（\\u005C） 上面这些字符前面加上反斜杠，都表示特殊含义。 123console.log(&apos;1\\n2&apos;)// 1// 2 上面代码中，\\n表示换行，输出的时候就分成了两行。 反斜杠还有三种特殊用法。 （1）\\HHH 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\\251表示版权符号。显然，这种方法只能输出256种字符。 （2）\\xHH \\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\\xA9表示版权符号。这种方法也只能输出256种字符。 （3）\\uXXXX \\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\\u00A9表示版权符号。 下面是这三种字符特殊写法的例子。 1234567&apos;\\251&apos; // &quot;©&quot;&apos;\\xA9&apos; // &quot;©&quot;&apos;\\u00A9&apos; // &quot;©&quot;&apos;\\172&apos; === &apos;z&apos; // true&apos;\\x7A&apos; === &apos;z&apos; // true&apos;\\u007A&apos; === &apos;z&apos; // true 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。 12&apos;\\a&apos;// &quot;a&quot; 上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。 如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。 12&quot;Prev \\\\ Next&quot;// &quot;Prev \\ Next&quot; 1.3 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = &apos;hello&apos;;s[0] // &quot;h&quot;s[1] // &quot;e&quot;s[4] // &quot;o&quot;// 直接对字符串使用方括号运算符&apos;hello&apos;[1] // &quot;e&quot; 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123&apos;abc&apos;[3] // undefined&apos;abc&apos;[-1] // undefined&apos;abc&apos;[&apos;x&apos;] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 12345678910var s = &apos;hello&apos;;delete s[0];s // &quot;hello&quot;s[1] = &apos;a&apos;;s // &quot;hello&quot;s[5] = &apos;!&apos;;s // &quot;hello&quot; 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 1.4 length 属性length属性返回字符串的长度，该属性也是无法改变的。 12345678var s = &apos;hello&apos;;s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 2. 字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。 12var s = &apos;\\u00A9&apos;;s // &quot;©&quot; 解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。 12var f\\u006F\\u006F = &apos;abc&apos;;foo // &quot;abc&quot; 上面代码中，第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。 我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。 但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。 JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。 1&apos;𝌆&apos;.length // 2 上面代码中，JavaScript 认为𝌆的长度为2，而不是1。 总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 3. Base64 转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。 所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = &apos;Hello World!&apos;;btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;atob(&apos;SGVsbG8gV29ybGQh&apos;) // &quot;Hello World!&quot; 注意，这两个方法不适合非 ASCII 码的字符，会报错。 1btoa(&apos;你好&apos;) // 报错 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode(&apos;你好&apos;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;b64Decode(&apos;JUU0JUJEJUEwJUU1JUE1JUJE&apos;) // &quot;你好&quot; 对象1 概述1.1 生成方法对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。 什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 1234var obj = &#123; foo: &apos;Hello&apos;, bar: &apos;World&apos;&#125;; 上面代码中，大括号就定义了一个对象，它被赋值给变量obj，所以变量obj就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是foo: &#39;Hello&#39;，其中foo是“键名”（成员的名称），字符串Hello是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是bar: &#39;World&#39;，bar是键名，World是键值。两个键值对之间用逗号分隔。 1.2 键名对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。 1234var obj = &#123; &apos;foo&apos;: &apos;Hello&apos;, &apos;bar&apos;: &apos;World&apos;&#125;; 如果键名是数值，会被自动转为字符串。 1234567891011121314151617181920var obj = &#123; 1: &apos;a&apos;, 3.2: &apos;b&apos;, 1e2: true, 1e-2: true, .234: true, 0xFF: true&#125;;obj// Object &#123;// 1: &quot;a&quot;,// 3.2: &quot;b&quot;,// 100: true,// 0.01: true,// 0.234: true,// 255: true// &#125;obj[&apos;100&apos;] // true 上面代码中，对象obj的所有键名虽然看上去像数值，实际上都被自动转成了字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 1234567891011// 报错var obj = &#123; 1p: &apos;Hello World&apos;&#125;;// 不报错var obj = &#123; &apos;1p&apos;: &apos;Hello World&apos;, &apos;h w&apos;: &apos;Hello World&apos;, &apos;p+q&apos;: &apos;Hello World&apos;&#125;; 上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。 1234567var obj = &#123; p: function (x) &#123; return 2 * x; &#125;&#125;;obj.p(1) // 2 上面代码中，对象obj的属性p，就指向一个函数。 如果属性的值还是一个对象，就形成了链式引用。 12345var o1 = &#123;&#125;;var o2 = &#123; bar: &apos;hello&apos; &#125;;o1.foo = o2;o1.foo.bar // &quot;hello&quot; 上面代码中，对象o1的属性foo指向对象o2，就可以链式引用o2的属性。 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。 1234var obj = &#123; p: 123, m: function () &#123; ... &#125;,&#125; 上面的代码中，m属性后面的那个逗号，有没有都可以。 属性可以动态创建，不必在对象声明时就指定。 123var obj = &#123;&#125;;obj.foo = 123;obj.foo // 123 上面代码中，直接对obj对象的foo属性赋值，结果就在运行时创建了foo属性。 1.3 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 12345678var o1 = &#123;&#125;;var o2 = o1;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2 上面代码中，o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 12345var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125; 上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。 但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。 12345var x = 1;var y = x;x = 2;y // 1 上面的代码中，当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。 1.4 表达式还是语句?对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？ 1&#123; foo: 123 &#125; JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。 为了避免这种歧义，V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。 1(&#123; foo: 123&#125;) 这种差异在eval语句（作用是对字符串求值）中反映得最明显。 12eval(&apos;&#123;foo: 123&#125;&apos;) // 123eval(&apos;(&#123;foo: 123&#125;)&apos;) // &#123;foo: 123&#125; 上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象。 2. 属性的操作2.1 属性的读取读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。 123456var obj = &#123; p: &apos;Hello World&apos;&#125;;obj.p // &quot;Hello World&quot;obj[&apos;p&apos;] // &quot;Hello World&quot; 上面代码分别采用点运算符和方括号运算符，读取属性p。 请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。 123456789var foo = &apos;bar&apos;;var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo] // 2 上面代码中，引用对象obj的foo属性时，如果使用点运算符，foo就是字符串；如果使用方括号运算符，但是不使用引号，那么foo就是一个变量，指向字符串bar。 方括号运算符内部还可以使用表达式。 12obj[&apos;hello&apos; + &apos; world&apos;]obj[3 + 3] 数字键可以不加引号，因为会自动转成字符串。 123456var obj = &#123; 0.7: &apos;Hello World&apos;&#125;;obj[&apos;0.7&apos;] // &quot;Hello World&quot;obj[0.7] // &quot;Hello World&quot; 上面代码中，对象obj的数字键0.7，加不加引号都可以，因为会被自动转为字符串。 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。 123456var obj = &#123; 123: &apos;hello world&apos;&#125;;obj.123 // 报错obj[123] // &quot;hello world&quot; 上面代码的第一个表达式，对数值键名123使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。 2.2 属性的赋值点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。 1234var obj = &#123;&#125;;obj.foo = &apos;Hello&apos;;obj[&apos;bar&apos;] = &apos;World&apos;; 上面代码中，分别使用点运算符和方括号运算符，对属性赋值。 JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。 123456var obj = &#123; p: 1 &#125;;// 等价于var obj = &#123;&#125;;obj.p = 1; 2.3 属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// [&apos;key1&apos;, &apos;key2&apos;] 2.4 属性的删除：delete 命令delete命令用于删除对象的属性，删除成功后返回true。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 1234567var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 123, configurable: false&#125;);obj.p // 123delete obj.p // false 上面代码之中，对象obj的p属性是不能删除的，所以delete命令返回false。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 2.5 属性是否存在：in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。 123var obj = &#123; p: 1 &#125;;&apos;p&apos; in obj // true&apos;toString&apos; in obj // true in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。 1234var obj = &#123;&#125;;if (&apos;toString&apos; in obj) &#123; console.log(obj.hasOwnProperty(&apos;toString&apos;)) // false&#125; 2.6 属性的遍历：for…in 循环for...in循环用来遍历一个对象的全部属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log(&apos;键名：&apos;, i); console.log(&apos;键值：&apos;, obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: &apos;老张&apos; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 3. with 语句with语句的格式如下： 123with (对象) &#123; 语句;&#125; 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 1234567891011121314151617181920212223// 例一var obj = &#123; p1: 1, p2: 2,&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123; console.log(href); console.log(title); console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 上面代码中，对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1。正确的写法应该是，先定义对象obj的属性p1，然后在with区块内操作它。 这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。 123with (obj) &#123; console.log(x);&#125; 单纯从上面的代码块，根本无法判断x到底是全局变量，还是对象obj的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。 1234567with(obj1.obj2.obj3) &#123; console.log(p1 + p2);&#125;// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2); 函数函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。 1. 概述1.1 函数的声明JavaScript 有三种声明函数的方法 （1）function 命令 function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。 123function print(s) &#123; console.log(s);&#125; 上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。 （2）函数表达式 除了用function命令声明函数，还可以采用变量赋值的写法。 123var print = function(s) &#123; console.log(s);&#125;; 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 123456789var print = function x()&#123; console.log(typeof x);&#125;;x// ReferenceError: x is not definedprint()// function 上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。 1var f = function f() &#123;&#125;; 需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。 （3）Function 构造函数 第三种声明函数的方式是Function构造函数。 12345678910var add = new Function( &apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos;);// 等同于function add(x, y) &#123; return x + y;&#125; 上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。 你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。 12345678var foo = new Function( &apos;return &quot;hello world&quot;;&apos;);// 等同于function foo() &#123; return &apos;hello world&apos;;&#125; Function构造函数可以不使用new命令，返回结果完全一样。 总的来说，这种声明函数的方式非常不直观，几乎无人使用。 1.2 函数的重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 123456789function f() &#123; console.log(1);&#125;f() // 2function f() &#123; console.log(2);&#125;f() // 2 上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升，前一次声明在任何时候都是无效的，这一点要特别注意。 1.3 圆括号运算符，return 语句和递归调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。 12345function add(x, y) &#123; return x + y;&#125;add(1, 1) // 2 上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。 函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。 函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。 1234567function fib(num) &#123; if (num === 0) return 0; if (num === 1) return 1; return fib(num - 2) + fib(num - 1);&#125;fib(6) // 8 上面代码中，fib函数内部又调用了fib，计算得到斐波那契数列的第6个元素是8。 1.4 第一等公民JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。 由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。 12345678910111213function add(x, y) &#123; return x + y;&#125;// 将函数赋值给一个变量var operator = add;// 将函数作为参数和返回值function a(op)&#123; return op;&#125;a(add)(1, 1)// 2 1.5 函数名的提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。 123f();function f() &#123;&#125; 表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。 123f();var f = function ()&#123;&#125;;// TypeError: undefined is not a function 上面的代码等同于下面的形式。 123var f;f();f = function () &#123;&#125;; 上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。因此，如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 123456789var f = function () &#123; console.log(&apos;1&apos;);&#125;function f() &#123; console.log(&apos;2&apos;);&#125;f() // 1 2. 函数的属性和方法2.1 name 属性函数的name属性返回函数的名字。 12function f1() &#123;&#125;f1.name // &quot;f1&quot; 如果是通过变量赋值定义的函数，那么name属性返回变量名。 12var f2 = function () &#123;&#125;;f2.name // &quot;f2&quot; 但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。 12var f3 = function myName() &#123;&#125;;f3.name // &apos;myName&apos; 上面代码中，f3.name返回函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。 name属性的一个用处，就是获取参数函数的名字。 1234567var myFunc = function () &#123;&#125;;function test(f) &#123; console.log(f.name);&#125;test(myFunc) // myFunc 上面代码中，函数test内部通过name属性，就可以知道传入的参数是什么函数。 2.2 length 属性函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 12function f(a, b) &#123;&#125;f.length // 2 上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。 length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。 2.3 toString()函数的toString方法返回一个字符串，内容是函数的源码。 123456789101112function f() &#123; a(); b(); c();&#125;f.toString()// function f() &#123;// a();// b();// c();// &#125; 函数内部的注释也可以返回。 12345678910function f() &#123;/* 这是一个 多行注释*/&#125;f.toString()// &quot;function f()&#123;/*// 这是一个// 多行注释// */&#125;&quot; 利用这一点，可以变相实现多行字符串。 12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split(&apos;\\n&apos;); return arr.slice(1, arr.length - 1).join(&apos;\\n&apos;);&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// &quot; 这是一个// 多行注释&quot; 3. 函数作用域3.1 定义作用域（scope）指的是变量存在的范围。在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。 函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。 12345678var v = 1;function f() &#123; console.log(v);&#125;f()// 1 上面的代码表明，函数f内部可以读取全局变量v。 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。 12345function f()&#123; var v = 1;&#125;v // ReferenceError: v is not defined 上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。 函数内部定义的变量，会在该作用域内覆盖同名全局变量。 123456789var v = 1;function f()&#123; var v = 2; console.log(v);&#125;f() // 2v // 1 上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v。 注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。 1234if (true) &#123; var x = 5;&#125;console.log(x); // 5 上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。 3.2 函数内部的变量提升与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 12345678910111213function foo(x) &#123; if (x &gt; 100) &#123; var tmp = x - 100; &#125;&#125;// 等同于function foo(x) &#123; var tmp; if (x &gt; 100) &#123; tmp = x - 100; &#125;;&#125; 3.3 函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。 很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量。 1234567891011var x = function () &#123; console.log(a);&#125;;function y(f) &#123; var a = 2; f();&#125;y(x)// ReferenceError: a is not defined 上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。 同样的，函数体内部声明的函数，作用域绑定函数体内部。 1234567891011function foo() &#123; var x = 1; function bar() &#123; console.log(x); &#125; return bar;&#125;var x = 2;var f = foo();f() // 1 上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了“闭包”现象。 4. 参数4.1 概述函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。 123456function square(x) &#123; return x * x;&#125;square(2) // 4square(3) // 9 上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。 4.2 参数的省略函数参数不是必需的，Javascript 允许省略参数。 123456789function f(a, b) &#123; return a;&#125;f(1, 2, 3) // 1f(1) // 1f() // undefinedf.length // 2 上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。 123456function f(a, b) &#123; return a;&#125;f( , 1) // SyntaxError: Unexpected token ,(…)f(undefined, 1) // undefined 上面代码中，如果省略第一个参数，就会报错。 4.3 传递方式函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。 12345678var p = 2;function f(p) &#123; p = 3;&#125;f(p);p // 2 上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 12345678var obj = &#123; p: 1 &#125;;function f(o) &#123; o.p = 2;&#125;f(obj);obj.p // 2 上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。 12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] 上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。 4.4 同名参数如果有同名的参数，则取最后出现的那个值。 12345function f(a, a) &#123; console.log(a);&#125;f(1, 2) // 2 上面代码中，函数f有两个参数，且参数名都是a。取值的时候，以后面的a为准，即使后面的a没有值或被省略，也是以其为准。 12345function f(a, a) &#123; console.log(a);&#125;f(1) // undefined 调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。 12345function f(a, a) &#123; console.log(arguments[0]);&#125;f(1) // 1 4.5 arguments 对象（1）定义 由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 12345678910var f = function (one) &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]);&#125;f(1, 2, 3)// 1// 2// 3 正常模式下，arguments对象可以在运行时修改。 1234567var f = function(a, b) &#123; arguments[0] = 3; arguments[1] = 2; return a + b;&#125;f(1, 1) // 5 上面代码中，函数f调用时传入的参数，在函数内部被修改成3和2。 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。 12345678var f = function(a, b) &#123; &apos;use strict&apos;; // 开启严格模式 arguments[0] = 3; // 无效 arguments[1] = 2; // 无效 return a + b;&#125;f(1, 1) // 2 上面代码中，函数体内是严格模式，这时修改arguments对象就是无效的。 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。 1234567function f() &#123; return arguments.length;&#125;f(1, 2, 3) // 3f(1) // 1f() // 0 （2）与数组的关系 需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; （3）callee 属性 arguments对象带有一个callee属性，返回它所对应的原函数。 12345var f = function () &#123; console.log(arguments.callee === f);&#125;f() // true 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 5. 函数的其他知识点5.1 闭包闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。 123456var n = 999;function f1() &#123; console.log(n);&#125;f1() // 999 上面代码中，函数f1可以读取全局变量n。 但是，函数外部无法读取函数内部声明的变量。 123456function f1() &#123; var n = 999;&#125;console.log(n)// Uncaught ReferenceError: n is not defined( 上面代码中，函数f1内部声明的变量n，函数外是无法读取的。 如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 123456function f1() &#123; var n = 999; function f2() &#123; console.log(n); // 999 &#125;&#125; 上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 12345678910function f1() &#123; var n = 999; function f2() &#123; console.log(n); &#125; return f2;&#125;var result = f1();result(); // 999 上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。 闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。 1234567891011function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7 上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。 为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 闭包的另一个用处，是封装对象的私有属性和私有方法。 12345678910111213141516171819function Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person(&apos;张三&apos;);p1.setAge(25);p1.getAge() // 25 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 5.2 立即调用的函数表达式（IIFE）在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。 有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。 12function()&#123; /* code */ &#125;();// SyntaxError: Unexpected token ( 产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。 12345// 语句function f() &#123;&#125;// 表达式var f = function f() &#123;&#125; 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。 123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。 注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。 123// 报错(function()&#123; /* code */ &#125;())(function()&#123; /* code */ &#125;()) 上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。 推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。 123var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;(); 甚至像下面这样写，也是可以的。 1234!function () &#123; /* code */ &#125;();~function () &#123; /* code */ &#125;();-function () &#123; /* code */ &#125;();+function () &#123; /* code */ &#125;(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 1234567891011// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () &#123; var tmp = newData; processData(tmp); storeData(tmp);&#125;()); 上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。 6. eval 命令6.1 基本用法eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。 12eval(&apos;var a = 1;&apos;);a // 1 上面代码将字符串当作语句运行，生成了变量a。 如果参数字符串无法当作语句运行，那么就会报错。 1eval(&apos;3x&apos;) // Uncaught SyntaxError: Invalid or unexpected token 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用。举例来说，下面的代码将会报错。 1eval(&apos;return;&apos;); // Uncaught SyntaxError: Illegal return statement 上面代码会报错，因为return不能单独使用，必须在函数中使用。 如果eval的参数不是字符串，那么会原样返回。 1eval(123) // 123 eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。 1234var a = 1;eval(&apos;a = 2&apos;);a // 2 上面代码中，eval命令修改了外部变量a的值。由于这个原因，eval有安全风险。 为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。 12345(function f() &#123; &apos;use strict&apos;; eval(&apos;var foo = 123&apos;); console.log(foo); // ReferenceError: foo is not defined&#125;)() 上面代码中，函数f内部是严格模式，这时eval内部声明的foo变量，就不会影响到外部。 不过，即使在严格模式下，eval依然可以读写当前作用域的变量。 123456(function f() &#123; &apos;use strict&apos;; var foo = 1; eval(&apos;foo = 2&apos;); console.log(foo); // 2&#125;)() 上面代码中，严格模式下，eval内部还是改写了外部变量，可见安全风险依然存在。 总之，eval的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，eval最常见的场合是解析JSON数据的字符串，不过正确的做法应该是使用原生的JSON.parse方法。 6.2 eval 的别名调用前面说过eval不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是eval。 123var m = eval;m(&apos;var x = 1&apos;);x // 1 上面代码中，变量m是eval的别名。静态代码分析阶段，引擎分辨不出m(&#39;var x = 1&#39;)执行的是eval命令。 为了保证eval的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。 123456789var a = 1;function f() &#123; var a = 2; var e = eval; e(&apos;console.log(a)&apos;);&#125;f() // 1 上面代码中，eval是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的a为全局变量。这样的话，引擎就能确认e()不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。 eval的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨eval()这一种形式是直接调用。 1234eval.call(null, &apos;...&apos;)window.eval(&apos;...&apos;)(1, eval)(&apos;...&apos;)(eval, eval)(&apos;...&apos;) 上面这些形式都是eval的别名调用，作用域都是全局作用域。 数组1. 定义数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。 1var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; 上面代码中的a、b、c就构成一个数组，两端的方括号是数组的标志。a是0号位置，b是1号位置，c是2号位置。 除了在定义时赋值，数组也可以先定义后赋值。 12345var arr = [];arr[0] = &apos;a&apos;;arr[1] = &apos;b&apos;;arr[2] = &apos;c&apos;; 任何类型的数据，都可以放入数组。 123456789var arr = [ &#123;a: 1&#125;, [1, 2, 3], function() &#123;return true;&#125;];arr[0] // Object &#123;a: 1&#125;arr[1] // [1, 2, 3]arr[2] // function ()&#123;return true;&#125; 上面数组arr的3个成员依次是对象、数组、函数。 如果数组的元素还是数组，就形成了多维数组。 123var a = [[1, 2], [3, 4]];a[0][1] // 2a[1][1] // 4 2. 数组的本质本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 1typeof [1, 2, 3] // &quot;object&quot; 上面代码表明，typeof运算符认为数组的类型就是对象。 数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];Object.keys(arr)// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] 上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。 由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr[&apos;0&apos;] // &apos;a&apos;arr[0] // &apos;a&apos; 上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。 注意，这点在赋值时也成立。如果一个值总是先转成字符串，再进行赋值。 1234var a = [];a[1.00] = 6;a[1] // 6 上面代码中，由于1.00转成字符串是1，所以通过数字键1可以读取值。 上一章说过，对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]）。但是，对于数值的键名，不能使用点结构。 12var arr = [1, 2, 3];arr.0 // SyntaxError 上面代码中，arr.0的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。 3. length 属性数组的length属性，返回数组的成员数量。 1[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].length // 3 JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（2^32 - 1）个，也就是说length属性的最大值就是 4294967295。 只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。 1234567891011var arr = [&apos;a&apos;, &apos;b&apos;];arr.length // 2arr[2] = &apos;c&apos;;arr.length // 3arr[9] = &apos;d&apos;;arr.length // 10arr[1000] = &apos;e&apos;;arr.length // 1001 上面代码表示，数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。 length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。 12345var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];arr.length // 3arr.length = 2;arr // [&quot;a&quot;, &quot;b&quot;] 上面代码表示，当数组的length属性设为2（即最大的整数键只能是1）那么整数键2（值为c）就已经不在数组中了，被自动删除了。 清空数组的一个有效方法，就是将length属性设为0。 1234var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];arr.length = 0;arr // [] 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。 1234var a = [&apos;a&apos;];a.length = 3;a[1] // undefined 上面代码表示，当length属性设为大于数组个数时，读取新增的位置都会返回undefined。 如果人为设置length为不合法的值，JavaScript 会报错。 1234567891011// 设置负值[].length = -1// RangeError: Invalid array length// 数组元素个数大于等于2的32次方[].length = Math.pow(2, 32)// RangeError: Invalid array length// 设置字符串[].length = &apos;abc&apos;// RangeError: Invalid array length 值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。 1234567var a = [];a[&apos;p&apos;] = &apos;abc&apos;;a.length // 0a[2.1] = &apos;abc&apos;;a.length // 0 上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。 1234567var arr = [];arr[-1] = &apos;a&apos;;arr[Math.pow(2, 32)] = &apos;b&apos;;arr.length // 0arr[-1] // &quot;a&quot;arr[4294967296] // &quot;b&quot; 上面代码中，我们为数组arr添加了两个不合法的数字键，结果length属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。 4. in 运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。 1234var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];2 in arr // true&apos;2&apos; in arr // true4 in arr // false 上面代码表明，数组存在键名为2的键。由于键名都是字符串，所以数值2会自动转成字符串。 注意，如果数组的某个位置是空位，in运算符返回false。 12345var arr = [];arr[100] = &apos;a&apos;;100 in arr // true1 in arr // false 上面代码中，数组arr只有一个成员arr[100]，其他位置的键名都会返回false。 5. for…in 循环和数组的遍历for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。 12345678var a = [1, 2, 3];for (var i in a) &#123; console.log(a[i]);&#125;// 1// 2// 3 但是，for...in不仅会遍历数组所有的数字键，还会遍历非数字键。 12345678910var a = [1, 2, 3];a.foo = true;for (var key in a) &#123; console.log(key);&#125;// 0// 1// 2// foo 上面代码在遍历数组时，也遍历到了非整数键foo。所以，不推荐使用for...in遍历数组。 数组的遍历可以考虑使用for循环或while循环。 123456789101112131415161718var a = [1, 2, 3];// for循环for(var i = 0; i &lt; a.length; i++) &#123; console.log(a[i]);&#125;// while循环var i = 0;while (i &lt; a.length) &#123; console.log(a[i]); i++;&#125;var l = a.length;while (l--) &#123; console.log(a[l]);&#125; 上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。 1234567var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];colors.forEach(function (color) &#123; console.log(color);&#125;);// red// green// blue 6. 数组的空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。 12var a = [1, , 1];a.length // 3 上面代码表明，数组的空位不影响length属性。 需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。 1234var a = [1, 2, 3,];a.length // 3a // [1, 2, 3] 上面代码中，数组最后一个成员后面有一个逗号，这不影响length属性的值，与没有这个逗号时效果一样。 数组的空位是可以读取的，返回undefined。 12var a = [, , ,];a[1] // undefined 使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。 12345var a = [1, 2, 3];delete a[1];a[1] // undefineda.length // 3 上面代码用delete命令删除了数组的第二个元素，这个位置就形成了空位，但是对length属性没有影响。也就是说，length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。 1234567891011121314var a = [, , ,];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;)// 不产生任何输出for (var i in a) &#123; console.log(i);&#125;// 不产生任何输出Object.keys(a)// [] 如果某个位置是undefined，遍历的时候就不会被跳过。 123456789101112131415161718var a = [undefined, undefined, undefined];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;);// 0. undefined// 1. undefined// 2. undefinedfor (var i in a) &#123; console.log(i);&#125;// 0// 1// 2Object.keys(a)// [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] 这就是说，空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。 7. 类似数组的对象如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。 1234567891011var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3&#125;;obj[0] // &apos;a&apos;obj[1] // &apos;b&apos;obj.length // 3obj.push(&apos;d&apos;) // TypeError: obj.push is not a function 上面代码中，对象obj就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。 “类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。 12345var obj = &#123; length: 0&#125;;obj[3] = &apos;d&apos;;obj.length // 0 上面代码为对象obj添加了一个数字键，但是length属性没变。这就说明了obj不是数组。 典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。 1234567891011121314151617// arguments对象function args() &#123; return arguments &#125;var arrayLike = args(&apos;a&apos;, &apos;b&apos;);arrayLike[0] // &apos;a&apos;arrayLike.length // 2arrayLike instanceof Array // false// DOM元素集var elts = document.getElementsByTagName(&apos;h3&apos;);elts.length // 3elts instanceof Array // false// 字符串&apos;abc&apos;[1] // &apos;b&apos;&apos;abc&apos;.length // 3&apos;abc&apos; instanceof Array // false 上面代码包含三个例子，它们都不是数组（instanceof运算符返回false），但是看上去都非常像数组。 数组的slice方法可以将“类似数组的对象”变成真正的数组。 1var arr = Array.prototype.slice.call(arrayLike); 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。 12345function print(value, index) &#123; console.log(index + &apos; : &apos; + value);&#125;Array.prototype.forEach.call(arrayLike, print); 上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。 下面的例子就是通过这种方法，在arguments对象上面调用forEach方法。 12345678910111213// forEach 方法function logArgs() &#123; Array.prototype.forEach.call(arguments, function (elem, i) &#123; console.log(i + &apos;. &apos; + elem); &#125;);&#125;// 等同于 for 循环function logArgs() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(i + &apos;. &apos; + arguments[i]); &#125;&#125; 字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。 123456Array.prototype.forEach.call(&apos;abc&apos;, function (chr) &#123; console.log(chr);&#125;);// a// b// c 注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。 1234567var arr = Array.prototype.slice.call(&apos;abc&apos;);arr.forEach(function (chr) &#123; console.log(chr);&#125;);// a// b// c","categories":[],"tags":[]},{"title":"JS基本语法","slug":"JS基本语法","date":"2018-09-07T01:23:21.000Z","updated":"2021-02-26T16:49:29.477Z","comments":true,"path":"2018/09/07/JS基本语法/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/07/JS基本语法/","excerpt":"","text":"JS基本语法什么是 JavaScript 语言JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。 1. 语句JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。 1var a = 1 + 3; 这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。 1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 1var a = 1 + 3 ; var b = &apos;abc&apos;; 分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。 1;;; 上面的代码就表示3个空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 121 + 3;&apos;abc&apos;; 上面两行语句只是单纯地产生一个值，并没有任何实际的意义。 2.变量2.1. 概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 1var a = 1; 上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。 注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。 12var a;a = 1; 如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。 12var a;a // undefined 如果变量赋值的时候，忘了写var命令，这条语句也是有效的。 123var a = 1;// 基本等同a = 1; 但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用var命令声明变量。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 12x// ReferenceError: x is not defined 上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。 可以在同一条var命令中声明多个变量。 1var a, b; JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 12var a = 1;a = &apos;hello&apos;; 上面代码中，变量a起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量a已经存在，所以不需要使用var命令。 如果使用var重新声明一个已经存在的变量，是无效的。 123var x = 1;var x;x // 1 上面代码中，变量x声明了两次，第二次声明是无效的。 但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 12345678var x = 1;var x = 2;// 等同于var x = 1;var x;x = 2; 2.2 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 3. 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 4. 注释源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法： 单行注释，用//起头； 多行注释，放在/*和*/之间。 1234567// 这是单行注释/* 这是 多行 注释*/ 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以也被视为合法的单行注释。 12x = 1; &lt;!-- x = 2;--&gt; x = 3; 上面代码中，只有x = 1会执行，其他的部分都被注释掉了。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 1234567function countdown(n) &#123; while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0 上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0。 5. 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。 12345&#123; var a = 1;&#125;a // 1 上面代码在区块内部，使用var命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于var命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如for、if、while、function等。 6. 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 6.1 if 结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示 真，false表示 伪。 12345if (布尔值) 语句;// 或者if (布尔值) 语句; 上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。 12if (m === 3) m = m + 1; 上面代码表示，只有在m等于3时，才会将其值加上1。 这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。 123if (m === 3) &#123; m += 1;&#125; 建议总是在if语句中使用大括号，因为这样方便插入语句。 注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 123456var x = 1;var y = 2;if (x = y) &#123; console.log(x);&#125;// &quot;2&quot; 上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于2）的布尔值（结果为true）。 这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值 12if (x = 2) &#123; // 不报错if (2 = x) &#123; // 报错 至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==）。 6.2 if…else 结构if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 12345if (m === 3) &#123; // 满足条件时，执行的语句&#125; else &#123; // 不满足条件时，执行的语句&#125; 上面代码判断变量m是否等于3，如果等于就执行if代码块，否则执行else代码块。 对同一个变量进行多次判断时，多个if...else语句可以连写在一起。 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; else代码块总是与离自己最近的那个if语句配对。 123456var m = 1;var n = 2;if (m !== 1)if (n === 2) console.log(&apos;hello&apos;);else console.log(&apos;world&apos;); 上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。 1234567if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125; else &#123; console.log(&apos;world&apos;); &#125;&#125; 如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。 12345678if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125;&#125; else &#123; console.log(&apos;world&apos;);&#125;// world 6.3 switch 结构多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。 12345678910switch (fruit) &#123; case &quot;banana&quot;: // ... break; case &quot;apple&quot;: // ... break; default: // ...&#125; 上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 12345678910111213var x = 1;switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); case 2: console.log(&apos;x 等于2&apos;); default: console.log(&apos;x 等于其他值&apos;);&#125;// x等于1// x等于2// x等于其他值 上面代码中，case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。正确的写法是像下面这样。 12345678910switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); break; case 2: console.log(&apos;x 等于2&apos;); break; default: console.log(&apos;x 等于其他值&apos;);&#125; switch语句部分和case语句部分，都可以使用表达式。 1234567switch (1 + 3) &#123; case 2 + 2: f(); break; default: neverHappens();&#125; 上面代码的default部分，是永远不会执行到的。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 12345678910var x = 1;switch (x) &#123; case true: console.log(&apos;x 发生类型转换&apos;); break; default: console.log(&apos;x 没有发生类型转换&apos;);&#125;// x 没有发生类型转换 上面代码中，由于变量x没有发生类型转换，所以不会执行case true的情况。这表明，switch语句内部采用的是“严格相等运算符”。 6.4 三元运算符 ?:JavaScript 还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。 1(条件) ? 表达式1 : 表达式2 上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。 1var even = (n % 2 === 0) ? true : false; 上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。 123456var even;if (n % 2 === 0) &#123; even = true;&#125; else &#123; even = false;&#125; 这个三元运算符可以被视为if...else...的简写形式，因此可以用于多种场合。 1234567var myVar;console.log( myVar ? &apos;myVar has a value&apos; : &apos;myVar does not have a value&apos;)// myVar does not have a value 上面代码利用三元运算符，输出相应的提示。 1var msg = &apos;数字&apos; + n + &apos;是&apos; + (n % 2 === 0 ? &apos;偶数&apos; : &apos;奇数&apos;); 上面代码利用三元运算符，在字符串之中插入不同的值。 7. 循环语句循环语句用于重复执行某个操作，它有多种形式。 7.1 while 循环While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 12345while (条件) 语句;// 或者while (条件) 语句; while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; 下面是while语句的一个例子。 123456var i = 0;while (i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i = i + 1;&#125; 上面的代码将循环100次，直到i等于100为止。 下面的例子是一个无限循环，因为循环条件总是为真。 123while (true) &#123; console.log(&apos;Hello, world&apos;);&#125; 7.2 for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。 12345678for (初始化表达式; 条件; 递增表达式) 语句// 或者for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; for语句后面的括号里面，有三个表达式。 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。 条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。 递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。 下面是一个例子。 1234567var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2 上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。 所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。 1234567var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。 123for ( ; ; )&#123; console.log(&apos;Hello World&apos;);&#125; 上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。 7.3 do…while 循环do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 12345678do 语句while (条件);// 或者do &#123; 语句&#125; while (条件); 不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。 下面是一个例子。 1234567var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); 7.4 break 语句和 continue 语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。 break语句用于跳出代码块或循环。 1234567var i = 0;while(i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i++; if (i === 10) break;&#125; 上面代码只会执行10次循环，一旦i等于10，就会跳出循环。 for循环也可以使用break语句跳出循环。 123456789for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break;&#125;// 0// 1// 2// 3 上面代码执行到i等于3，就会跳出循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 1234567var i = 0;while (i &lt; 100)&#123; i++; if (i % 2 === 0) continue; console.log(&apos;i 当前为：&apos; + i);&#125; 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。 7.5 标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label: 语句 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 标签也可以用于跳出代码块。 12345678foo: &#123; console.log(1); break foo; console.log(&apos;本行不会输出&apos;);&#125;console.log(2);// 1// 2 上面代码执行到break foo，就会跳出区块。 continue语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2","categories":[],"tags":[]},{"title":"学习jquery源码","slug":"学习jquery源码","date":"2018-09-07T01:21:00.000Z","updated":"2021-02-26T16:49:29.485Z","comments":true,"path":"2018/09/07/学习jquery源码/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/07/学习jquery源码/","excerpt":"","text":"学习jQuery源码笔记1. 立即执行函数IIFE (立即调用的函数表达,Immediately-Invoked Function Expression，简称IIFE) 123(function() &#123; /*code*/&#125;)() 或者123(function() &#123; /*code*/&#125;()) IIFE的作用 不必为函数命名，避免了污染全局变量我们这里直接对匿名函数使用这种“立即执行的函数表达式”，并且在函数的在括号内定义之后立刻调用执行，这样避免为函数命名，减少命名的冲突 IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。在的JavaScript语法中我们知道作用域分为全局作用域和函数作用域(当然在后面的ES6中引入了块级作用域)，依据函数作用域这一特点，在匿名函数中我们可以封装一些自己内部模块使用的私有变量。 例子1234(function () &#123; var a=10;&#125;)();alert(a); 会报错 a is not defined","categories":[],"tags":[]},{"title":"mac 下svn的使用","slug":"mac-下svn的使用","date":"2018-07-13T01:48:15.000Z","updated":"2021-02-26T16:49:29.481Z","comments":true,"path":"2018/07/13/mac-下svn的使用/","link":"","permalink":"https://akitsukiwong.github.io/2018/07/13/mac-下svn的使用/","excerpt":"","text":"原来mac自带了svn，还挺好用的 以下是一些常用命令： 1、将文件checkout到本地目录 1 svn checkout path（path是服务器上的目录）2 例如：svn checkout svn://192.168.1.1/pro/domain3 简写：svn co 2、往版本库中添加新的文件 1 svn add file2 例如：svn add test.php(添加test.php)3 svn add *.php(添加当前目录下所有的php文件) 3、将改动的文件提交到版本库 1 svn commit -m “LogMessage“ [-N] [–no-unlock] PATH (如果选择了保持锁，就使用–no-unlock开关)2 例如： svn commit -m “add test file for my test“ test.php3 简写： svn ci 4、加锁/解锁 1 svn lock -m “LockMessage“ [–force] PATH2 例如：svn lock -m “lock test file“ test.php3 svn unlock PATH 5、更新到某个版本 1 svn update -r m path2 例如：3 svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。4 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200)5 svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)6 简写：svn up 6、查看文件或者目录状态 1 1）svn status path（目录下的文件和子目录的状态，正常状态不显示）2 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】3 2）svn status -v path(显示文件和子目录状态)4 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。5 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。6 简写：svn st 7、删除文件 1 svn delete path -m “delete test fle“2 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file”3 或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，推荐使用这种4 简写：svn (del, remove, rm) 8、查看日志 1 svn log path2 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化 9、查看文件详细信息 1 svn info path2 例如：svn info test.php 10、比较差异 1 svn diff path(将修改的文件与基础版本比较)2 例如：svn diff test.php3 svn diff -r m:n path(对版本m和版本n比较差异)4 例如：svn diff -r 200:201 test.php5 简写：svn di 11、将两个版本之间的差异合并到当前文件 1 svn merge -r m:n path2 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） 12、SVN 帮助 1 svn help2 svn help ci 13、版本库下的文件和目录列表 1 svn list path2 显示path目录下的所有属于版本库的文件和目录3 简写：svn ls 14、创建纳入版本控制下的新目录 复制代码 1 svn mkdir: 创建纳入版本控制下的新目录。2 用法: 1、mkdir PATH…3 2、mkdir URL…4 创建版本控制的目录。5 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增6 调度，以待下一次的提交。7 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。8 在这两个情况下，所有的中间目录都必须事先存在 复制代码 15、恢复本地修改 1 svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:2 用法: revert PATH…3 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复4 被删除的目录 16、代码库URL变更 复制代码 1 svn switch (sw): 更新工作副本至不同的URL。 2 用法: 1、switch URL [PATH] 3 2、switch –relocate FROM TO [PATH…] 4 5 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将 6 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的 7 方法。 8 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动 9 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用10 这个命令更新工作副本与仓库的对应关系。 复制代码 17、解决冲突 1 svn resolved: 移除工作副本的目录或文件的“冲突”状态。2 用法: resolved PATH…3 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的4 相关文件，然后让 PATH 可以再次提交。","categories":[],"tags":[]},{"title":"试一下Hexo Admin好不好用～","slug":"试一下Hexo-Admin好不好用～","date":"2018-07-12T04:23:00.000Z","updated":"2021-02-26T16:49:29.486Z","comments":true,"path":"2018/07/12/试一下Hexo-Admin好不好用～/","link":"","permalink":"https://akitsukiwong.github.io/2018/07/12/试一下Hexo-Admin好不好用～/","excerpt":"","text":"觉得原始的发blog太麻烦，所以装了个hexo admin 现在来尝试下发下博客 1 2 3 发送！","categories":[],"tags":[]},{"title":"重新学习Java​Script","slug":"重新学习Java​Script","date":"2018-05-28T01:52:00.000Z","updated":"2021-02-26T16:49:29.487Z","comments":true,"path":"2018/05/28/重新学习Java​Script/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/28/重新学习Java​Script/","excerpt":"","text":"概览JavaScript 是一种面向对象的动态语言 类型 NUmber （数字） String （字符串） Boolean （布尔） Function（函数） Object（对象） Symbol（ES2015新增） undefined (未定义) null(空) Array（数组）Date(日期) RegExp （正则表达式） 都是特殊的对象 所以准确来说，JavaScript 中的类型应该包括这些： Number（数字） String（字符串） Boolean（布尔） Symbol（符号）（ES2015 新增） Object（对象） Function（函数） Array（数组） Date（日期） RegExp（正则表达式） null（空） undefined（未定义） 数字根据语言规范，JavaScript 采用“遵循 IEEE 754 标准的双精度 64 位格式” JavaScript 不区分整数值和浮点数值，所有数字在 JavaScript 中均用浮点数值表示，所以在进行数字运算的时候要特别注意，例： 10.1 + 0.2 = 0.30000000000000004 内置对象 Math 12Math.sin(3.5);var d = Math.PI * (r + r) 内置函数 parseInt() 将字符串转换为整型，第二个参数表示字符串所表示数字的基（进制） 12parseInt(&quot;123&quot;, 10); // 123parseInt(&quot;010&quot;, 10); //10 如果调用时没有提供第二个参数（字符串所表示数字的基），2013 年以前的 JavaScript 实现会返回一个意外的结果： 12parseInt(&quot;010&quot;); // 8parseInt(&quot;0x10&quot;); // 16 这是因为字符串以数字 0 开头，parseInt()函数会把这样的字符串视作八进制数字；同理，0x开头的字符串则视为十六进制数字。 如果想把一个二进制数字字符串转换成整数值，只要把第二个参数设置为 2 就可以了： 1parseInt(&quot;11&quot;, 2); // 3 内置函数 parseFloat() 解析浮点数字符串,只应用于解析十进制数字 单元运算符 + 也可以把数字字符串转换成数值 123+ &quot;42&quot;; // 42+ &quot;010&quot;; // 10+ &quot;0x10&quot;; // 16 如果给定的字符串不存在数值形式，函数会返回一个特殊的值 NaN（Not a Number 的缩写）： 1parseInt(&quot;hello&quot;, 10); // NaN 如果把 NaN 作为参数进行任何数学运算，结果也会是 NaN 1NaN + 5; //NaN 可以使用内置函数 isNaN() 来判断一个变量是否为 NaN： 1isNaN(NaN); // true JavaScript 还有两个特殊值：Infinity（正无穷）和 -Infinity（负无穷）： 121 / 0; // Infinity-1 / 0; // -Infinity 可以使用内置函数 isFinite() 来判断一个变量是否是一个有穷数， 如果类型为Infinity, -Infinity 或 NaN则返回false： 1234567891011isFinite(1/0); // falseisFinite(Infinity); // falseisFinite(-Infinity); // falseisFinite(NaN); // falseisFinite(0); // trueisFinite(2e64); // trueisFinite(&quot;0&quot;); // true// 如果是纯数值类型的检测，则返回 false：Number.isFinite(&quot;0&quot;); // false 字符串JavaScript 中的字符串是一串Unicode 字符序列。这对于那些需要和多语种网页打交道的开发者来说是个好消息。更准确地说，它们是一串UTF-16编码单元的序列，每一个编码单元由一个 16 位二进制数表示。每一个Unicode字符由一个或两个编码单元来表示。 如果想表示一个单独的字符，只需使用长度为 1 的字符串。 通过访问字符串的 length（编码单元的个数）属性，可以得到它的长度。 1&quot;hello&quot;.length; // 5 这是我们第一次碰到 JavaScript 对象。我们有没有提过你可以像 object 一样使用字符串？是的，字符串也有 methods（方法）能让你操作字符串和获取字符串的信息。 123&quot;hello&quot;.charAt(0); // &quot;h&quot;&quot;hello, world&quot;.replace(&quot;world&quot;, &quot;mars&quot;); // &quot;hello, mars&quot;&quot;hello&quot;.toUpperCase(); // &quot;HELLO&quot; 其他类型与其他类型不同，JavaScript 中的 null 表示一个空值（non-value），必须使用 null 关键字才能访问，undefined 是一个“undefined（未定义）”类型的对象，表示一个未初始化的值，也就是还没有被分配的值。我们之后再具体讨论变量，但有一点可以先简单说明一下，JavaScript 允许声明变量但不对其赋值，一个未被赋值的变量就是 undefined 类型。还有一点需要说明的是，undefined 实际上是一个不允许修改的常量。 JavaScript 包含布尔类型，这个类型的变量有两个可能的值，分别是 true 和 false（两者都是关键字）。根据具体需要，JavaScript 按照如下规则将变量转换成布尔类型： false、0、空字符串（””）、NaN、null 和 undefined 被转换为 false 所有其他值被转换为 true 也可以使用 Boolean() 函数进行显式转换： 12Boolean(&quot;&quot;); // falseBoolean(234); // true","categories":[],"tags":[]},{"title":"基于 vue2 + vuex 构建一个具有 45 个页面的大型单页面应用","slug":"个页面的大型单页面应用","date":"2018-05-18T16:28:13.000Z","updated":"2021-02-26T16:49:29.483Z","comments":true,"path":"2018/05/19/个页面的大型单页面应用/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/19/个页面的大型单页面应用/","excerpt":"","text":"https://www.vue-js.com/topic/58abbd21a9c1282817afc28d github:https://github.com/bailicangdu/vue2-elm","categories":[],"tags":[]},{"title":"css3做banner","slug":"css3做banner","date":"2018-05-12T07:02:56.000Z","updated":"2021-02-26T16:49:29.480Z","comments":true,"path":"2018/05/12/css3做banner/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/12/css3做banner/","excerpt":"","text":"也是面试时候遇到的问题,回来随便弄了一个 在线地址：http://dflxm.oschina.io/code/ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;css3写一个banner&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; ul li &#123; list-style: none; &#125; .banner-box &#123; position: relative; width: 400px; height: 200px; overflow: hidden; &#125; .banner &#123; width: 1600px; position: absolute; left: 0; animation-name: bannerMove; animation-duration: 8s; animation-iteration-count: infinite; &#125; @keyframes bannerMove &#123; 0%, 30% &#123; left: 0; &#125; 35%, 65% &#123; left: -400px; &#125; 70%, 99% &#123; left: -800px; &#125; 100% &#123; left: -1200px; &#125; &#125; .banner li &#123; float: left; width: 400px; height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;banner-box&quot;&gt; &lt;ul class=&quot;banner&quot;&gt; &lt;li style=&quot;background-color:#f90;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#f00;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#9f0;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#333;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://akitsukiwong.github.io/tags/css/"}]},{"title":"ECharts学习","slug":"2018-05-12 ECharts学习","date":"2018-05-12T06:10:00.000Z","updated":"2021-02-26T16:49:29.472Z","comments":true,"path":"2018/05/12/2018-05-12 ECharts学习/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/12/2018-05-12 ECharts学习/","excerpt":"","text":"面试了很多家单位，都问到了ECharts，所以准备一下还是很有必要的 2018-5-27 更新： 新单位也用到了ECharts，画了几个，也不难，官方文档也很全 主要就这几个步骤 引用js 准备放图表的容器 初始化图表，设置参数 有其它个性化要求，根据官方的文档，改一改配置项都可以快速解决","categories":[{"name":"笔记","slug":"笔记","permalink":"https://akitsukiwong.github.io/categories/笔记/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"https://akitsukiwong.github.io/tags/echarts/"}]},{"title":"常见前端面试题","slug":"2018-05-10 常见前端面试题","date":"2018-05-10T14:20:00.000Z","updated":"2021-02-26T16:49:29.471Z","comments":true,"path":"2018/05/10/2018-05-10 常见前端面试题/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/10/2018-05-10 常见前端面试题/","excerpt":"","text":"HTML什么是盒子模型？在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素：a、b、span、img、input、strong、select、label、em、button、textarea块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img 块元素与内联元素的区别？1.块元素，总是在新行上开始；内联元素，和其他元素都在一行上。 2.块元素，能容纳其他块元素或内联元素；内联元素，只能容纳文本或者其他内联元素。 3.块元素中高度，行高以及顶和底边距都可控制；内联元素中高，行高及顶和底边距不可改变。 常见的块级元素 address – 地址 blockquote – 块引用 center – 举中对齐块 dir – 目录列表 div – 常用块级容易，也是CSS layout的主要标签 dl – 定义列表 fieldset – form控制组 form – 交互表单 h1 – 大标题 h2 – 副标题 h3 – 3级标题 h4 – 4级标题 h5 – 5级标题 h6 – 6级标题 hr – 水平分隔线 isindex – input prompt menu – 菜单列表 noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript – 可选脚本内容（对于不支持script的浏览器显示此内容） ol – 有序表单 p – 段落 pre – 格式化文本 table – 表格 ul – 无序列表 常见的内联元素 a – 锚点 abbr – 缩写 acronym – 首字 b – 粗体(不推荐) bdo – bidi override big – 大字体 br – 换行 cite – 引用 code – 计算机代码(在引用源码的时候需要) dfn – 定义字段 em – 强调 font – 字体设定(不推荐) i – 斜体 img – 图片 input – 输入框 kbd – 定义键盘文本 label – 表格标签 q – 短引用 s – 中划线(不推荐) samp – 定义范例计算机代码 select – 项目选择 small – 小字体文本 span – 常用内联容器，定义文本内区块 strike – 中划线 strong – 粗体强调 sub – 下标 sup – 上标 textarea – 多行文本输入框 tt – 电传文本 u – 下划线 CSSCSS实现垂直水平居中js如何理解闭包？定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。 表现形式：使函数外部能够调用函数内部定义的变量。 jQuery相关jQuery库中的$()是什么？$()函数是jQuery()函数的别称。$()函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $()函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。 其它","categories":[{"name":"面试","slug":"面试","permalink":"https://akitsukiwong.github.io/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://akitsukiwong.github.io/tags/面试/"}]},{"title":"随便做的一个个人简历","slug":"2018-05-10 随便做的一个个人简历","date":"2018-05-10T07:44:58.000Z","updated":"2021-02-26T16:49:29.471Z","comments":true,"path":"2018/05/10/2018-05-10 随便做的一个个人简历/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/10/2018-05-10 随便做的一个个人简历/","excerpt":"","text":"码云page地址: http://dflxm.oschina.io","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://akitsukiwong.github.io/tags/面试/"},{"name":"简历","slug":"简历","permalink":"https://akitsukiwong.github.io/tags/简历/"}]},{"title":"rem.js","slug":"2017-12-18 rem-js","date":"2017-12-18T07:25:00.000Z","updated":"2021-02-26T16:49:29.471Z","comments":true,"path":"2017/12/18/2017-12-18 rem-js/","link":"","permalink":"https://akitsukiwong.github.io/2017/12/18/2017-12-18 rem-js/","excerpt":"","text":"12345678910111213window.onload = function()&#123; /*720代表设计师给的设计稿的宽度，你的设计稿是多少，就写多少;100代表换算比例，这里写100是 为了以后好算,比如，你测量的一个宽度是100px,就可以写为1rem,以及1px=0.01rem等等*/ getRem(750,100)&#125;;window.onresize = function()&#123; getRem(750,100)&#125;;function getRem(pwidth,prem)&#123; var html = document.getElementsByTagName(&quot;html&quot;)[0]; var oWidth = document.body.clientWidth || document.documentElement.clientWidth; html.style.fontSize = oWidth/pwidth*prem + &quot;px&quot;;&#125;","categories":[{"name":"代码片段","slug":"代码片段","permalink":"https://akitsukiwong.github.io/categories/代码片段/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://akitsukiwong.github.io/tags/JS/"},{"name":"rem","slug":"rem","permalink":"https://akitsukiwong.github.io/tags/rem/"}]},{"title":"javascript高级程序设计学习笔记","slug":"2017-12-01 javascript高级程序设计学习笔记","date":"2017-11-30T17:45:00.000Z","updated":"2021-02-26T16:49:29.470Z","comments":true,"path":"2017/12/01/2017-12-01 javascript高级程序设计学习笔记/","link":"","permalink":"https://akitsukiwong.github.io/2017/12/01/2017-12-01 javascript高级程序设计学习笔记/","excerpt":"","text":"第一章 HTML中使用JavaScriptscript元素script中有六个属性 async charset defer language src type 标签的位置传统做法放在&lt;head&gt;中，js会被先加载页面会有延迟 所以把JavaScript引入放在&lt;body&gt;元素中页面元素的后面 这样先加载页面内容，用户会因为空白页面时间缩短而感到页面打开速度加快 延迟脚本HTML 4.01为&lt;script&gt;标签定义了defer属性。 相当于告诉浏览器立即下载延迟执行。 1&lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt; 异步脚本async 1&lt;script type=&apos;text/javascript&apos; async src=&apos;example.js&apos;&gt;&lt;/script&gt; 在XHTML中的用法XTML（可拓展超文本标记语言），是将HTML作为XML的应用而重新定于的一个标准规则比HTML严格 第二章 基本概念语法ECMAScript大量借鉴C及其他类C语言（Java等） 区分大小写ECMAScript中一切（变量、函数名和操作符）都区分大小写。 标识符标识符，指变量、函数、属性都名字，或者函数的参数。 第一个字符必须是字母、下划线（_）或者一个美元符号（$）； 其他字符可以是字母、下划线、美元符号或数字。 注释C风格注释 123456// 单行注释/** 这是一个多行*（块级）注释*/ 严格模式ECMAScript 5 引入严格模式 启用严格模式可在顶部添加use strict; 1234function()&#123; &quot;use strict&quot;; //函数体&#125; 语句分号结尾；代码块{ } 里面 关键字和保留字变量ECMAScript的变量是松散类型的，可以保存任何类型的数据。 定义变量使用 var 操作符 函数中var的是局部变量，省略var是全局变量 定义多个变量（用逗号隔开） 123var message = &quot;hi&quot; , found = false , age = 29 ; 数据类型ES中有五种简单的数据类型 1- Undefined —– 未定义 2- Null ————- 3- Boolean ——– 布尔值 4- Number ——— 数值 5- String ———— 还有一种复杂数据类型 Object typeof 操作符12var message = &quot;some string&quot; ;alert(typeof message) ; //&quot;string&quot; typeof 返回值 undefined —— 为定义 boolean ——— 布尔值 string ———— 字符串 number ———- 数值 object ———— 对象 或者 null function ———- 函数 undefined 类型var 声明变量但为对其加以初始化的值就是undefined Null类型Boolean 类型true和false Number类型 整数和浮点数（带小数点的数值，小数点后至少有一位数字） 浮点数值极大极小的数字用e表示法（科学计数法） 12var floatNum = 3.125e7 //31250000var floatNum = 3e-17 //0.00000000000000003 浮点数值最高精度为17位小数，其计算精度远远不如整数，例如 0.1 + 0.2 结果不是 0.3 而是 0.300000000000004。 数值范围 Infinity （负无穷） Infinity （正无穷） NaN非数值 （not a number） 任何涉及NaN的操作都会返回NaN NaN和任何值都不相等，包括NaN 1alert（NaN == NaN） //false isNaN（）函数，查询是否为数值 123alert(isNaN(NaN)); //truealert(isNaN(10)); //false(10是一个数值)alert(isNaN(&quot;blue&quot;)) //true 数值转换 number() – 如果是布尔值，返回0和1 – 如果是数字，简单的传入和返回 – 如果是null，返回0 – 如果是undefined，返回NaN – 如果是字符串……… – 如果是对象，调用valueOf( ) 方法，如果转换的对象是NaN，调用toString（）方法 parseInt() parseFloat() string 类型单引号和双引号字符串形式完全相同 字符字面量string数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符 \\n 换行 \\t 制表 \\b 退格 等… 字符串的特点ES中字符串是不可变的，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充改变量。 转换为字符串toString（） Object 类型对象其实就是一组数据和功能的集合。对象可以通过new操作符来创建 1var o = new Object( ) ; （括号可以省略，但不推荐） 操作符一元操作符只能操作一个值但操作符叫做一元操作符。 递增和递减操作符++age；等于age = age +1; –age; 等于age = age - 1； 【前置型】会影响语句的结果，求值之前执行 【后置型】不会影响语句结果，求值之后执行 例子 1234var num1 = 2 ;var num2 = 20 ;var num3 = --num + num2 ; //21var num4 = num1 + num2 ; //21 1234var num1 = 2 ;var num2 = 20 ;var num3 = num-- + num2 ; //22var num4 = num1 + num2 ; //21 一元加和减操作符一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。 12var num = 25 ;num = +num ; //25 一元减操作符主要表示负数。 位操作符转化位二进制 12var num = -18 ;alert(num.toString(2)) ; //&quot;-10010&quot; 按位非（NOT）按位非由一个波浪号【～】表示，执行按位非的结果就是返回数值的反码（二进制逐位取反） 按位与（AND）按位与由一个和字符号【&amp;】表示，都是1返回1，有0就返回0 按位或（OR）按位或由一个竖线符号【|】表示，有1返回1，都是0才返回0 左移【&lt;&lt;】，会将数值的所有位向左移动制定的位数。 12var oldValue = 2 ; //二进制10var newValue = oldValue &lt;&lt; 5; //二进制100000，即64 右移【&gt;&gt;】,会将数值向右移动，但保留符号位 12var oldValue = 64 ; //二进制1000000var newValue = oldValue &gt;&gt; 5; //二进制10，即2 无符号右移【&gt;&gt;&gt;】，会将数值的所有32位都向右移动。 对于正数于【&gt;&gt;】一样，对于负数无符号右移后结果会变得非常大，因为无符号右移会移动所有的二进制码。 12var oldValue = -64 ; //二进制1000000var newValue = oldValue &gt;&gt;&gt; 5; //十进制134217726 3.5.3 布尔操作符布尔操作符一共三个 非（NOT）【 ！】 与（AND） 【 &amp;&amp; 】 或（OR） 【 || 】 乘性操作符 乘法 【 * 】 除法 【 / 】 求模 （余数） 【 % 】 1var result = 26 % 5 ; //等于 1 加性操作符 加法 【 + 】 减法 【 - 】 关系操作符 小于 【 &lt; 】 大于 【 &gt; 】 小于等于 【 &lt;= 】 大于等于 【 &gt;= 】 相等操作符相等和不相等（先转换再比较） 全等和不全等（仅比较不转换） 相等和不相等 相等 【 == 】 不相等 【 != 】 全等和不全等 全等 【 === 】 不全等 【 !== 】 条件操作符1variable = boolean_expression ? true_value : false_value 基于对boolean_expression求值对结果，决定给变量variable赋什么值。如果为true，赋true_value值，如果为false，赋false_value值 1var max = (num1 &gt; num2) ? num1 : num2 ; max将保存最大对值，表达式意思是：如果num1大于num2，给max赋num1值，反之赋值num2 赋值操作符简单赋值操作符由符号【 = 】表示，作用：把右侧对值赋给左侧对变量 逗号操作符可以在一条语句中执行多个操作 1var num1 = 1, num2 = 2, num3 = 3; 逗号操作符还可以用作赋值，会返回表达式对最后一项。 1var num = ( 5, 1, 4, 8, 0); //num的值为0，因为0是表达式的最后一项 语句if语句12345if ( condition【条件】 ) &#123; statement1【语句1】； &#125; else &#123; statement【语句2】； &#125; 1234567if( condition1【条件1】 )&#123; statement1【语句1】；&#125; else if ( condition2【条件2】 )&#123; statemen2【语句2】；&#125; else &#123; statement3【语句3】；&#125; do-while 语句12345do&#123; statement【语句】&#125; while &#123; expression【条件】&#125; while 语句123while( expression【条件】 )&#123; statement【语句】&#125; for语句for语句也是一种前端测试循环语句，它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。 123for(initialization【初始化】; expression【条件】; post-loop-expression【循环表达式】)&#123; statement【语句】;&#125; 当三个表达式全部省略就会创建一个无限循环 123for( ; ; )&#123; //无限循环 doSomething();&#125; 3.6.5 for-in语句for-in语句是一种精准当迭代语句，可以用来枚举对象当属性。 123for( property【属性】 in expression)&#123; statement【语句】&#125; 3.6.6 label语句1label【标签】: statement 123start: for (var i = 0; i &lt; count; i++)&#123; alert(i);&#125; 3.6.7 break和continue语句break和continue用于在循环中精确的控制代码的执行【break】立即退出循环，强制继续执行循环后面的语句【continue】立即退出循环，退出循环后会从循环的顶部继续执行break和continue都可以和label语句联合使用，从而返回代码中特定的位置。 3.6.8 with语句123with(expreession【条件】)&#123; statement【语句】&#125; with语句主要目的是为了简化多次编写同一个对象的工作123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 以上代码都包含了location对象，用with语句12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 不建议使用过with语句 3.6.9 switch 语句1234567891011switch(expression)&#123; case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; 相当于if-else语句简化写法123456789if(i == 25)&#123; alert(&quot;25&quot;);&#125; else if(i == 35)&#123; alert(&quot;35&quot;)&#125; else if(i == 45)&#123; alert(&quot;45&quot;)&#125;else &#123; alert(&quot;other&quot;)&#125; 等价于switch语句12345678910111213switch( i )&#123; case 25: alert(&quot;25&quot;); break; case 35: alert(&quot;35&quot;); break; case 45: alert(&quot;45&quot;); break; default: alert(&quot;other&quot;);&#125; 3.7 函数123function functionName(arg0, arg1, ...,argN)&#123; statements&#125; 位于语句之后都任何代码都永远不会执行 3.7.1 理解参数命名的参数只提供便利，但不是必须的 3.7.2 没有重载第三章 变量、作用域和内存问题4.1 基本类型和引用类型的值【基本类型】简单的数据段【引用类型】可能有多个值构成的对象 4.1.1 动态的属性4.1.2 复制变量值4.1.3 传递参数当在函数内部重写obj时，这个变量引用的就是一个局部对象，这个局部对象会在函数执行完毕后立即销毁。12345678function setName(obj)&#123; obj.name = &quot;Nicholas&quot;; obj = new Object(); obj.name = &quot;Greg&quot;;&#125;var person = new Object();set.Name(person);alert(person.name); //&quot;Nicholas&quot; 4.1.4 检测类型instanceof操作符1result = variable instanceof constructor 例子123alert(person instanceof Object); //变量person是Object吗？alert(colors instanceof Array); //变量colors是Array吗？alert(pattern instanceof RegExp); //变量pattern是RegExp吗？ 4.2 执行环境及作用域延长作用域链4.2.2 没有块级作用域声明变量使用var声明的变量会自动添加到最接近到环境中如果初始化变量没有使用var 声明，该变量会自动被添加到全局环境。 查询标识符4.3 垃圾收集js具有垃圾自动收集功能 4.3.1 标记清除4.3.2 引用计数4.3.3 性能问题4.3.4 管理内存第五章 引用类型5.1 Object类型创建Object实例有两种方式 使用new操作符后跟Object构造函数123var person = new Object();person.name = &quot;Nicholas&quot;;person.age = &quot;29&quot;; Object可以省略，用大括号代替123var person = &#123;&#125;;person.name = &quot;Nicholas&quot;;person.age = &quot;29&quot;; 使用对象字面量表示法，是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。1234var person = &#123; name = &quot;Nicholas&quot; , age = 29&#125;; 访问对象属性可以用点表示法，也可以用方括号12alert(person.name); //Nicholasalert(person[&quot;name&quot;]); //Nicholas 方括号语法的主要优点是可以通过变量来访问属性12var propertyName = &quot;name&quot;;alert(person[propertyName]); //Nicholas 5.2 array类型创建数组有两种方法1var colors = new Array(); 创建length值为20的数组1var colors = new Array( 20 ); 也可以向Array构造函数传递数组中应该包含的项1var colors = new Array( &quot;red&quot;,&quot;blue&quot;,&quot;green&quot; ); 可以省略new操作符1var colors = Array(); 可以使用字面量表示法，数组用方括号表示，逗号隔开12var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; var names = [] //创建一个空数组 利用length属性可以方便的在数组末尾添加新项123var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; colors[colors.length] = &quot;black&quot;; //在位置3添加一种颜色colors[colors.length] = &quot;brown&quot; //在位置4添加一种颜色 5.2.1 检测数组123if(value instanceof Array)&#123; //do something&#125; ES5新增的Array.isArray()方法，用于确定某个值到底是不是数组，而不管它是在哪个全局环境下创建的。123if(Array.isArray(value))&#123; //do something&#125; 5.2.2 转换方法join方法可以使用不同的分隔符来构建这个字符串join方法只接受一个参数，用作分隔符的字符串123var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];alert(colors.join(&quot;,&quot;)); //red,blue,greenalert(colors.join(&quot;||&quot;)); //red||blue||green 5.2.3 栈方法栈是一种【LOFO】后进先出的数据结构栈中 插入叫做推入，移除叫做弹出 push() 接收任意数量的参数逐个添加到数组末尾（从末尾加）pop() 从数组末尾移除最后一项（删最后一个） 5.2.4 队列方法队列是【FIFO】先进先出 shift() 移除数组中的第一个项（删第一个）unshift() 在数组前端添加任意个项（从前面加） 5.2.5 重排列方法reverse() 翻转数组项的顺序sort() 升序排列（首字母排序，不是按大小） 比较函数 升序1function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //0,1,5,10,15 降序1function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //15,10,5,1,0 5.2.6 操作方法concat() 末尾添加数组 splice() 数组中部插入项 删除splice（要删除的第一项的位置， 要删除的项数）splice( 0, 2 ) 删除数组中前两项 插入splice( 起始位置， 0（要删除的项数）， 要插入的项)splice( 2, 0, &quot;red&quot;, &quot;green&quot; ) 从当前数组的位置2 开始插入字符串“red” 和“green” 替换splice( 起始位置， 要删除的项数， 要插入的任意数量的项)splice( 2, 1, &quot;red&quot;, &quot;green&quot; ) 会删除当前数组位置 2 的项， 然后再从位置 2 开始插入字符串 “red” 和“green”例子 1var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; var removed = colors.splice(0,1); //remove the first item alert(colors); //green,blue alert(removed); //red - one item array removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); //insert two items at position 1 alert(colors); //green,yellow,orange,blue alert(removed); //empty array removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //insert two values, remove one alert(colors); //green,red,purple,orange,blue alert(removed); //yellow - one item array 5.2.7 位置方法indexOf() 从数组的开头（位置0）开始向后查找， 没找到的情况下会返回-1lastIndexOf 从数组的末尾开始向前查找， 没找到的情况下会返回-1例子 1234567891011121314var numbers = [1,2,3,4,5,4,3,2,1]; alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5 alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3 var person = &#123; name: &quot;Nicholas&quot; &#125;;var people = [&#123; name: &quot;Nicholas&quot; &#125;];var morePeople = [person]; alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 5.2.8 迭代方法every() 对数组中的每一项运行给定函数， 如果该函数对每一项都返回true， 则返回true。filter() 对数组中的每一项运行给定函数， 返回该函数会返回 true 的项组成的数组。forEach() 对数组中的每一项运行给定的函数。 这个方法没有返回值。map() 对数组中的每一项运行给定的函数， 返回每次函数调用的结果组成的数组。some() 对数组中的每一项运行给定的函数， 如果该函数对任一项返回true， 则返回true。 以上方法都不会修改数组中的包含的值， 传入这些方法会接受三个参数（数组项的值， 该项在数组中的位置， 数组对象本身） every() some() 例子以上代码调用的every() 和 some() ， 传入的函数只要给定项大于 2 就会返回true， 对于every()，它返回的是false， 因为只有部分数组项符合条件，对于some() 就返回true， 因为至少有一项是大于 2 的。 12345678910111213var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true filter() 例子通过filter（）方法创建并返回一个所有数值都大于 2 的数组 1234567var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3] map() 例子给数组中每一项都乘以 21234567var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] forEach() 例子1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;) 5.2.9 归并方法reduce() 从数组第一项开始逐个遍历到最后reduceRight() 从数组最后一项开始，向前遍历到第一项四个参数（前一个值， 当前值， 项的索引， 数组对象） reduce() 例子求数组所有值之和12345var values = [1,2,3,4,5]; var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur; &#125;); alert(sum); reduceRight() 例子求数组所有值之和 12345var values = [1,2,3,4,5]; var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur; &#125;); alert(sum); 5.3 Data 类型Data.parse()-接收一个表示日期的字符串参数，然后根据这个字符串返回相应日期的毫秒数Data.UTC()-同样返回日期的毫秒数，但参数分别是年份、基于0但月份（一月是0，二月是1…）、月中的哪一天（1-31）、小时数（0-23）、分钟、秒、毫秒数。只有前两个参数，年和月是必须的 12345//GMT时间2000年1月1日午夜零时var y2k = new Data(Data.UTC(2000,0));//GMT时间2005年5月5日下午5:55:55var allFive = new Data(Data.UTC(2005,4,5,17,55,55)); ES5中添加来Data.now()方法 5.3.1 继承的方法","categories":[{"name":"笔记","slug":"笔记","permalink":"https://akitsukiwong.github.io/categories/笔记/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://akitsukiwong.github.io/tags/JS/"}]},{"title":"数组常用方法","slug":"2017-11-20 数组常用方法","date":"2017-11-20T07:04:00.000Z","updated":"2021-02-26T16:49:29.470Z","comments":true,"path":"2017/11/20/2017-11-20 数组常用方法/","link":"","permalink":"https://akitsukiwong.github.io/2017/11/20/2017-11-20 数组常用方法/","excerpt":"","text":"栈方法push() 接收任意数量的参数逐个添加到数组末尾（从末尾加） pop() 从数组末尾移除最后一项（删最后一个） 队列方法shift() 移除数组中的第一个项（删第一个） unshift() 在数组前端添加任意个项（从前面加） 重排列方法reverse() 翻转数组项的顺序 sort() 升序排列（首字母排序，不是按大小） 比较函数升序12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //0,1,5,10,15 降序12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //15,10,5,1,0 操作方法concat() 末尾添加数组 1contan( [ &quot;black&quot; , &quot;yellow&quot; , &quot;red&quot; ] ) splice() 数组中部插入项 删除splice（要删除的第一项的位置， 要删除的项数） splice( 0, 2 ) 删除数组中前两项 插入splice( 起始位置， 0（要删除的项数）， 要插入的项) splice( 2, 0, &quot;red&quot;, &quot;green&quot; )从当前数组的位置2 开始插入字符串“red” 和“green” 替换splice( 起始位置， 要删除的项数， 要插入的任意数量的项) splice( 2, 1, &quot;red&quot;, &quot;green&quot; ) 会删除当前数组位置 2 的项， 然后再从位置 2 开始插入字符串 “red” 和“green” 例子 123456789101112var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1); //remove the first itemalert(colors); //green,bluealert(removed); //red - one item array removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); //insert two items at position 1alert(colors); //green,yellow,orange,bluealert(removed); //empty array removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //insert two values, remove onealert(colors); //green,red,purple,orange,bluealert(removed); //yellow - one item array 位置方法indexOf() 从数组的开头（位置0）开始向后查找， 没找到的情况下会返回-1 lastIndexOf 从数组的末尾开始向前查找， 没找到的情况下会返回-1 例子 1234567891011121314var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5 alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3 var person = &#123; name: &quot;Nicholas&quot; &#125;;var people = [&#123; name: &quot;Nicholas&quot; &#125;];var morePeople = [person]; alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 迭代方法every() 对数组中的每一项运行给定函数， 如果该函数对每一项都返回true， 则返回true。 filter() 对数组中的每一项运行给定函数， 返回该函数会返回 true 的项组成的数组。 forEach() 对数组中的每一项运行给定的函数。 这个方法没有返回值。 map() 对数组中的每一项运行给定的函数， 返回每次函数调用的结果组成的数组。 some() 对数组中的每一项运行给定的函数， 如果该函数对任一项返回true， 则返回true。 以上方法都不会修改数组中的包含的值， 传入这些方法会接受三个参数（数组项的值， 该项在数组中的位置， 数组对象本身） every() some() 例子以上代码调用的every() 和 some() ， 传入的函数只要给定项大于 2 就会返回true， 对于every()，它返回的是false， 因为只有部分数组项符合条件，对于some() 就返回true， 因为至少有一项是大于 2 的。 12345678910111213var numbers = [1,2,3,4,5,4,3,2,1]; var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(everyResult); //false var someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(someResult); //true filter() 例子通过filter（）方法创建并返回一个所有数值都大于 2 的数组 1234567var numbers = [1,2,3,4,5,4,3,2,1]; var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(filterResult); //[3,4,5,4,3] map() 例子给数组中每一项都乘以 2 1234567var numbers = [1,2,3,4,5,4,3,2,1]; var mapResult = numbers.map(function(item, index, array)&#123; return item * 2; &#125;); alert(mapResult); //[2,4,6,8,10,8,6,4,2] forEach() 例子1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;) 归并方法reduce() 从数组第一项开始逐个遍历到最后 reduceRight() 从数组最后一项开始，向前遍历到第一项 四个参数（前一个值， 当前值， 项的索引， 数组对象） reduce() 例子求数组所有值之和 12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); reduceRight() 例子求数组所有值之和 12345var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum);","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://akitsukiwong.github.io/categories/前端学习/"}],"tags":[{"name":"js","slug":"js","permalink":"https://akitsukiwong.github.io/tags/js/"},{"name":"数组","slug":"数组","permalink":"https://akitsukiwong.github.io/tags/数组/"}]},{"title":"Markdown学习","slug":"2017-11-13 Markdown学习","date":"2017-05-13T07:16:00.000Z","updated":"2021-02-26T16:49:29.470Z","comments":true,"path":"2017/05/13/2017-11-13 Markdown学习/","link":"","permalink":"https://akitsukiwong.github.io/2017/05/13/2017-11-13 Markdown学习/","excerpt":"","text":"一级标题H1二级标题H2三级标题H3四级标题H4五级标题H5六级标题H6无序列表 列表1 列表2 列表3 或者 列表1 列表1 列表1 再或者 列表1 列表1 列表1 引用 这个样子引用，啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦 还有个二级的引用，哈哈哈哈哈哈哈哈哈哈哈哈或或或或或或或或或或或或或或或或或或或或或 三级的引用，看了啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦 回归一级吧，记得要空一行 例子 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 代码区块这是一个普通段落： 这是一个代码区块。 前面一个制表符就是代码 或者四个空格 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理 分割线 链接I get 10 times more traffic from Google than fromYahoo or MSN. I get 10 times more traffic from Google than fromYahoo or MSN. 一小段代码Use the printf() function.There is a literal backtick (`) here.A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 dog bird cat foo foo foo bar bar bar baz baz baz","categories":[{"name":"学习","slug":"学习","permalink":"https://akitsukiwong.github.io/categories/学习/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://akitsukiwong.github.io/tags/Markdown/"}]},{"title":"css画三角形","slug":"css画三角形","date":"2017-05-12T06:13:00.000Z","updated":"2021-02-26T16:49:29.480Z","comments":true,"path":"2017/05/12/css画三角形/","link":"","permalink":"https://akitsukiwong.github.io/2017/05/12/css画三角形/","excerpt":"","text":"面试时候遇到的问题，只要设置两个边框透明就行了,学会了这个，妈妈再也不怕我面试的时候被要求画三角形了 上三角 1234567#triangle-up &#123;width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-bottom: 100px solid red;&#125; 下三角 1234567#triangle-down &#123;width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-top: 100px solid red;&#125; 左三角 1234567#triangle-left &#123;width: 0;height: 0;border-top: 50px solid transparent;border-right: 100px solid red;border-bottom: 50px solid transparent;&#125; 右三角 1234567#triangle-right &#123;width: 0;height: 0;border-top: 50px solid transparent;border-left: 100px solid red;border-bottom: 50px solid transparent;&#125;","categories":[{"name":"代码片段","slug":"代码片段","permalink":"https://akitsukiwong.github.io/categories/代码片段/"}],"tags":[{"name":"css","slug":"css","permalink":"https://akitsukiwong.github.io/tags/css/"}]},{"title":"hexo的常用命令","slug":"2018-05-10 hexo的常用命令","date":"2017-05-09T17:43:00.000Z","updated":"2021-02-26T16:49:29.471Z","comments":true,"path":"2017/05/10/2018-05-10 hexo的常用命令/","link":"","permalink":"https://akitsukiwong.github.io/2017/05/10/2018-05-10 hexo的常用命令/","excerpt":"","text":"指令新建一篇文章1$ hexo new 新的文章名称 简写 1$ hexo n 新的文章名称 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: Hexokeywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 清除缓存文件 db.json 和已生成的静态文件 public1$ hexo clean 生成静态文件1$ hexo generate 简写 1$ hexo g 自动生成网站静态文件，并部署到设定的仓库1$ hexo deploy 简写 1$ hexo d 启动本地服务器，用于预览主题。默认地址： http://localhost:4000/ 1$ hexo s","categories":[{"name":"笔记","slug":"笔记","permalink":"https://akitsukiwong.github.io/categories/笔记/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://akitsukiwong.github.io/tags/hexo/"}]},{"title":"CSS初始化","slug":"2018-05-11 CSS初始化","date":"2017-05-01T09:24:00.000Z","updated":"2021-02-26T16:49:29.472Z","comments":true,"path":"2017/05/01/2018-05-11 CSS初始化/","link":"","permalink":"https://akitsukiwong.github.io/2017/05/01/2018-05-11 CSS初始化/","excerpt":"","text":"为什么初始化css?考虑到浏览器兼容性问题，不同浏览器对标签的默认值是不同的 通用初始化样式1234567891011121314151617181920212223242526272829303132333435body&#123; margin: 0;padding: 0;font-family: &quot;微软雅黑&quot;;overflow: hidden;&#125;body,html&#123;-webkit-text-size-adjust: none;width: 100%;height: 100%;&#125;*&#123;text-decoration: none;list-style: none;&#125;img&#123;border: 0px;&#125;ul,li,dl,dd,dt,p,ol,h1,h2,h3,h4,h5&#123;font-size: 12px;font-weight: 100;padding: 0;margin: 0;&#125;.wrap&#123;margin: 0 auto;&#125;.fl&#123;float: left;&#125;.fr&#123;float: right;&#125;.index&#123;overflow: hidden;&#125;.clr&#123;clear:both; height:0px; width:100%; font-size:1px; line-height:0px; visibility:hidden; overflow:hidden;&#125;.pointer&#123;cursor:pointer;&#125;a,input,button&#123; outline:none; &#125;::-moz-focus-inner&#123;border:0px;&#125;/*a:link &#123;color:#0f0;text-decoration:none;&#125; a:visited &#123;color: #FFFF00; text-decoration:none;&#125; a:hover &#123;color: #00FF00; text-decoration:underline;&#125; a:active &#123;color: #0000FF; text-decoration:underline;&#125;*/a&#123;color: #000;&#125;.wrapper&#123;clear: both;width: 100%;&#125;table &#123; border-collapse:collapse; &#125;word-break:break-all /*文字换行*//*white-space:nowrap 文字不换行*//*默认滚动条样式修改ie9 google Firefox 等高版本浏览器有效*//*::selection &#123;background: #D03333;color: white;text-shadow: none;&#125;::-webkit-scrollbar-track-piece&#123;width:10px;background-color:#f2f2f2&#125;::-webkit-scrollbar&#123;width:10px;height:6px&#125;::-webkit-scrollbar-thumb&#123;height:50px;background-color:rgba(0,0,0,.3);&#125;::-webkit-scrollbar-thumb:hover&#123;background:#cc0000&#125;*//*渐变*//*background-image: -moz-linear-gradient(top, #8fa1ff, #3757fa);background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #ff4f02), color-stop(1, #8f2c00)); Saf4+, Chrome filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=&apos;#c6ff00&apos;, endColorstr=&apos;#538300&apos;, GradientType=&apos;0&apos;); IE*/ 另一种通用化样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* CSS Document */html, body, div, span, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,abbr, address, cite, code,del, dfn, em, img, ins,kbd, q, samp,small, strong, sub, sup, var,b, i,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot,thead,tr, th, td,article, aside, canvas, details, figcaption, figure, footer, header, hgroup, menu, nav, section, summary,time, mark, audio, video &#123; margin:0; padding:0; border:0; outline:0; font-size:100%; vertical-align:baseline; background:transparent; outline-style:none;/*FF*/ &#125;body &#123; line-height:1;&#125;a&#123; margin:0; padding:0; border:0; font-size:100%; vertical-align:baseline; background:transparent;&#125;a:hover,a:focus&#123; text-decoration:none; bblr:expression(this.onFocus=this.blur());/*IE*/ outline-style:none;/*FF*/ &#125;table &#123; border-collapse:collapse; border-spacing:0;&#125;input, select &#123; vertical-align:middle;&#125;/*css为clearfix，清除浮动*/.clearfix::before,.clearfix::after&#123; content: &quot;&quot;; height: 0; line-height: 0; display: block; visibility: hidden; clear: both;&#125;.clearfix:after&#123;clear:both;&#125; .clearfix&#123; *zoom:1;/*IE/7/6*/&#125; 雅虎工程师提供的CSS初始化示例代码12345678910111213141516body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px; &#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption, cite, code, dfn, em, strong, th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none; &#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123;overflow-y: scroll;&#125; .clearfix:after &#123;content: &quot;.&quot;; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; 腾讯官网 样式初始化123456789body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select&#123;margin:0;padding:0&#125; body&#123;font:12px&quot;宋体&quot;,&quot;Arial Narrow&quot;,HELVETICA;background:#fff;-webkit-text-size-adjust:100%;&#125; a&#123;color:#2d374b;text-decoration:none&#125; a:hover&#123;color:#cd0200;text-decoration:underline&#125; em&#123;font-style:normal&#125; li&#123;list-style:none&#125; img&#123;border:0;vertical-align:middle&#125; table&#123;border-collapse:collapse;border-spacing:0&#125; p&#123;word-wrap:break-word&#125; 新浪官网 样式初始化12345678910body,ul,ol,li,p,h1,h2,h3,h4,h5,h6,form,fieldset,table,td,img,div&#123;margin:0;padding:0;border:0;&#125; body&#123;background:#fff;color:#333;font-size:12px; margin-top:5px;font-family:&quot;SimSun&quot;,&quot;宋体&quot;,&quot;Arial Narrow&quot;;&#125; ul,ol&#123;list-style-type:none;&#125; select,input,img,select&#123;vertical-align:middle;&#125; a&#123;text-decoration:none;&#125; a:link&#123;color:#009;&#125; a:visited&#123;color:#800080;&#125; a:hover,a:active,a:focus&#123;color:#c00;text-decoration:underline;&#125; 淘宝官网 样式初始化12345678910111213141516171819202122232425body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125; body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \\5b8b\\4f53; &#125; h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125; address, cite, dfn, em, var &#123; font-style:normal; &#125; code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125; small&#123; font-size:12px; &#125; ul, ol &#123; list-style:none; &#125; a &#123; text-decoration:none; &#125; a:hover &#123; text-decoration:underline; &#125; sup &#123; vertical-align:text-top; &#125; sub&#123; vertical-align:text-bottom; &#125; legend &#123; color:#000; &#125; fieldset, img &#123; border:0; &#125; button, input, select, textarea &#123; font-size:100%; &#125; table &#123; border-collapse:collapse; border-spacing:0; &#125; 网易官网 样式初始化html &#123;overflow-y:scroll;&#125; body &#123;margin:0; padding:29px00; font:12px&quot;\\5B8B\\4F53&quot;,sans-serif;background:#ffffff;&#125; div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p&#123;padding:0; margin:0;&#125; table,td,tr,th&#123;font-size:12px;&#125; li&#123;list-style-type:none;&#125; img&#123;vertical-align:top;border:0;&#125; ol,ul &#123;list-style:none;&#125; h1,h2,h3,h4,h5,h6&#123;font-size:12px; font-weight:normal;&#125; address,cite,code,em,th &#123;font-weight:normal; font-style:normal;&#125; 下面顺便给出admin10000.com 的html模板，用于每次新开发页面使用。123456789101112131415161718&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;zh-cn&quot;&gt; &lt;head&gt; &lt;title&gt;网站标题 - Admin10000.com &lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot; /&gt; &lt;meta name=&quot;Author&quot; content=&quot;网页作者&quot; /&gt; &lt;meta name=&quot;Copyright&quot; content=&quot;网站版权&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;网站关键字&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;网站描述&quot; /&gt; &lt;link rel=&quot;Shortcut Icon&quot; href=&quot;网站.ico图标路径&quot; /&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;CSS文件路径&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;JS文件路径&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"代码片段","slug":"代码片段","permalink":"https://akitsukiwong.github.io/categories/代码片段/"}],"tags":[{"name":"css","slug":"css","permalink":"https://akitsukiwong.github.io/tags/css/"}]},{"title":"pc端移动端跳转js","slug":"2017-12-18 pc端移动端跳转js","date":"2016-12-17T17:43:00.000Z","updated":"2021-02-26T16:49:29.471Z","comments":true,"path":"2016/12/18/2017-12-18 pc端移动端跳转js/","link":"","permalink":"https://akitsukiwong.github.io/2016/12/18/2017-12-18 pc端移动端跳转js/","excerpt":"经常用到的跳转代码","text":"经常用到的跳转代码 if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href=”你的手机版地址”;}else{ window.location.href=”你的电脑版地址”;}","categories":[{"name":"代码片段","slug":"代码片段","permalink":"https://akitsukiwong.github.io/categories/代码片段/"}],"tags":[{"name":"跳转","slug":"跳转","permalink":"https://akitsukiwong.github.io/tags/跳转/"},{"name":"JS","slug":"JS","permalink":"https://akitsukiwong.github.io/tags/JS/"}]},{"title":"css3优惠券/邮票","slug":"css3优惠券-邮票","date":"2016-05-18T12:17:00.000Z","updated":"2021-02-26T16:49:29.479Z","comments":true,"path":"2016/05/18/css3优惠券-邮票/","link":"","permalink":"https://akitsukiwong.github.io/2016/05/18/css3优惠券-邮票/","excerpt":"","text":"css3写的优惠券/邮票 码云地址：http://dflxm.gitee.io/code/%E9%82%AE%E7%A5%A8.html","categories":[],"tags":[{"name":"css3","slug":"css3","permalink":"https://akitsukiwong.github.io/tags/css3/"}]}]}