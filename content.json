{"meta":{"title":"渣博客","subtitle":"哈哈哈","description":"汪秋月的个人博客","author":"汪秋月","url":"https://akitsukiwong.github.io"},"pages":[{"title":"关于我","date":"2018-05-10T16:15:47.000Z","updated":"2018-05-11T06:28:29.737Z","comments":true,"path":"about/index.html","permalink":"https://akitsukiwong.github.io/about/index.html","excerpt":"","text":"这是一个渣渣前端的个人博客 个人简历网站版 http://dflxm.oschina.io"}],"posts":[{"title":"写插件教程","slug":"写插件教程","date":"2018-09-07T06:45:37.000Z","updated":"2018-09-07T06:45:39.366Z","comments":true,"path":"2018/09/07/写插件教程/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/07/写插件教程/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #demo-1, #demo-2 &#123; width: 200px; height: 200px; border: 1px solid #ddd; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;点击add可以添加个自input的内容到div里并实现变颜色&lt;/h3&gt; &lt;!--组件实例1--&gt; &lt;div id=&quot;demo-1&quot;&gt; &lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;好的&quot; /&gt; &lt;button id=&quot;add-1&quot;&gt;add&lt;/button&gt; &lt;/div&gt; &lt;br /&gt; &lt;br /&gt; &lt;!--组件实例2--&gt; &lt;div id=&quot;demo-2&quot;&gt; &lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;11&quot; /&gt; &lt;button id=&quot;add-2&quot;&gt;add&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //这里是插件的代码；我为了方便都写到一个html中了；请把这个script标签中的内容单独写在一个js文件里 //整个插件写在一个立即执行函数里；就是function()&#123;&#125;();函数自执行；保证里面的变量不会与外界互相影响 //头部的win啊,doc啊 $ 啊都是底部的window,document,jQuery的映射；方便内部直接调用； //当然你不引用jq的话头部的$和底部的jQuery干掉；你若引用了更过的依赖可以依次添加； //最后面的undefined可不写；最好写了；保证里面再出现的undefined是未定义的意思；不被其他东西赋值； //好了下面是时候展现真正的技术了 //function前的!号(叹号)或者;(分号)这不是写错了,为了防止那个二货写的js结束没有分号；而可能发生报错 /* ;function(win,doc,$,undefined)&#123; &#125;(window,document,jQuery) 或者写在一个闭包里(function()&#123; &#125;()) */ (function(win, doc, undefined) &#123; //我们随便写一个插件吧 比如你要点击按钮 添加input的值到 div里 var addHtml = function(demo, btn) &#123; //插件名，调用的时候直接new一下插件名就行了并传参数或者传对象(一般这个函数名手写字母大写比较好，构造函数嘛，其实也是函数) //很明显我要传id名；这里传什么都可以的其实； this.div = doc.getElementById(demo); //为什么把获取的id传给this.div呢？this的指向为调用的实例；我们此时姑且认为this就指向这个函数；因为这样我们之后再想获取这个div就可以直接用this.div了好吗；而不是在document.getElementById（。。。。） this.btn = doc.getElementById(btn); this.Input = this.div.getElementsByTagName(&quot;input&quot;)[0]; //既然找到了div我们在找下div下面的input；当然你要不input用获取id的形式传参数我没有意见 this.num = 0; //你也可以写一些其他的默认的东西；比如默认的变量啦；方便下面调用；这里写了什么都不会报错；只是有用没用的问题这行可以忽略 this.author = &quot;lianxiaozhuang&quot;; this.init(); //执行下你下面写的函数吧；你想想；如果整个插件没有执行函数；多不好；一堆方法function就不调用；对；这里是调用的时候最开始执行的函数 &#125; //；给构造函数addHtml对象原型里添加属性（方法） addHtml.prototype = &#123; //给函数写方法；这里可能不止一个函数；你还记得你在全局里写一个个的function吗；贼乱； //找也不好找；把一个个函数都写到对象的属性里；调用函数就直接调用对象的属性； constructor: addHtml, //构造器指向构造函数；这行其实不写没啥毛病；不过有时候防止构造器指向Object的情况；你还是装逼写上吧； init: function() &#123; //这里的init；你也可以写成 nimade:function()&#123; &#125;都没有问题；就是在addHtml函数里this.init();执行下；你明白了这里的this了吧；整个插件里this都是只得这个函数（实例）；除非你又引入了其他的函数里的（其他函数里的可能指向就是window了） var _self = this; ////把this保存下来防止在局部函数内部取不到（局部函数内部取得this可能是别的） this.btn.onclick = function() &#123; var _val = _self.Input.value; var tempdiv = doc.createElement(&quot;div&quot;); //创建临时div存放获取input的值 tempdiv.innerHTML = _val; //console.log(tempdiv); _self.div.appendChild(tempdiv); _self.setColor(); //你把所有方法都写在init里绝对没问题；还是那句话；说好的松耦合呢；说好的不写一堆堆的function一层层乱套呢 &#125;; &#125;, setColor: function() &#123; //console.log(this.div) this.div.style.color = &quot;red&quot; &#125; /*, otherFun()&#123; //当然你还可以扩展其他方法；这些方法之间都可以互相调用； 只要用this.方法名 就行了；如果在取不到this比如上面的click函数中的this指向点击的button；只要在写var _self = this;就可以用_self 代替this（函数实例）了；当然_self 也可以写成别的 比如$this等自定义的 &#125;*/ &#125; win.addHtml = addHtml; //把这个对象附给window底下的 名字叫addHtml的对象；要不你调用的时候 new addHtml() 怕在window的环境下找不到； &#125;(window, document)) &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; new addHtml(&quot;demo-1&quot;, &quot;add-1&quot;); //这里是实例1调用插件的代码 new addHtml(&quot;demo-2&quot;, &quot;add-2&quot;); //这里是实例2调用插件的代码 //是不是明白为什么要写插件了；要封装；两个相同组件即使有相同的class名在dom操作的时候也不会相互冲突；因为他们都new出来了个自的实例；有自己的this；有自己的一套方法了（其实方法都在原型里是公用的；操作各自的dom） &lt;/script&gt; &lt;!--这里是最简单的插件写法；当然还有传对象参数的插件等等。。。。--&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"ES6学习笔记","slug":"ES6学习笔记","date":"2018-09-07T01:26:41.000Z","updated":"2018-09-07T01:26:41.513Z","comments":true,"path":"2018/09/07/ES6学习笔记/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/07/ES6学习笔记/","excerpt":"","text":"ES6学习笔记ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准 let 和 const 命令1. let命令用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 2. 块级作用域为什么要使用块级作用域 ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域 let实际上为 JavaScript 新增了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 1&#123;&#123;&#123;&#123;&#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。 1234&#123;&#123;&#123;&#123; &#123;let insane = &apos;Hello World&apos;&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。 1234&#123;&#123;&#123;&#123; let insane = &apos;Hello World&apos;; &#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125;","categories":[],"tags":[]},{"title":"js数据类型","slug":"js数据类型","date":"2018-09-07T01:25:27.000Z","updated":"2018-09-07T06:46:28.824Z","comments":true,"path":"2018/09/07/js数据类型/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/07/js数据类型/","excerpt":"","text":"JS数据类型 概述 null，undefined 和布尔值 数值 字符串 对象 函数 数组 概述简介JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object） 数组（array） 函数（function） 狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。 typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof 运算符 instanceof 运算符 Object.prototype.toString 方法 instanceof运算符和Object.prototype.toString方法，将在后文介绍。这里介绍typeof运算符。 typeof运算符可以返回一个值的数据类型。 数值、字符串、布尔值分别返回number、string、boolean。 123typeof 123 // &quot;number&quot;typeof &apos;123&apos; // &quot;string&quot;typeof false // &quot;boolean&quot; 函数返回function。 123function f() &#123;&#125;typeof f// &quot;function&quot; undefined返回undefined。 12typeof undefined// &quot;undefined 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// &quot;undefined&quot; 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === &quot;undefined&quot;) &#123; // ...&#125; 对象返回object。 123typeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot; 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释。 12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true null返回object。 1typeof null // &quot;object&quot; null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。 null, undefined 和布尔值1. null 和 undefined1.1 概述null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 123var a = undefined;// 或者var a = null; 上面代码中，变量a分别被赋值为undefined和null，这两种写法的效果几乎等价。 在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log(&apos;undefined is false&apos;);&#125;// undefined is falseif (!null) &#123; console.log(&apos;null is false&apos;);&#125;// null is falseundefined == null// true 从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有null，没有undefined！ 既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。 1995年 JavaScript 诞生时，最初像 Java 一样，只设置了null表示”无”。根据 C 语言的传统，null可以自动转为0。 12Number(null) // 05 + null // 5 上面代码中，null转为数字时，自动变成0。 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，null就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果null自动转为0，很不容易发现错误。 因此，他又设计了一个undefined。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 12Number(undefined) // NaN5 + undefined // NaN 1.2 用法和含义对于null和undefined，大致可以像下面这样理解。 null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 2. 布尔值布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。 下列运算符会返回布尔值： 两元逻辑运算符：&amp;&amp; (And)，|| (Or) 前置逻辑运算符： !(Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 布尔值往往用于程序流程的控制，请看一个例子。 1234if (&apos;&apos;) &#123; console.log(&apos;true&apos;);&#125;// 没有任何输出 上面代码中，if命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出。 注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。 123456789if ([]) &#123; console.log(&apos;true&apos;);&#125;// trueif (&#123;&#125;) &#123; console.log(&apos;true&apos;);&#125;// true 数值1. 概述1.1 整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 123456780.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false 1.2 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位 1(-1)^符号位 * 1.xx...xx * 2^指数部分 上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。 精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。 1234567891011121314Math.pow(2, 53)// 9007199254740992 Math.pow(2, 53) + 1// 9007199254740992Math.pow(2, 53) + 2// 9007199254740994Math.pow(2, 53) + 3// 9007199254740996Math.pow(2, 53) + 4// 9007199254740996 上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。 123456Math.pow(2, 53)// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111// 9007199254740992000 上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。 1.3 数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 1Math.pow(2, -1075) // 0 下面是一个实际的例子 1234567var x = 0.5;for(var i = 0; i &lt; 25; i++) &#123; x = x * x;&#125;x // 0 上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 2. 数值的表示法JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。 数值也可以采用科学计数法表示，下面是几个科学计数法的例子。 1234123e3 // 123000123e-3 // 0.123-3.1E+12.1e-23 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。 （1）小数点前的数字多于21位。 123451234567890123456789012// 1.2345678901234568e+21123456789012345678901// 123456789012345680000 （2）小数点后的零多于5个。 123456// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003 // 3e-7// 否则，就保持原来的字面形式0.000003 // 0.000003 3. 数值的进制使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 1230xff // 2550o377 // 2550b11 // 3 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 1230xzz // 报错0o88 // 报错0b22 // 报错 上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。 通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。 120888 // 8880777 // 511 前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 4.特殊数值JavaScript 提供了几个特殊的数值。 4.1 正零和负零前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连0也不例外。 JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。 123-0 === +0 // true0 === -0 // true0 === +0 // true 几乎所有场合，正零和负零都会被当作正常的0。 1234+0 // 0-0 // 0(-0).toString() // &apos;0&apos;(+0).toString() // &apos;0&apos; 唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。 1(1 / +0) === (1 / -0) // false 上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的（关于Infinity详见下文）。 4.2 NaN4.2.1 含义NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 15 - &apos;x&apos; // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 10 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // &apos;number&apos; 4.2.2 运算规则NaN不等于任何值，包括它本身。 1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。 1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。 1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN 4.3 Infinity4.3.1 含义Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 1234567// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity 上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回Infinity。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。 1234Infinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity 上面代码中，非零正数除以-0，会得到-Infinity，负数除以-0，会得到Infinity。 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。 Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。 12Infinity &gt; 1000 // true-Infinity &lt; -1000 // true Infinity与NaN比较，总是返回false。 12345Infinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false 4.3.2 运算规则Infinity的四则运算，符合无穷的数学计算规则。 12345 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。 1230 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity Infinity加上或乘以Infinity，返回的还是Infinity。 12Infinity + Infinity // InfinityInfinity * Infinity // Infinity Infinity减去或除以Infinity，得到NaN。 12Infinity - Infinity // NaNInfinity / Infinity // NaN Infinity与null计算时，null会转成0，等同于与0的计算。 123null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity Infinity与undefined计算，返回的都是NaN。 12345undefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN 5. 与数值相关的全局方法5.1 parseInt()5.1.1 基本用法parseInt方法用于将字符串转为整数。 1parseInt(&apos;123&apos;) // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(&apos; 81&apos;) // 81 如果parseInt的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23) // 1// 等同于parseInt(&apos;1.23&apos;) // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt(&apos;8a&apos;) // 8parseInt(&apos;12**&apos;) // 12parseInt(&apos;12.34&apos;) // 12parseInt(&apos;15e2&apos;) // 15parseInt(&apos;15px&apos;) // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt(&apos;abc&apos;) // NaNparseInt(&apos;.3&apos;) // NaNparseInt(&apos;&apos;) // NaNparseInt(&apos;+&apos;) // NaNparseInt(&apos;+1&apos;) // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt(&apos;0x10&apos;) // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt(&apos;011&apos;) // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt(&apos;1e+21&apos;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&apos;8e-7&apos;) // 8 5.1.2 进制转换parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 123parseInt(&apos;1000&apos;) // 1000// 等同于parseInt(&apos;1000&apos;, 10) // 1000 下面是转换指定进制的数的例子。 123parseInt(&apos;1000&apos;, 2) // 8parseInt(&apos;1000&apos;, 6) // 216parseInt(&apos;1000&apos;, 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt(&apos;10&apos;, 37) // NaNparseInt(&apos;10&apos;, 1) // NaNparseInt(&apos;10&apos;, 0) // 10parseInt(&apos;10&apos;, null) // 10parseInt(&apos;10&apos;, undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 12parseInt(&apos;1546&apos;, 2) // 1parseInt(&apos;546&apos;, 2) // NaN 上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt(&apos;17&apos;, 36)parseInt(&apos;17&apos;, 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 1234567parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2) 上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 5.2 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 1parseFloat(&apos;3.14&apos;) // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat(&apos;314e-2&apos;) // 3.14parseFloat(&apos;0.0314E+2&apos;) // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat(&apos;3.14more non-digit characters&apos;) // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat(&apos;\\t\\v\\r12.34\\n &apos;) // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat(&apos;FF2&apos;) // NaNparseFloat(&apos;&apos;) // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat(&apos;&apos;) // NaNNumber(&apos;&apos;) // 0parseFloat(&apos;123.45#&apos;) // 123.45Number(&apos;123.45#&apos;) // NaN 5.3 isNaN()isNaN方法可以用来判断一个值是否为NaN。 12isNaN(NaN) // trueisNaN(123) // false 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。 123isNaN(&apos;Hello&apos;) // true// 相当于isNaN(Number(&apos;Hello&apos;)) // true 出于同样的原因，对于对象和数组，isNaN也返回true。 1234567isNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // trueisNaN([&apos;xzy&apos;]) // true// 等同于isNaN(Number([&apos;xzy&apos;])) // true 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 123isNaN([]) // falseisNaN([123]) // falseisNaN([&apos;123&apos;]) // false 上面代码之所以返回false，原因是这些数组能被Number函数转成数值。 因此，使用isNaN之前，最好判断一下数据类型。 123function myIsNaN(value) &#123; return typeof value === &apos;number&apos; &amp;&amp; isNaN(value);&#125; 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。 123function myIsNaN(value) &#123; return value !== value;&#125; 5.4 isFinite()isFinite方法返回一个布尔值，表示某个值是否为正常的数值。 123456isFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。 字符串1. 概述1.1 定义字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。 12&apos;abc&apos;&quot;abc&quot; 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12&apos;key = &quot;value&quot;&apos;&quot;It&apos;s a long journey&quot; 上面两个都是合法的字符串。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 12345&apos;Did she say \\&apos;Hello\\&apos;?&apos;// &quot;Did she say &apos;Hello&apos;?&quot;&quot;Did she say \\&quot;Hello\\&quot;?&quot;// &quot;Did she say &quot;Hello&quot;?&quot; 由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。 字符串默认只能写在一行内，分成多行将会报错。 1234&apos;abc&apos;// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript 就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = &apos;Long \\long \\long \\string&apos;;longString// &quot;Long long long string&quot; 上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = &apos;Long &apos; + &apos;long &apos; + &apos;long &apos; + &apos;string&apos;; 如果想输出多行字符串，有一种利用多行注释的变通方法。 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split(&apos;\\n&apos;).slice(1, -1).join(&apos;\\n&apos;)// &quot;line 1// line 2// line 3&quot; 上面的例子中，输出的字符串就是多行。 1.2 转义反斜杠（\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些。 \\0 ：null（\\u0000） \\b ：后退键（\\u0008） \\f ：换页符（\\u000C） \\n ：换行符（\\u000A） \\r ：回车键（\\u000D） \\t ：制表符（\\u0009） \\v ：垂直制表符（\\u000B） \\&#39; ：单引号（\\u0027） \\&quot; ：双引号（\\u0022） \\\\ ：反斜杠（\\u005C） 上面这些字符前面加上反斜杠，都表示特殊含义。 123console.log(&apos;1\\n2&apos;)// 1// 2 上面代码中，\\n表示换行，输出的时候就分成了两行。 反斜杠还有三种特殊用法。 （1）\\HHH 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\\251表示版权符号。显然，这种方法只能输出256种字符。 （2）\\xHH \\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\\xA9表示版权符号。这种方法也只能输出256种字符。 （3）\\uXXXX \\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\\u00A9表示版权符号。 下面是这三种字符特殊写法的例子。 1234567&apos;\\251&apos; // &quot;©&quot;&apos;\\xA9&apos; // &quot;©&quot;&apos;\\u00A9&apos; // &quot;©&quot;&apos;\\172&apos; === &apos;z&apos; // true&apos;\\x7A&apos; === &apos;z&apos; // true&apos;\\u007A&apos; === &apos;z&apos; // true 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。 12&apos;\\a&apos;// &quot;a&quot; 上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。 如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。 12&quot;Prev \\\\ Next&quot;// &quot;Prev \\ Next&quot; 1.3 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = &apos;hello&apos;;s[0] // &quot;h&quot;s[1] // &quot;e&quot;s[4] // &quot;o&quot;// 直接对字符串使用方括号运算符&apos;hello&apos;[1] // &quot;e&quot; 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123&apos;abc&apos;[3] // undefined&apos;abc&apos;[-1] // undefined&apos;abc&apos;[&apos;x&apos;] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 12345678910var s = &apos;hello&apos;;delete s[0];s // &quot;hello&quot;s[1] = &apos;a&apos;;s // &quot;hello&quot;s[5] = &apos;!&apos;;s // &quot;hello&quot; 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 1.4 length 属性length属性返回字符串的长度，该属性也是无法改变的。 12345678var s = &apos;hello&apos;;s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 2. 字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。 12var s = &apos;\\u00A9&apos;;s // &quot;©&quot; 解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。 12var f\\u006F\\u006F = &apos;abc&apos;;foo // &quot;abc&quot; 上面代码中，第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。 我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。 但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。 JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。 1&apos;𝌆&apos;.length // 2 上面代码中，JavaScript 认为𝌆的长度为2，而不是1。 总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 3. Base64 转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。 所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = &apos;Hello World!&apos;;btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;atob(&apos;SGVsbG8gV29ybGQh&apos;) // &quot;Hello World!&quot; 注意，这两个方法不适合非 ASCII 码的字符，会报错。 1btoa(&apos;你好&apos;) // 报错 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode(&apos;你好&apos;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;b64Decode(&apos;JUU0JUJEJUEwJUU1JUE1JUJE&apos;) // &quot;你好&quot; 对象1 概述1.1 生成方法对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。 什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 1234var obj = &#123; foo: &apos;Hello&apos;, bar: &apos;World&apos;&#125;; 上面代码中，大括号就定义了一个对象，它被赋值给变量obj，所以变量obj就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是foo: &#39;Hello&#39;，其中foo是“键名”（成员的名称），字符串Hello是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是bar: &#39;World&#39;，bar是键名，World是键值。两个键值对之间用逗号分隔。 1.2 键名对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。 1234var obj = &#123; &apos;foo&apos;: &apos;Hello&apos;, &apos;bar&apos;: &apos;World&apos;&#125;; 如果键名是数值，会被自动转为字符串。 1234567891011121314151617181920var obj = &#123; 1: &apos;a&apos;, 3.2: &apos;b&apos;, 1e2: true, 1e-2: true, .234: true, 0xFF: true&#125;;obj// Object &#123;// 1: &quot;a&quot;,// 3.2: &quot;b&quot;,// 100: true,// 0.01: true,// 0.234: true,// 255: true// &#125;obj[&apos;100&apos;] // true 上面代码中，对象obj的所有键名虽然看上去像数值，实际上都被自动转成了字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 1234567891011// 报错var obj = &#123; 1p: &apos;Hello World&apos;&#125;;// 不报错var obj = &#123; &apos;1p&apos;: &apos;Hello World&apos;, &apos;h w&apos;: &apos;Hello World&apos;, &apos;p+q&apos;: &apos;Hello World&apos;&#125;; 上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。 1234567var obj = &#123; p: function (x) &#123; return 2 * x; &#125;&#125;;obj.p(1) // 2 上面代码中，对象obj的属性p，就指向一个函数。 如果属性的值还是一个对象，就形成了链式引用。 12345var o1 = &#123;&#125;;var o2 = &#123; bar: &apos;hello&apos; &#125;;o1.foo = o2;o1.foo.bar // &quot;hello&quot; 上面代码中，对象o1的属性foo指向对象o2，就可以链式引用o2的属性。 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。 1234var obj = &#123; p: 123, m: function () &#123; ... &#125;,&#125; 上面的代码中，m属性后面的那个逗号，有没有都可以。 属性可以动态创建，不必在对象声明时就指定。 123var obj = &#123;&#125;;obj.foo = 123;obj.foo // 123 上面代码中，直接对obj对象的foo属性赋值，结果就在运行时创建了foo属性。 1.3 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 12345678var o1 = &#123;&#125;;var o2 = o1;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2 上面代码中，o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 12345var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125; 上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。 但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。 12345var x = 1;var y = x;x = 2;y // 1 上面的代码中，当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。 1.4 表达式还是语句?对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？ 1&#123; foo: 123 &#125; JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。 为了避免这种歧义，V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。 1(&#123; foo: 123&#125;) 这种差异在eval语句（作用是对字符串求值）中反映得最明显。 12eval(&apos;&#123;foo: 123&#125;&apos;) // 123eval(&apos;(&#123;foo: 123&#125;)&apos;) // &#123;foo: 123&#125; 上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象。 2. 属性的操作2.1 属性的读取读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。 123456var obj = &#123; p: &apos;Hello World&apos;&#125;;obj.p // &quot;Hello World&quot;obj[&apos;p&apos;] // &quot;Hello World&quot; 上面代码分别采用点运算符和方括号运算符，读取属性p。 请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。 123456789var foo = &apos;bar&apos;;var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo] // 2 上面代码中，引用对象obj的foo属性时，如果使用点运算符，foo就是字符串；如果使用方括号运算符，但是不使用引号，那么foo就是一个变量，指向字符串bar。 方括号运算符内部还可以使用表达式。 12obj[&apos;hello&apos; + &apos; world&apos;]obj[3 + 3] 数字键可以不加引号，因为会自动转成字符串。 123456var obj = &#123; 0.7: &apos;Hello World&apos;&#125;;obj[&apos;0.7&apos;] // &quot;Hello World&quot;obj[0.7] // &quot;Hello World&quot; 上面代码中，对象obj的数字键0.7，加不加引号都可以，因为会被自动转为字符串。 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。 123456var obj = &#123; 123: &apos;hello world&apos;&#125;;obj.123 // 报错obj[123] // &quot;hello world&quot; 上面代码的第一个表达式，对数值键名123使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。 2.2 属性的赋值点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。 1234var obj = &#123;&#125;;obj.foo = &apos;Hello&apos;;obj[&apos;bar&apos;] = &apos;World&apos;; 上面代码中，分别使用点运算符和方括号运算符，对属性赋值。 JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。 123456var obj = &#123; p: 1 &#125;;// 等价于var obj = &#123;&#125;;obj.p = 1; 2.3 属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// [&apos;key1&apos;, &apos;key2&apos;] 2.4 属性的删除：delete 命令delete命令用于删除对象的属性，删除成功后返回true。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 1234567var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 123, configurable: false&#125;);obj.p // 123delete obj.p // false 上面代码之中，对象obj的p属性是不能删除的，所以delete命令返回false。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 2.5 属性是否存在：in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。 123var obj = &#123; p: 1 &#125;;&apos;p&apos; in obj // true&apos;toString&apos; in obj // true in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。 1234var obj = &#123;&#125;;if (&apos;toString&apos; in obj) &#123; console.log(obj.hasOwnProperty(&apos;toString&apos;)) // false&#125; 2.6 属性的遍历：for…in 循环for...in循环用来遍历一个对象的全部属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log(&apos;键名：&apos;, i); console.log(&apos;键值：&apos;, obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: &apos;老张&apos; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 3. with 语句with语句的格式如下： 123with (对象) &#123; 语句;&#125; 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 1234567891011121314151617181920212223// 例一var obj = &#123; p1: 1, p2: 2,&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123; console.log(href); console.log(title); console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 上面代码中，对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1。正确的写法应该是，先定义对象obj的属性p1，然后在with区块内操作它。 这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。 123with (obj) &#123; console.log(x);&#125; 单纯从上面的代码块，根本无法判断x到底是全局变量，还是对象obj的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。 1234567with(obj1.obj2.obj3) &#123; console.log(p1 + p2);&#125;// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2); 函数函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。 1. 概述1.1 函数的声明JavaScript 有三种声明函数的方法 （1）function 命令 function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。 123function print(s) &#123; console.log(s);&#125; 上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。 （2）函数表达式 除了用function命令声明函数，还可以采用变量赋值的写法。 123var print = function(s) &#123; console.log(s);&#125;; 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 123456789var print = function x()&#123; console.log(typeof x);&#125;;x// ReferenceError: x is not definedprint()// function 上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。 1var f = function f() &#123;&#125;; 需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。 （3）Function 构造函数 第三种声明函数的方式是Function构造函数。 12345678910var add = new Function( &apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos;);// 等同于function add(x, y) &#123; return x + y;&#125; 上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。 你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。 12345678var foo = new Function( &apos;return &quot;hello world&quot;;&apos;);// 等同于function foo() &#123; return &apos;hello world&apos;;&#125; Function构造函数可以不使用new命令，返回结果完全一样。 总的来说，这种声明函数的方式非常不直观，几乎无人使用。 1.2 函数的重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 123456789function f() &#123; console.log(1);&#125;f() // 2function f() &#123; console.log(2);&#125;f() // 2 上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升，前一次声明在任何时候都是无效的，这一点要特别注意。 1.3 圆括号运算符，return 语句和递归调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。 12345function add(x, y) &#123; return x + y;&#125;add(1, 1) // 2 上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。 函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。 函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。 1234567function fib(num) &#123; if (num === 0) return 0; if (num === 1) return 1; return fib(num - 2) + fib(num - 1);&#125;fib(6) // 8 上面代码中，fib函数内部又调用了fib，计算得到斐波那契数列的第6个元素是8。 1.4 第一等公民JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。 由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。 12345678910111213function add(x, y) &#123; return x + y;&#125;// 将函数赋值给一个变量var operator = add;// 将函数作为参数和返回值function a(op)&#123; return op;&#125;a(add)(1, 1)// 2 1.5 函数名的提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。 123f();function f() &#123;&#125; 表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。 123f();var f = function ()&#123;&#125;;// TypeError: undefined is not a function 上面的代码等同于下面的形式。 123var f;f();f = function () &#123;&#125;; 上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。因此，如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 123456789var f = function () &#123; console.log(&apos;1&apos;);&#125;function f() &#123; console.log(&apos;2&apos;);&#125;f() // 1 2. 函数的属性和方法2.1 name 属性函数的name属性返回函数的名字。 12function f1() &#123;&#125;f1.name // &quot;f1&quot; 如果是通过变量赋值定义的函数，那么name属性返回变量名。 12var f2 = function () &#123;&#125;;f2.name // &quot;f2&quot; 但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。 12var f3 = function myName() &#123;&#125;;f3.name // &apos;myName&apos; 上面代码中，f3.name返回函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。 name属性的一个用处，就是获取参数函数的名字。 1234567var myFunc = function () &#123;&#125;;function test(f) &#123; console.log(f.name);&#125;test(myFunc) // myFunc 上面代码中，函数test内部通过name属性，就可以知道传入的参数是什么函数。 2.2 length 属性函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 12function f(a, b) &#123;&#125;f.length // 2 上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。 length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。 2.3 toString()函数的toString方法返回一个字符串，内容是函数的源码。 123456789101112function f() &#123; a(); b(); c();&#125;f.toString()// function f() &#123;// a();// b();// c();// &#125; 函数内部的注释也可以返回。 12345678910function f() &#123;/* 这是一个 多行注释*/&#125;f.toString()// &quot;function f()&#123;/*// 这是一个// 多行注释// */&#125;&quot; 利用这一点，可以变相实现多行字符串。 12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split(&apos;\\n&apos;); return arr.slice(1, arr.length - 1).join(&apos;\\n&apos;);&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// &quot; 这是一个// 多行注释&quot; 3. 函数作用域3.1 定义作用域（scope）指的是变量存在的范围。在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。 函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。 12345678var v = 1;function f() &#123; console.log(v);&#125;f()// 1 上面的代码表明，函数f内部可以读取全局变量v。 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。 12345function f()&#123; var v = 1;&#125;v // ReferenceError: v is not defined 上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。 函数内部定义的变量，会在该作用域内覆盖同名全局变量。 123456789var v = 1;function f()&#123; var v = 2; console.log(v);&#125;f() // 2v // 1","categories":[],"tags":[]},{"title":"JS基本语法","slug":"JS基本语法","date":"2018-09-07T01:23:21.000Z","updated":"2018-09-07T01:24:19.996Z","comments":true,"path":"2018/09/07/JS基本语法/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/07/JS基本语法/","excerpt":"","text":"JS基本语法什么是 JavaScript 语言JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。 1. 语句JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。 1var a = 1 + 3; 这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。 1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 1var a = 1 + 3 ; var b = &apos;abc&apos;; 分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。 1;;; 上面的代码就表示3个空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 121 + 3;&apos;abc&apos;; 上面两行语句只是单纯地产生一个值，并没有任何实际的意义。 2.变量2.1. 概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 1var a = 1; 上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。 注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。 12var a;a = 1; 如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。 12var a;a // undefined 如果变量赋值的时候，忘了写var命令，这条语句也是有效的。 123var a = 1;// 基本等同a = 1; 但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用var命令声明变量。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 12x// ReferenceError: x is not defined 上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。 可以在同一条var命令中声明多个变量。 1var a, b; JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 12var a = 1;a = &apos;hello&apos;; 上面代码中，变量a起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量a已经存在，所以不需要使用var命令。 如果使用var重新声明一个已经存在的变量，是无效的。 123var x = 1;var x;x // 1 上面代码中，变量x声明了两次，第二次声明是无效的。 但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 12345678var x = 1;var x = 2;// 等同于var x = 1;var x;x = 2; 2.2 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 3. 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 4. 注释源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法： 单行注释，用//起头； 多行注释，放在/*和*/之间。 1234567// 这是单行注释/* 这是 多行 注释*/ 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以也被视为合法的单行注释。 12x = 1; &lt;!-- x = 2;--&gt; x = 3; 上面代码中，只有x = 1会执行，其他的部分都被注释掉了。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 1234567function countdown(n) &#123; while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0 上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0。 5. 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。 12345&#123; var a = 1;&#125;a // 1 上面代码在区块内部，使用var命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于var命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如for、if、while、function等。 6. 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 6.1 if 结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示 真，false表示 伪。 12345if (布尔值) 语句;// 或者if (布尔值) 语句; 上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。 12if (m === 3) m = m + 1; 上面代码表示，只有在m等于3时，才会将其值加上1。 这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。 123if (m === 3) &#123; m += 1;&#125; 建议总是在if语句中使用大括号，因为这样方便插入语句。 注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 123456var x = 1;var y = 2;if (x = y) &#123; console.log(x);&#125;// &quot;2&quot; 上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于2）的布尔值（结果为true）。 这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值 12if (x = 2) &#123; // 不报错if (2 = x) &#123; // 报错 至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==）。 6.2 if…else 结构if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 12345if (m === 3) &#123; // 满足条件时，执行的语句&#125; else &#123; // 不满足条件时，执行的语句&#125; 上面代码判断变量m是否等于3，如果等于就执行if代码块，否则执行else代码块。 对同一个变量进行多次判断时，多个if...else语句可以连写在一起。 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; else代码块总是与离自己最近的那个if语句配对。 123456var m = 1;var n = 2;if (m !== 1)if (n === 2) console.log(&apos;hello&apos;);else console.log(&apos;world&apos;); 上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。 1234567if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125; else &#123; console.log(&apos;world&apos;); &#125;&#125; 如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。 12345678if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125;&#125; else &#123; console.log(&apos;world&apos;);&#125;// world 6.3 switch 结构多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。 12345678910switch (fruit) &#123; case &quot;banana&quot;: // ... break; case &quot;apple&quot;: // ... break; default: // ...&#125; 上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 12345678910111213var x = 1;switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); case 2: console.log(&apos;x 等于2&apos;); default: console.log(&apos;x 等于其他值&apos;);&#125;// x等于1// x等于2// x等于其他值 上面代码中，case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。正确的写法是像下面这样。 12345678910switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); break; case 2: console.log(&apos;x 等于2&apos;); break; default: console.log(&apos;x 等于其他值&apos;);&#125; switch语句部分和case语句部分，都可以使用表达式。 1234567switch (1 + 3) &#123; case 2 + 2: f(); break; default: neverHappens();&#125; 上面代码的default部分，是永远不会执行到的。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 12345678910var x = 1;switch (x) &#123; case true: console.log(&apos;x 发生类型转换&apos;); break; default: console.log(&apos;x 没有发生类型转换&apos;);&#125;// x 没有发生类型转换 上面代码中，由于变量x没有发生类型转换，所以不会执行case true的情况。这表明，switch语句内部采用的是“严格相等运算符”。 6.4 三元运算符 ?:JavaScript 还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。 1(条件) ? 表达式1 : 表达式2 上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。 1var even = (n % 2 === 0) ? true : false; 上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。 123456var even;if (n % 2 === 0) &#123; even = true;&#125; else &#123; even = false;&#125; 这个三元运算符可以被视为if...else...的简写形式，因此可以用于多种场合。 1234567var myVar;console.log( myVar ? &apos;myVar has a value&apos; : &apos;myVar does not have a value&apos;)// myVar does not have a value 上面代码利用三元运算符，输出相应的提示。 1var msg = &apos;数字&apos; + n + &apos;是&apos; + (n % 2 === 0 ? &apos;偶数&apos; : &apos;奇数&apos;); 上面代码利用三元运算符，在字符串之中插入不同的值。 7. 循环语句循环语句用于重复执行某个操作，它有多种形式。 7.1 while 循环While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 12345while (条件) 语句;// 或者while (条件) 语句; while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; 下面是while语句的一个例子。 123456var i = 0;while (i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i = i + 1;&#125; 上面的代码将循环100次，直到i等于100为止。 下面的例子是一个无限循环，因为循环条件总是为真。 123while (true) &#123; console.log(&apos;Hello, world&apos;);&#125; 7.2 for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。 12345678for (初始化表达式; 条件; 递增表达式) 语句// 或者for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; for语句后面的括号里面，有三个表达式。 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。 条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。 递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。 下面是一个例子。 1234567var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2 上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。 所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。 1234567var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。 123for ( ; ; )&#123; console.log(&apos;Hello World&apos;);&#125; 上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。 7.3 do…while 循环do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 12345678do 语句while (条件);// 或者do &#123; 语句&#125; while (条件); 不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。 下面是一个例子。 1234567var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); 7.4 break 语句和 continue 语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。 break语句用于跳出代码块或循环。 1234567var i = 0;while(i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i++; if (i === 10) break;&#125; 上面代码只会执行10次循环，一旦i等于10，就会跳出循环。 for循环也可以使用break语句跳出循环。 123456789for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break;&#125;// 0// 1// 2// 3 上面代码执行到i等于3，就会跳出循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 1234567var i = 0;while (i &lt; 100)&#123; i++; if (i % 2 === 0) continue; console.log(&apos;i 当前为：&apos; + i);&#125; 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。 7.5 标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label: 语句 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 标签也可以用于跳出代码块。 12345678foo: &#123; console.log(1); break foo; console.log(&apos;本行不会输出&apos;);&#125;console.log(2);// 1// 2 上面代码执行到break foo，就会跳出区块。 continue语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2","categories":[],"tags":[]},{"title":"学习jquery源码","slug":"学习jquery源码","date":"2018-09-07T01:21:00.000Z","updated":"2018-09-07T01:22:20.550Z","comments":true,"path":"2018/09/07/学习jquery源码/","link":"","permalink":"https://akitsukiwong.github.io/2018/09/07/学习jquery源码/","excerpt":"","text":"学习jQuery源码笔记1. 立即执行函数IIFE (立即调用的函数表达,Immediately-Invoked Function Expression，简称IIFE) 123(function() &#123; /*code*/&#125;)() 或者123(function() &#123; /*code*/&#125;()) IIFE的作用 不必为函数命名，避免了污染全局变量我们这里直接对匿名函数使用这种“立即执行的函数表达式”，并且在函数的在括号内定义之后立刻调用执行，这样避免为函数命名，减少命名的冲突 IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。在的JavaScript语法中我们知道作用域分为全局作用域和函数作用域(当然在后面的ES6中引入了块级作用域)，依据函数作用域这一特点，在匿名函数中我们可以封装一些自己内部模块使用的私有变量。 例子1234(function () &#123; var a=10;&#125;)();alert(a); 会报错 a is not defined","categories":[],"tags":[]},{"title":"mac 下svn的使用","slug":"mac-下svn的使用","date":"2018-07-13T01:48:15.000Z","updated":"2018-07-13T01:51:05.463Z","comments":true,"path":"2018/07/13/mac-下svn的使用/","link":"","permalink":"https://akitsukiwong.github.io/2018/07/13/mac-下svn的使用/","excerpt":"","text":"原来mac自带了svn，还挺好用的 以下是一些常用命令： 1、将文件checkout到本地目录 1 svn checkout path（path是服务器上的目录）2 例如：svn checkout svn://192.168.1.1/pro/domain3 简写：svn co 2、往版本库中添加新的文件 1 svn add file2 例如：svn add test.php(添加test.php)3 svn add *.php(添加当前目录下所有的php文件) 3、将改动的文件提交到版本库 1 svn commit -m “LogMessage“ [-N] [–no-unlock] PATH (如果选择了保持锁，就使用–no-unlock开关)2 例如： svn commit -m “add test file for my test“ test.php3 简写： svn ci 4、加锁/解锁 1 svn lock -m “LockMessage“ [–force] PATH2 例如：svn lock -m “lock test file“ test.php3 svn unlock PATH 5、更新到某个版本 1 svn update -r m path2 例如：3 svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。4 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200)5 svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)6 简写：svn up 6、查看文件或者目录状态 1 1）svn status path（目录下的文件和子目录的状态，正常状态不显示）2 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】3 2）svn status -v path(显示文件和子目录状态)4 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。5 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。6 简写：svn st 7、删除文件 1 svn delete path -m “delete test fle“2 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file”3 或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，推荐使用这种4 简写：svn (del, remove, rm) 8、查看日志 1 svn log path2 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化 9、查看文件详细信息 1 svn info path2 例如：svn info test.php 10、比较差异 1 svn diff path(将修改的文件与基础版本比较)2 例如：svn diff test.php3 svn diff -r m:n path(对版本m和版本n比较差异)4 例如：svn diff -r 200:201 test.php5 简写：svn di 11、将两个版本之间的差异合并到当前文件 1 svn merge -r m:n path2 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） 12、SVN 帮助 1 svn help2 svn help ci 13、版本库下的文件和目录列表 1 svn list path2 显示path目录下的所有属于版本库的文件和目录3 简写：svn ls 14、创建纳入版本控制下的新目录 复制代码 1 svn mkdir: 创建纳入版本控制下的新目录。2 用法: 1、mkdir PATH…3 2、mkdir URL…4 创建版本控制的目录。5 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增6 调度，以待下一次的提交。7 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。8 在这两个情况下，所有的中间目录都必须事先存在 复制代码 15、恢复本地修改 1 svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:2 用法: revert PATH…3 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复4 被删除的目录 16、代码库URL变更 复制代码 1 svn switch (sw): 更新工作副本至不同的URL。 2 用法: 1、switch URL [PATH] 3 2、switch –relocate FROM TO [PATH…] 4 5 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将 6 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的 7 方法。 8 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动 9 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用10 这个命令更新工作副本与仓库的对应关系。 复制代码 17、解决冲突 1 svn resolved: 移除工作副本的目录或文件的“冲突”状态。2 用法: resolved PATH…3 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的4 相关文件，然后让 PATH 可以再次提交。","categories":[],"tags":[]},{"title":"试一下Hexo Admin好不好用～","slug":"试一下Hexo-Admin好不好用～","date":"2018-07-12T04:23:00.000Z","updated":"2018-07-12T04:24:41.990Z","comments":true,"path":"2018/07/12/试一下Hexo-Admin好不好用～/","link":"","permalink":"https://akitsukiwong.github.io/2018/07/12/试一下Hexo-Admin好不好用～/","excerpt":"","text":"觉得原始的发blog太麻烦，所以装了个hexo admin 现在来尝试下发下博客 1 2 3 发送！","categories":[],"tags":[]},{"title":"基于 vue2 + vuex 构建一个具有 45 个页面的大型单页面应用","slug":"个页面的大型单页面应用","date":"2018-05-18T16:28:13.000Z","updated":"2018-05-18T16:30:33.709Z","comments":true,"path":"2018/05/19/个页面的大型单页面应用/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/19/个页面的大型单页面应用/","excerpt":"","text":"https://www.vue-js.com/topic/58abbd21a9c1282817afc28d github:https://github.com/bailicangdu/vue2-elm","categories":[],"tags":[]},{"title":"css3优惠券/邮票","slug":"css3优惠券-邮票","date":"2018-05-18T12:17:50.000Z","updated":"2018-05-18T12:20:50.751Z","comments":true,"path":"2018/05/18/css3优惠券-邮票/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/18/css3优惠券-邮票/","excerpt":"","text":"css3写的优惠券/邮票 码云地址：http://dflxm.gitee.io/code/%E9%82%AE%E7%A5%A8.html","categories":[],"tags":[{"name":"css3","slug":"css3","permalink":"https://akitsukiwong.github.io/tags/css3/"}]},{"title":"css3做banner","slug":"css3做banner","date":"2018-05-12T07:02:56.000Z","updated":"2018-05-12T07:14:17.458Z","comments":true,"path":"2018/05/12/css3做banner/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/12/css3做banner/","excerpt":"","text":"也是面试时候遇到的问题,回来随便弄了一个 在线地址：http://dflxm.oschina.io/code/ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;css3写一个banner&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; ul li &#123; list-style: none; &#125; .banner-box &#123; position: relative; width: 400px; height: 200px; overflow: hidden; &#125; .banner &#123; width: 1600px; position: absolute; left: 0; animation-name: bannerMove; animation-duration: 8s; animation-iteration-count: infinite; &#125; @keyframes bannerMove &#123; 0%, 30% &#123; left: 0; &#125; 35%, 65% &#123; left: -400px; &#125; 70%, 99% &#123; left: -800px; &#125; 100% &#123; left: -1200px; &#125; &#125; .banner li &#123; float: left; width: 400px; height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;banner-box&quot;&gt; &lt;ul class=&quot;banner&quot;&gt; &lt;li style=&quot;background-color:#f90;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#f00;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#9f0;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#333;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://akitsukiwong.github.io/tags/css/"}]},{"title":"css画三角形","slug":"css画三角形","date":"2018-05-12T06:13:43.000Z","updated":"2018-05-12T06:52:27.693Z","comments":true,"path":"2018/05/12/css画三角形/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/12/css画三角形/","excerpt":"","text":"面试时候遇到的问题，只要设置两个边框透明就行了,学会了这个，妈妈再也不怕我面试的时候被要求画三角形了 上三角 1234567#triangle-up &#123;width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-bottom: 100px solid red;&#125; 下三角 1234567#triangle-down &#123;width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-top: 100px solid red;&#125; 左三角 1234567#triangle-left &#123;width: 0;height: 0;border-top: 50px solid transparent;border-right: 100px solid red;border-bottom: 50px solid transparent;&#125; 右三角 1234567#triangle-right &#123;width: 0;height: 0;border-top: 50px solid transparent;border-left: 100px solid red;border-bottom: 50px solid transparent;&#125;","categories":[{"name":"代码片段","slug":"代码片段","permalink":"https://akitsukiwong.github.io/categories/代码片段/"}],"tags":[{"name":"css","slug":"css","permalink":"https://akitsukiwong.github.io/tags/css/"}]},{"title":"ECharts学习","slug":"2018-05-12 ECharts学习","date":"2018-05-12T06:10:04.000Z","updated":"2018-05-27T03:41:40.374Z","comments":true,"path":"2018/05/12/2018-05-12 ECharts学习/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/12/2018-05-12 ECharts学习/","excerpt":"","text":"面试了很多家单位，都问到了ECharts，所以准备一下还是很有必要的 2018-5-27 更新： 新单位也用到了ECharts，画了几个，也不难，官方文档也很全 主要就这几个步骤 引用js 准备放图表的容器 初始化图表，设置参数 有其它个性化要求，根据官方的文档，改一改配置项都可以快速解决","categories":[{"name":"笔记","slug":"笔记","permalink":"https://akitsukiwong.github.io/categories/笔记/"}],"tags":[]},{"title":"CSS初始化","slug":"2018-05-11 CSS初始化","date":"2018-05-11T09:24:49.000Z","updated":"2018-05-11T09:31:22.576Z","comments":true,"path":"2018/05/11/2018-05-11 CSS初始化/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/11/2018-05-11 CSS初始化/","excerpt":"","text":"为什么初始化css?考虑到浏览器兼容性问题，不同浏览器对标签的默认值是不同的 通用初始化样式1234567891011121314151617181920212223242526272829303132333435body&#123; margin: 0;padding: 0;font-family: &quot;微软雅黑&quot;;overflow: hidden;&#125;body,html&#123;-webkit-text-size-adjust: none;width: 100%;height: 100%;&#125;*&#123;text-decoration: none;list-style: none;&#125;img&#123;border: 0px;&#125;ul,li,dl,dd,dt,p,ol,h1,h2,h3,h4,h5&#123;font-size: 12px;font-weight: 100;padding: 0;margin: 0;&#125;.wrap&#123;margin: 0 auto;&#125;.fl&#123;float: left;&#125;.fr&#123;float: right;&#125;.index&#123;overflow: hidden;&#125;.clr&#123;clear:both; height:0px; width:100%; font-size:1px; line-height:0px; visibility:hidden; overflow:hidden;&#125;.pointer&#123;cursor:pointer;&#125;a,input,button&#123; outline:none; &#125;::-moz-focus-inner&#123;border:0px;&#125;/*a:link &#123;color:#0f0;text-decoration:none;&#125; a:visited &#123;color: #FFFF00; text-decoration:none;&#125; a:hover &#123;color: #00FF00; text-decoration:underline;&#125; a:active &#123;color: #0000FF; text-decoration:underline;&#125;*/a&#123;color: #000;&#125;.wrapper&#123;clear: both;width: 100%;&#125;table &#123; border-collapse:collapse; &#125;word-break:break-all /*文字换行*//*white-space:nowrap 文字不换行*//*默认滚动条样式修改ie9 google Firefox 等高版本浏览器有效*//*::selection &#123;background: #D03333;color: white;text-shadow: none;&#125;::-webkit-scrollbar-track-piece&#123;width:10px;background-color:#f2f2f2&#125;::-webkit-scrollbar&#123;width:10px;height:6px&#125;::-webkit-scrollbar-thumb&#123;height:50px;background-color:rgba(0,0,0,.3);&#125;::-webkit-scrollbar-thumb:hover&#123;background:#cc0000&#125;*//*渐变*//*background-image: -moz-linear-gradient(top, #8fa1ff, #3757fa);background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #ff4f02), color-stop(1, #8f2c00)); Saf4+, Chrome filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=&apos;#c6ff00&apos;, endColorstr=&apos;#538300&apos;, GradientType=&apos;0&apos;); IE*/ 另一种通用化样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* CSS Document */html, body, div, span, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,abbr, address, cite, code,del, dfn, em, img, ins,kbd, q, samp,small, strong, sub, sup, var,b, i,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot,thead,tr, th, td,article, aside, canvas, details, figcaption, figure, footer, header, hgroup, menu, nav, section, summary,time, mark, audio, video &#123; margin:0; padding:0; border:0; outline:0; font-size:100%; vertical-align:baseline; background:transparent; outline-style:none;/*FF*/ &#125;body &#123; line-height:1;&#125;a&#123; margin:0; padding:0; border:0; font-size:100%; vertical-align:baseline; background:transparent;&#125;a:hover,a:focus&#123; text-decoration:none; bblr:expression(this.onFocus=this.blur());/*IE*/ outline-style:none;/*FF*/ &#125;table &#123; border-collapse:collapse; border-spacing:0;&#125;input, select &#123; vertical-align:middle;&#125;/*css为clearfix，清除浮动*/.clearfix::before,.clearfix::after&#123; content: &quot;&quot;; height: 0; line-height: 0; display: block; visibility: hidden; clear: both;&#125;.clearfix:after&#123;clear:both;&#125; .clearfix&#123; *zoom:1;/*IE/7/6*/&#125; 雅虎工程师提供的CSS初始化示例代码12345678910111213141516body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px; &#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption, cite, code, dfn, em, strong, th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none; &#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123;overflow-y: scroll;&#125; .clearfix:after &#123;content: &quot;.&quot;; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; 腾讯官网 样式初始化123456789body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select&#123;margin:0;padding:0&#125; body&#123;font:12px&quot;宋体&quot;,&quot;Arial Narrow&quot;,HELVETICA;background:#fff;-webkit-text-size-adjust:100%;&#125; a&#123;color:#2d374b;text-decoration:none&#125; a:hover&#123;color:#cd0200;text-decoration:underline&#125; em&#123;font-style:normal&#125; li&#123;list-style:none&#125; img&#123;border:0;vertical-align:middle&#125; table&#123;border-collapse:collapse;border-spacing:0&#125; p&#123;word-wrap:break-word&#125; 新浪官网 样式初始化12345678910body,ul,ol,li,p,h1,h2,h3,h4,h5,h6,form,fieldset,table,td,img,div&#123;margin:0;padding:0;border:0;&#125; body&#123;background:#fff;color:#333;font-size:12px; margin-top:5px;font-family:&quot;SimSun&quot;,&quot;宋体&quot;,&quot;Arial Narrow&quot;;&#125; ul,ol&#123;list-style-type:none;&#125; select,input,img,select&#123;vertical-align:middle;&#125; a&#123;text-decoration:none;&#125; a:link&#123;color:#009;&#125; a:visited&#123;color:#800080;&#125; a:hover,a:active,a:focus&#123;color:#c00;text-decoration:underline;&#125; 淘宝官网 样式初始化12345678910111213141516171819202122232425body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125; body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \\5b8b\\4f53; &#125; h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125; address, cite, dfn, em, var &#123; font-style:normal; &#125; code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125; small&#123; font-size:12px; &#125; ul, ol &#123; list-style:none; &#125; a &#123; text-decoration:none; &#125; a:hover &#123; text-decoration:underline; &#125; sup &#123; vertical-align:text-top; &#125; sub&#123; vertical-align:text-bottom; &#125; legend &#123; color:#000; &#125; fieldset, img &#123; border:0; &#125; button, input, select, textarea &#123; font-size:100%; &#125; table &#123; border-collapse:collapse; border-spacing:0; &#125; 网易官网 样式初始化html &#123;overflow-y:scroll;&#125; body &#123;margin:0; padding:29px00; font:12px&quot;\\5B8B\\4F53&quot;,sans-serif;background:#ffffff;&#125; div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p&#123;padding:0; margin:0;&#125; table,td,tr,th&#123;font-size:12px;&#125; li&#123;list-style-type:none;&#125; img&#123;vertical-align:top;border:0;&#125; ol,ul &#123;list-style:none;&#125; h1,h2,h3,h4,h5,h6&#123;font-size:12px; font-weight:normal;&#125; address,cite,code,em,th &#123;font-weight:normal; font-style:normal;&#125; 下面顺便给出admin10000.com 的html模板，用于每次新开发页面使用。123456789101112131415161718&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;zh-cn&quot;&gt; &lt;head&gt; &lt;title&gt;网站标题 - Admin10000.com &lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot; /&gt; &lt;meta name=&quot;Author&quot; content=&quot;网页作者&quot; /&gt; &lt;meta name=&quot;Copyright&quot; content=&quot;网站版权&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;网站关键字&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;网站描述&quot; /&gt; &lt;link rel=&quot;Shortcut Icon&quot; href=&quot;网站.ico图标路径&quot; /&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;CSS文件路径&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;JS文件路径&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"代码片段","slug":"代码片段","permalink":"https://akitsukiwong.github.io/categories/代码片段/"}],"tags":[{"name":"css","slug":"css","permalink":"https://akitsukiwong.github.io/tags/css/"}]},{"title":"常见前端面试题","slug":"2018-05-10 常见前端面试题","date":"2018-05-10T14:20:58.000Z","updated":"2018-05-11T09:21:19.494Z","comments":true,"path":"2018/05/10/2018-05-10 常见前端面试题/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/10/2018-05-10 常见前端面试题/","excerpt":"","text":"HTML什么是盒子模型？在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素：a、b、span、img、input、strong、select、label、em、button、textarea块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img 块元素与内联元素的区别？1.块元素，总是在新行上开始；内联元素，和其他元素都在一行上。 2.块元素，能容纳其他块元素或内联元素；内联元素，只能容纳文本或者其他内联元素。 3.块元素中高度，行高以及顶和底边距都可控制；内联元素中高，行高及顶和底边距不可改变。 常见的块级元素 address – 地址 blockquote – 块引用 center – 举中对齐块 dir – 目录列表 div – 常用块级容易，也是CSS layout的主要标签 dl – 定义列表 fieldset – form控制组 form – 交互表单 h1 – 大标题 h2 – 副标题 h3 – 3级标题 h4 – 4级标题 h5 – 5级标题 h6 – 6级标题 hr – 水平分隔线 isindex – input prompt menu – 菜单列表 noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript – 可选脚本内容（对于不支持script的浏览器显示此内容） ol – 有序表单 p – 段落 pre – 格式化文本 table – 表格 ul – 无序列表 常见的内联元素 a – 锚点 abbr – 缩写 acronym – 首字 b – 粗体(不推荐) bdo – bidi override big – 大字体 br – 换行 cite – 引用 code – 计算机代码(在引用源码的时候需要) dfn – 定义字段 em – 强调 font – 字体设定(不推荐) i – 斜体 img – 图片 input – 输入框 kbd – 定义键盘文本 label – 表格标签 q – 短引用 s – 中划线(不推荐) samp – 定义范例计算机代码 select – 项目选择 small – 小字体文本 span – 常用内联容器，定义文本内区块 strike – 中划线 strong – 粗体强调 sub – 下标 sup – 上标 textarea – 多行文本输入框 tt – 电传文本 u – 下划线 CSSCSS实现垂直水平居中js如何理解闭包？定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。 表现形式：使函数外部能够调用函数内部定义的变量。 jQuery相关jQuery库中的$()是什么？$()函数是jQuery()函数的别称。$()函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $()函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。 其它","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://akitsukiwong.github.io/tags/面试/"}]},{"title":"随便做的一个个人简历","slug":"2018-05-10 随便做的一个个人简历","date":"2018-05-10T07:44:58.000Z","updated":"2018-05-11T09:07:22.744Z","comments":true,"path":"2018/05/10/2018-05-10 随便做的一个个人简历/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/10/2018-05-10 随便做的一个个人简历/","excerpt":"","text":"码云page地址: http://dflxm.oschina.io","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://akitsukiwong.github.io/tags/面试/"},{"name":"简历","slug":"简历","permalink":"https://akitsukiwong.github.io/tags/简历/"}]},{"title":"hexo的常用命令","slug":"2018-05-10 hexo的常用命令","date":"2018-05-09T17:43:33.000Z","updated":"2018-05-11T09:35:48.784Z","comments":true,"path":"2018/05/10/2018-05-10 hexo的常用命令/","link":"","permalink":"https://akitsukiwong.github.io/2018/05/10/2018-05-10 hexo的常用命令/","excerpt":"","text":"指令新建一篇文章1$ hexo new 新的文章名称 简写 1$ hexo n 新的文章名称 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: Hexokeywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 清除缓存文件 db.json 和已生成的静态文件 public1$ hexo clean 生成静态文件1$ hexo generate 简写 1$ hexo g 自动生成网站静态文件，并部署到设定的仓库1$ hexo deploy 简写 1$ hexo d 启动本地服务器，用于预览主题。默认地址： http://localhost:4000/ 1$ hexo s","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://akitsukiwong.github.io/tags/hexo/"}]},{"title":"rem.js","slug":"2017-12-18 rem-js","date":"2017-12-18T07:25:44.000Z","updated":"2018-05-11T09:08:54.638Z","comments":true,"path":"2017/12/18/2017-12-18 rem-js/","link":"","permalink":"https://akitsukiwong.github.io/2017/12/18/2017-12-18 rem-js/","excerpt":"","text":"12345678910111213window.onload = function()&#123; /*720代表设计师给的设计稿的宽度，你的设计稿是多少，就写多少;100代表换算比例，这里写100是 为了以后好算,比如，你测量的一个宽度是100px,就可以写为1rem,以及1px=0.01rem等等*/ getRem(750,100)&#125;;window.onresize = function()&#123; getRem(750,100)&#125;;function getRem(pwidth,prem)&#123; var html = document.getElementsByTagName(&quot;html&quot;)[0]; var oWidth = document.body.clientWidth || document.documentElement.clientWidth; html.style.fontSize = oWidth/pwidth*prem + &quot;px&quot;;&#125;","categories":[{"name":"代码片段","slug":"代码片段","permalink":"https://akitsukiwong.github.io/categories/代码片段/"}],"tags":[{"name":"js","slug":"js","permalink":"https://akitsukiwong.github.io/tags/js/"},{"name":"rem","slug":"rem","permalink":"https://akitsukiwong.github.io/tags/rem/"}]},{"title":"pc端移动端跳转js","slug":"2017-12-18 pc端移动端跳转js","date":"2017-12-17T17:43:33.000Z","updated":"2018-05-11T09:47:51.590Z","comments":true,"path":"2017/12/18/2017-12-18 pc端移动端跳转js/","link":"","permalink":"https://akitsukiwong.github.io/2017/12/18/2017-12-18 pc端移动端跳转js/","excerpt":"经常用到的跳转代码","text":"经常用到的跳转代码 if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href=”你的手机版地址”;}else{ window.location.href=”你的电脑版地址”;}","categories":[{"name":"代码片段","slug":"代码片段","permalink":"https://akitsukiwong.github.io/categories/代码片段/"}],"tags":[{"name":"js","slug":"js","permalink":"https://akitsukiwong.github.io/tags/js/"},{"name":"跳转","slug":"跳转","permalink":"https://akitsukiwong.github.io/tags/跳转/"}]},{"title":"javascript高级程序设计学习笔记","slug":"2017-12-01 javascript高级程序设计学习笔记","date":"2017-11-30T17:45:22.000Z","updated":"2018-05-11T08:51:00.541Z","comments":true,"path":"2017/12/01/2017-12-01 javascript高级程序设计学习笔记/","link":"","permalink":"https://akitsukiwong.github.io/2017/12/01/2017-12-01 javascript高级程序设计学习笔记/","excerpt":"","text":"第一章 HTML中使用JavaScriptscript元素script中有六个属性 async charset defer language src type 标签的位置传统做法放在&lt;head&gt;中，js会被先加载页面会有延迟 所以把JavaScript引入放在&lt;body&gt;元素中页面元素的后面 这样先加载页面内容，用户会因为空白页面时间缩短而感到页面打开速度加快 延迟脚本HTML 4.01为&lt;script&gt;标签定义了defer属性。 相当于告诉浏览器立即下载延迟执行。 1&lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt; 异步脚本async 1&lt;script type=&apos;text/javascript&apos; async src=&apos;example.js&apos;&gt;&lt;/script&gt; 在XHTML中的用法XTML（可拓展超文本标记语言），是将HTML作为XML的应用而重新定于的一个标准规则比HTML严格 第二章 基本概念语法ECMAScript大量借鉴C及其他类C语言（Java等） 区分大小写ECMAScript中一切（变量、函数名和操作符）都区分大小写。 标识符标识符，指变量、函数、属性都名字，或者函数的参数。 第一个字符必须是字母、下划线（_）或者一个美元符号（$）； 其他字符可以是字母、下划线、美元符号或数字。 注释C风格注释 123456// 单行注释/** 这是一个多行*（块级）注释*/ 严格模式ECMAScript 5 引入严格模式 启用严格模式可在顶部添加use strict; 1234function()&#123; &quot;use strict&quot;; //函数体&#125; 语句分号结尾；代码块{ } 里面 关键字和保留字变量ECMAScript的变量是松散类型的，可以保存任何类型的数据。 定义变量使用 var 操作符 函数中var的是局部变量，省略var是全局变量 定义多个变量（用逗号隔开） 123var message = &quot;hi&quot; , found = false , age = 29 ; 数据类型ES中有五种简单的数据类型 1- Undefined —– 未定义 2- Null ————- 3- Boolean ——– 布尔值 4- Number ——— 数值 5- String ———— 还有一种复杂数据类型 Object typeof 操作符12var message = &quot;some string&quot; ;alert(typeof message) ; //&quot;string&quot; typeof 返回值 undefined —— 为定义 boolean ——— 布尔值 string ———— 字符串 number ———- 数值 object ———— 对象 或者 null function ———- 函数 undefined 类型var 声明变量但为对其加以初始化的值就是undefined Null类型Boolean 类型true和false Number类型 整数和浮点数（带小数点的数值，小数点后至少有一位数字） 浮点数值极大极小的数字用e表示法（科学计数法） 12var floatNum = 3.125e7 //31250000var floatNum = 3e-17 //0.00000000000000003 浮点数值最高精度为17位小数，其计算精度远远不如整数，例如 0.1 + 0.2 结果不是 0.3 而是 0.300000000000004。 数值范围 Infinity （负无穷） Infinity （正无穷） NaN非数值 （not a number） 任何涉及NaN的操作都会返回NaN NaN和任何值都不相等，包括NaN 1alert（NaN == NaN） //false isNaN（）函数，查询是否为数值 123alert(isNaN(NaN)); //truealert(isNaN(10)); //false(10是一个数值)alert(isNaN(&quot;blue&quot;)) //true 数值转换 number() – 如果是布尔值，返回0和1 – 如果是数字，简单的传入和返回 – 如果是null，返回0 – 如果是undefined，返回NaN – 如果是字符串……… – 如果是对象，调用valueOf( ) 方法，如果转换的对象是NaN，调用toString（）方法 parseInt() parseFloat() string 类型单引号和双引号字符串形式完全相同 字符字面量string数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符 \\n 换行 \\t 制表 \\b 退格 等… 字符串的特点ES中字符串是不可变的，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充改变量。 转换为字符串toString（） Object 类型对象其实就是一组数据和功能的集合。对象可以通过new操作符来创建 1var o = new Object( ) ; （括号可以省略，但不推荐） 操作符一元操作符只能操作一个值但操作符叫做一元操作符。 递增和递减操作符++age；等于age = age +1; –age; 等于age = age - 1； 【前置型】会影响语句的结果，求值之前执行 【后置型】不会影响语句结果，求值之后执行 例子 1234var num1 = 2 ;var num2 = 20 ;var num3 = --num + num2 ; //21var num4 = num1 + num2 ; //21 1234var num1 = 2 ;var num2 = 20 ;var num3 = num-- + num2 ; //22var num4 = num1 + num2 ; //21 一元加和减操作符一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。 12var num = 25 ;num = +num ; //25 一元减操作符主要表示负数。 位操作符转化位二进制 12var num = -18 ;alert(num.toString(2)) ; //&quot;-10010&quot; 按位非（NOT）按位非由一个波浪号【～】表示，执行按位非的结果就是返回数值的反码（二进制逐位取反） 按位与（AND）按位与由一个和字符号【&amp;】表示，都是1返回1，有0就返回0 按位或（OR）按位或由一个竖线符号【|】表示，有1返回1，都是0才返回0 左移【&lt;&lt;】，会将数值的所有位向左移动制定的位数。 12var oldValue = 2 ; //二进制10var newValue = oldValue &lt;&lt; 5; //二进制100000，即64 右移【&gt;&gt;】,会将数值向右移动，但保留符号位 12var oldValue = 64 ; //二进制1000000var newValue = oldValue &gt;&gt; 5; //二进制10，即2 无符号右移【&gt;&gt;&gt;】，会将数值的所有32位都向右移动。 对于正数于【&gt;&gt;】一样，对于负数无符号右移后结果会变得非常大，因为无符号右移会移动所有的二进制码。 12var oldValue = -64 ; //二进制1000000var newValue = oldValue &gt;&gt;&gt; 5; //十进制134217726 3.5.3 布尔操作符布尔操作符一共三个 非（NOT）【 ！】 与（AND） 【 &amp;&amp; 】 或（OR） 【 || 】 乘性操作符 乘法 【 * 】 除法 【 / 】 求模 （余数） 【 % 】 1var result = 26 % 5 ; //等于 1 加性操作符 加法 【 + 】 减法 【 - 】 关系操作符 小于 【 &lt; 】 大于 【 &gt; 】 小于等于 【 &lt;= 】 大于等于 【 &gt;= 】 相等操作符相等和不相等（先转换再比较） 全等和不全等（仅比较不转换） 相等和不相等 相等 【 == 】 不相等 【 != 】 全等和不全等 全等 【 === 】 不全等 【 !== 】 条件操作符1variable = boolean_expression ? true_value : false_value 基于对boolean_expression求值对结果，决定给变量variable赋什么值。如果为true，赋true_value值，如果为false，赋false_value值 1var max = (num1 &gt; num2) ? num1 : num2 ; max将保存最大对值，表达式意思是：如果num1大于num2，给max赋num1值，反之赋值num2 赋值操作符简单赋值操作符由符号【 = 】表示，作用：把右侧对值赋给左侧对变量 逗号操作符可以在一条语句中执行多个操作 1var num1 = 1, num2 = 2, num3 = 3; 逗号操作符还可以用作赋值，会返回表达式对最后一项。 1var num = ( 5, 1, 4, 8, 0); //num的值为0，因为0是表达式的最后一项 语句if语句12345if ( condition【条件】 ) &#123; statement1【语句1】； &#125; else &#123; statement【语句2】； &#125; 1234567if( condition1【条件1】 )&#123; statement1【语句1】；&#125; else if ( condition2【条件2】 )&#123; statemen2【语句2】；&#125; else &#123; statement3【语句3】；&#125; do-while 语句12345do&#123; statement【语句】&#125; while &#123; expression【条件】&#125; while 语句123while( expression【条件】 )&#123; statement【语句】&#125; for语句for语句也是一种前端测试循环语句，它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。 123for(initialization【初始化】; expression【条件】; post-loop-expression【循环表达式】)&#123; statement【语句】;&#125; 当三个表达式全部省略就会创建一个无限循环 123for( ; ; )&#123; //无限循环 doSomething();&#125; 3.6.5 for-in语句for-in语句是一种精准当迭代语句，可以用来枚举对象当属性。 123for( property【属性】 in expression)&#123; statement【语句】&#125; 3.6.6 label语句1label【标签】: statement 123start: for (var i = 0; i &lt; count; i++)&#123; alert(i);&#125; 3.6.7 break和continue语句break和continue用于在循环中精确的控制代码的执行【break】立即退出循环，强制继续执行循环后面的语句【continue】立即退出循环，退出循环后会从循环的顶部继续执行break和continue都可以和label语句联合使用，从而返回代码中特定的位置。 3.6.8 with语句123with(expreession【条件】)&#123; statement【语句】&#125; with语句主要目的是为了简化多次编写同一个对象的工作123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 以上代码都包含了location对象，用with语句12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 不建议使用过with语句 3.6.9 switch 语句1234567891011switch(expression)&#123; case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; 相当于if-else语句简化写法123456789if(i == 25)&#123; alert(&quot;25&quot;);&#125; else if(i == 35)&#123; alert(&quot;35&quot;)&#125; else if(i == 45)&#123; alert(&quot;45&quot;)&#125;else &#123; alert(&quot;other&quot;)&#125; 等价于switch语句12345678910111213switch( i )&#123; case 25: alert(&quot;25&quot;); break; case 35: alert(&quot;35&quot;); break; case 45: alert(&quot;45&quot;); break; default: alert(&quot;other&quot;);&#125; 3.7 函数123function functionName(arg0, arg1, ...,argN)&#123; statements&#125; 位于语句之后都任何代码都永远不会执行 3.7.1 理解参数命名的参数只提供便利，但不是必须的 3.7.2 没有重载第三章 变量、作用域和内存问题4.1 基本类型和引用类型的值【基本类型】简单的数据段【引用类型】可能有多个值构成的对象 4.1.1 动态的属性4.1.2 复制变量值4.1.3 传递参数当在函数内部重写obj时，这个变量引用的就是一个局部对象，这个局部对象会在函数执行完毕后立即销毁。12345678function setName(obj)&#123; obj.name = &quot;Nicholas&quot;; obj = new Object(); obj.name = &quot;Greg&quot;;&#125;var person = new Object();set.Name(person);alert(person.name); //&quot;Nicholas&quot; 4.1.4 检测类型instanceof操作符1result = variable instanceof constructor 例子123alert(person instanceof Object); //变量person是Object吗？alert(colors instanceof Array); //变量colors是Array吗？alert(pattern instanceof RegExp); //变量pattern是RegExp吗？ 4.2 执行环境及作用域延长作用域链4.2.2 没有块级作用域声明变量使用var声明的变量会自动添加到最接近到环境中如果初始化变量没有使用var 声明，该变量会自动被添加到全局环境。 查询标识符4.3 垃圾收集js具有垃圾自动收集功能 4.3.1 标记清除4.3.2 引用计数4.3.3 性能问题4.3.4 管理内存第五章 引用类型5.1 Object类型创建Object实例有两种方式 使用new操作符后跟Object构造函数123var person = new Object();person.name = &quot;Nicholas&quot;;person.age = &quot;29&quot;; Object可以省略，用大括号代替123var person = &#123;&#125;;person.name = &quot;Nicholas&quot;;person.age = &quot;29&quot;; 使用对象字面量表示法，是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。1234var person = &#123; name = &quot;Nicholas&quot; , age = 29&#125;; 访问对象属性可以用点表示法，也可以用方括号12alert(person.name); //Nicholasalert(person[&quot;name&quot;]); //Nicholas 方括号语法的主要优点是可以通过变量来访问属性12var propertyName = &quot;name&quot;;alert(person[propertyName]); //Nicholas 5.2 array类型创建数组有两种方法1var colors = new Array(); 创建length值为20的数组1var colors = new Array( 20 ); 也可以向Array构造函数传递数组中应该包含的项1var colors = new Array( &quot;red&quot;,&quot;blue&quot;,&quot;green&quot; ); 可以省略new操作符1var colors = Array(); 可以使用字面量表示法，数组用方括号表示，逗号隔开12var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; var names = [] //创建一个空数组 利用length属性可以方便的在数组末尾添加新项123var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; colors[colors.length] = &quot;black&quot;; //在位置3添加一种颜色colors[colors.length] = &quot;brown&quot; //在位置4添加一种颜色 5.2.1 检测数组123if(value instanceof Array)&#123; //do something&#125; ES5新增的Array.isArray()方法，用于确定某个值到底是不是数组，而不管它是在哪个全局环境下创建的。123if(Array.isArray(value))&#123; //do something&#125; 5.2.2 转换方法join方法可以使用不同的分隔符来构建这个字符串join方法只接受一个参数，用作分隔符的字符串123var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];alert(colors.join(&quot;,&quot;)); //red,blue,greenalert(colors.join(&quot;||&quot;)); //red||blue||green 5.2.3 栈方法栈是一种【LOFO】后进先出的数据结构栈中 插入叫做推入，移除叫做弹出 push() 接收任意数量的参数逐个添加到数组末尾（从末尾加）pop() 从数组末尾移除最后一项（删最后一个） 5.2.4 队列方法队列是【FIFO】先进先出 shift() 移除数组中的第一个项（删第一个）unshift() 在数组前端添加任意个项（从前面加） 5.2.5 重排列方法reverse() 翻转数组项的顺序sort() 升序排列（首字母排序，不是按大小） 比较函数 升序1function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //0,1,5,10,15 降序1function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //15,10,5,1,0 5.2.6 操作方法concat() 末尾添加数组 splice() 数组中部插入项 删除splice（要删除的第一项的位置， 要删除的项数）splice( 0, 2 ) 删除数组中前两项 插入splice( 起始位置， 0（要删除的项数）， 要插入的项)splice( 2, 0, &quot;red&quot;, &quot;green&quot; ) 从当前数组的位置2 开始插入字符串“red” 和“green” 替换splice( 起始位置， 要删除的项数， 要插入的任意数量的项)splice( 2, 1, &quot;red&quot;, &quot;green&quot; ) 会删除当前数组位置 2 的项， 然后再从位置 2 开始插入字符串 “red” 和“green”例子 1var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; var removed = colors.splice(0,1); //remove the first item alert(colors); //green,blue alert(removed); //red - one item array removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); //insert two items at position 1 alert(colors); //green,yellow,orange,blue alert(removed); //empty array removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //insert two values, remove one alert(colors); //green,red,purple,orange,blue alert(removed); //yellow - one item array 5.2.7 位置方法indexOf() 从数组的开头（位置0）开始向后查找， 没找到的情况下会返回-1lastIndexOf 从数组的末尾开始向前查找， 没找到的情况下会返回-1例子 1234567891011121314var numbers = [1,2,3,4,5,4,3,2,1]; alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5 alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3 var person = &#123; name: &quot;Nicholas&quot; &#125;;var people = [&#123; name: &quot;Nicholas&quot; &#125;];var morePeople = [person]; alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 5.2.8 迭代方法every() 对数组中的每一项运行给定函数， 如果该函数对每一项都返回true， 则返回true。filter() 对数组中的每一项运行给定函数， 返回该函数会返回 true 的项组成的数组。forEach() 对数组中的每一项运行给定的函数。 这个方法没有返回值。map() 对数组中的每一项运行给定的函数， 返回每次函数调用的结果组成的数组。some() 对数组中的每一项运行给定的函数， 如果该函数对任一项返回true， 则返回true。 以上方法都不会修改数组中的包含的值， 传入这些方法会接受三个参数（数组项的值， 该项在数组中的位置， 数组对象本身） every() some() 例子以上代码调用的every() 和 some() ， 传入的函数只要给定项大于 2 就会返回true， 对于every()，它返回的是false， 因为只有部分数组项符合条件，对于some() 就返回true， 因为至少有一项是大于 2 的。 12345678910111213var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true filter() 例子通过filter（）方法创建并返回一个所有数值都大于 2 的数组 1234567var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3] map() 例子给数组中每一项都乘以 21234567var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] forEach() 例子1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;) 5.2.9 归并方法reduce() 从数组第一项开始逐个遍历到最后reduceRight() 从数组最后一项开始，向前遍历到第一项四个参数（前一个值， 当前值， 项的索引， 数组对象） reduce() 例子求数组所有值之和12345var values = [1,2,3,4,5]; var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur; &#125;); alert(sum); reduceRight() 例子求数组所有值之和 12345var values = [1,2,3,4,5]; var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur; &#125;); alert(sum); 5.3 Data 类型Data.parse()-接收一个表示日期的字符串参数，然后根据这个字符串返回相应日期的毫秒数Data.UTC()-同样返回日期的毫秒数，但参数分别是年份、基于0但月份（一月是0，二月是1…）、月中的哪一天（1-31）、小时数（0-23）、分钟、秒、毫秒数。只有前两个参数，年和月是必须的 12345//GMT时间2000年1月1日午夜零时var y2k = new Data(Data.UTC(2000,0));//GMT时间2005年5月5日下午5:55:55var allFive = new Data(Data.UTC(2005,4,5,17,55,55)); ES5中添加来Data.now()方法 5.3.1 继承的方法","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://akitsukiwong.github.io/categories/前端学习/"}],"tags":[{"name":"js","slug":"js","permalink":"https://akitsukiwong.github.io/tags/js/"}]},{"title":"数组常用方法","slug":"2017-11-20 数组常用方法","date":"2017-11-20T07:04:48.000Z","updated":"2018-05-11T09:43:03.292Z","comments":true,"path":"2017/11/20/2017-11-20 数组常用方法/","link":"","permalink":"https://akitsukiwong.github.io/2017/11/20/2017-11-20 数组常用方法/","excerpt":"","text":"栈方法push() 接收任意数量的参数逐个添加到数组末尾（从末尾加） pop() 从数组末尾移除最后一项（删最后一个） 队列方法shift() 移除数组中的第一个项（删第一个） unshift() 在数组前端添加任意个项（从前面加） 重排列方法reverse() 翻转数组项的顺序 sort() 升序排列（首字母排序，不是按大小） 比较函数升序12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //0,1,5,10,15 降序12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //15,10,5,1,0 操作方法concat() 末尾添加数组 1contan( [ &quot;black&quot; , &quot;yellow&quot; , &quot;red&quot; ] ) splice() 数组中部插入项 删除splice（要删除的第一项的位置， 要删除的项数） splice( 0, 2 ) 删除数组中前两项 插入splice( 起始位置， 0（要删除的项数）， 要插入的项) splice( 2, 0, &quot;red&quot;, &quot;green&quot; )从当前数组的位置2 开始插入字符串“red” 和“green” 替换splice( 起始位置， 要删除的项数， 要插入的任意数量的项) splice( 2, 1, &quot;red&quot;, &quot;green&quot; ) 会删除当前数组位置 2 的项， 然后再从位置 2 开始插入字符串 “red” 和“green” 例子 123456789101112var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1); //remove the first itemalert(colors); //green,bluealert(removed); //red - one item array removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); //insert two items at position 1alert(colors); //green,yellow,orange,bluealert(removed); //empty array removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //insert two values, remove onealert(colors); //green,red,purple,orange,bluealert(removed); //yellow - one item array 位置方法indexOf() 从数组的开头（位置0）开始向后查找， 没找到的情况下会返回-1 lastIndexOf 从数组的末尾开始向前查找， 没找到的情况下会返回-1 例子 1234567891011121314var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5 alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3 var person = &#123; name: &quot;Nicholas&quot; &#125;;var people = [&#123; name: &quot;Nicholas&quot; &#125;];var morePeople = [person]; alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 迭代方法every() 对数组中的每一项运行给定函数， 如果该函数对每一项都返回true， 则返回true。 filter() 对数组中的每一项运行给定函数， 返回该函数会返回 true 的项组成的数组。 forEach() 对数组中的每一项运行给定的函数。 这个方法没有返回值。 map() 对数组中的每一项运行给定的函数， 返回每次函数调用的结果组成的数组。 some() 对数组中的每一项运行给定的函数， 如果该函数对任一项返回true， 则返回true。 以上方法都不会修改数组中的包含的值， 传入这些方法会接受三个参数（数组项的值， 该项在数组中的位置， 数组对象本身） every() some() 例子以上代码调用的every() 和 some() ， 传入的函数只要给定项大于 2 就会返回true， 对于every()，它返回的是false， 因为只有部分数组项符合条件，对于some() 就返回true， 因为至少有一项是大于 2 的。 12345678910111213var numbers = [1,2,3,4,5,4,3,2,1]; var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(everyResult); //false var someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(someResult); //true filter() 例子通过filter（）方法创建并返回一个所有数值都大于 2 的数组 1234567var numbers = [1,2,3,4,5,4,3,2,1]; var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(filterResult); //[3,4,5,4,3] map() 例子给数组中每一项都乘以 2 1234567var numbers = [1,2,3,4,5,4,3,2,1]; var mapResult = numbers.map(function(item, index, array)&#123; return item * 2; &#125;); alert(mapResult); //[2,4,6,8,10,8,6,4,2] forEach() 例子1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;) 归并方法reduce() 从数组第一项开始逐个遍历到最后 reduceRight() 从数组最后一项开始，向前遍历到第一项 四个参数（前一个值， 当前值， 项的索引， 数组对象） reduce() 例子求数组所有值之和 12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); reduceRight() 例子求数组所有值之和 12345var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum);","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://akitsukiwong.github.io/categories/前端学习/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://akitsukiwong.github.io/tags/数组/"},{"name":"js","slug":"js","permalink":"https://akitsukiwong.github.io/tags/js/"}]},{"title":"Markdown学习","slug":"2017-11-13 Markdown学习","date":"2017-11-13T07:16:21.000Z","updated":"2018-05-11T08:51:14.991Z","comments":true,"path":"2017/11/13/2017-11-13 Markdown学习/","link":"","permalink":"https://akitsukiwong.github.io/2017/11/13/2017-11-13 Markdown学习/","excerpt":"","text":"一级标题H1二级标题H2三级标题H3四级标题H4五级标题H5六级标题H6无序列表 列表1 列表2 列表3 或者 列表1 列表1 列表1 再或者 列表1 列表1 列表1 引用 这个样子引用，啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦 还有个二级的引用，哈哈哈哈哈哈哈哈哈哈哈哈或或或或或或或或或或或或或或或或或或或或或 三级的引用，看了啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦 回归一级吧，记得要空一行 例子 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 代码区块这是一个普通段落： 这是一个代码区块。 前面一个制表符就是代码 或者四个空格 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理 分割线 链接I get 10 times more traffic from Google than fromYahoo or MSN. I get 10 times more traffic from Google than fromYahoo or MSN. 一小段代码Use the printf() function.There is a literal backtick (`) here.A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 dog bird cat foo foo foo bar bar bar baz baz baz","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://akitsukiwong.github.io/tags/Markdown/"}]}]}